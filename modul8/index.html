<!DOCTYPE html>
<html lang=pl class="no-js">
<head>
    <meta name="ahrefs-site-verification" content="c2d3c04b9f125c5b8c98d89f738d343f69d841f035150344a932150235c5639a">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="csrf-token" content="FGlA4RkObUo18UXAEnOqvfNMqmQValvEVBDjQsbF" />

<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="https://kodilla.com/static/img/icons/apple-touch-icon-60x60.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="https://kodilla.com/static/img/icons/apple-touch-icon-76x76.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="https://kodilla.com/static/img/icons/apple-touch-icon-120x120.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://kodilla.com/static/img/icons/apple-touch-icon-152x152.png?00000">
<link rel="icon" type="image/png" sizes="32x32" href="https://kodilla.com/static/img/icons/favicon-32x32.png?00000">
<link rel="icon" type="image/png" sizes="96x96" href="https://kodilla.com/static/img/icons/favicon-96x96.png?00000">
<link rel="icon" type="image/png" sizes="16x16" href="https://kodilla.com/static/img/icons/favicon-16x16.png?00000">

    <link rel="canonical" href="https://kodilla.com/pl/bootcamp-module/407/530/5935" />

    <meta name="robots" content="noindex, follow" />
    <title>    Moduł: 8. Programowanie obiektowe w JS-ie
</title>
        <script>document.documentElement.classList.remove("no-js")</script>
<script src="https://kodilla.com/static/js/libs/yall.min.js?00000"></script>
<link href="https://kodilla.com/static/css/libs/bootstrap.min.css?00000" rel="stylesheet">
<link href="https://kodilla.com/static/css/libs/font-awesome.min.css?00000" rel="stylesheet">
<link href="https://kodilla.com/build/minified/css/main-b3cf79332c.css" rel="stylesheet" type="text/css">
            
    <link href="https://kodilla.com/static/css/libs/prism.min.css?00000" rel="stylesheet">

    <link href="https://kodilla.com/build/minified/css/bootcamp-6d0888d826.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://kodilla.com/static/css/libs/perfect-scrollbar.css?00000" />
    <link rel="stylesheet" href="https://kodilla.com/static/css/libs/fancybox/jquery.fancybox.min.css?00000" type="text/css" media="screen" />
    <link href="https://kodilla.com/static/css/libs/bootstrap-datetimepicker.min.css?00000">
    <link rel="stylesheet" href="https://uploads.kodilla.com/bootcamp/styles/content.css">
    <script>
    document.addEventListener("DOMContentLoaded", yall);
    window.environment = 'production';
    window.loggedIn = true;
    window.domain = 'https://kodilla.com';
            window.fbAppId = 1449248938627896;
    window.chatService = 'LiveAgent';
    window.useMessenger = window.chatService === 'Messenger';
    window.locale = 'pl';
    window.lang = 'pl';

    window.serverUTC       = 1625590539000;
    window.serverOffset    = 120;
    window.userDate        = new Date();
    window.userUTC         = userDate.getTime();
    window.userOffset      = userDate.getTimezoneOffset() * (-1);
    window.userClockDiff   = userUTC - serverUTC;
    window.diffRounded     = Math.round( userClockDiff / ( 1000 * 60 * 15 ) );
    window.isDifferentZone = ( userOffset - serverOffset !== 0 ) ? 1 : 0;
    window.hasWrongTime    = ( diffRounded !== 0 ) ? 1 : 0;
    window.dateTooltipText = 'Data i godzina są podane dla Twojej strefy czasowej GMT. <br>W razie wątpliwości napisz: <u>support@kodilla.com</u>.';
    window.wrongHourNotice = 'Godzina na Twoim urządzeniu r&oacute;żni się od godziny obowiązującej w strefie czasowej wybranej w ustawieniach Twojego urządzenia.';

    window.PAYU_HASH_ALGORITHM = 'SHA-256';
    window.PAYU_POS_ID = 1429452;
    window.PAYU_MD5_SECOND_KEY = 'f3627be5fab5a4238c8474936f057908';

    var moment = undefined,
        momentReady = function( method, method2, count ){
            var c = ( count ) ? count : 0;

            if      ( isDifferentZone && moment !== undefined ){
                if      ( method ) { method(); }
                else    { return false; }
            }
            else if ( isDifferentZone && moment === undefined ) {
                if ( c < 20 ) {
                    c++;
                    setTimeout( function() { momentReady( method, method2, c ); }
                        , 300 );
                } else {
                    if      ( method2 === true && method )  { method(); }
                    else if ( method2 !== true && method2 ) { method2(); }
                }
            }
            else {
                if      ( method2 === true && method )  { method(); }
                else if ( method2 !== true && method2 ) { method2(); }
                else    { return false; }
            }
        };

    if ( window.isDifferentZone && moment === undefined ) {
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = '/static/js/libs/moment.timezone.locales.min.js?v=2.22.2';
        document.getElementsByTagName("head")[0].appendChild(script);
    }
</script>
<script src="https://cdn.onesignal.com/sdks/OneSignalSDK.js" async=""></script>
<script>
    var OneSignal = window.OneSignal || [];
    OneSignal.push(function() {
        OneSignal.init({
            appId: "92552bb5-b477-4ea2-8260-dba65be198d9",
        });
    });
</script>
<script data-ad-client="ca-pub-9483216428129091" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:2404285,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
    <!-- Facebook Pixel Code -->
    <script>
        !function(f,b,e,v,n,t,s)
        {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
            n.callMethod.apply(n,arguments):n.queue.push(arguments)};
            if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
            n.queue=[];t=b.createElement(e);t.async=!0;
            t.src=v;s=b.getElementsByTagName(e)[0];
            s.parentNode.insertBefore(t,s)}(window, document,'script',
            'https://connect.facebook.net/en_US/fbevents.js');
        fbq('init', 389137334769464 );
        fbq('track', 'PageView');
    </script>
    <!-- End Facebook Pixel Code -->

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-KN2WWBH');</script>
    <!-- End Google Tag Manager -->
    
    </head>
<body class="no-js student ">
<!-- Facebook Pixel Code -->
<noscript><img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=389137334769464&ev=PageView&noscript=1"/></noscript>
<!-- End Facebook Pixel Code -->
<script>
    document.getElementsByTagName('body')[0].classList.remove('no-js');
    if ( window.isDifferentZone ) {
        document.querySelector('body').classList.add('time-conversion-applied');
    }
    if ( window.hasWrongTime ) {
        document.querySelector('body').classList.add('wrong-hour');
    }
</script>

    <nav class="navbar-main hidden-sm-down dark navbar">
    <div class="nav-container">
        <div class="navbar-header clearfix">
            <button class="navbar-toggler hidden-md-up pull-right" type="button" data-toggle="collapse" data-target="#collapsingNavbarUpper"><i class="fa fa-bars"></i></button>
        </div>
        <div class="collapse navbar-toggleable-sm container" id="collapsingNavbarUpper">
            <ul class="nav navbar-nav navbar-nav-left">
                                    <li class="nav-item nav-contact">
    <span>Skontaktuj się z nami:</span>
    <a href="mailto:support@kodilla.com">
        <i class="fa fa-envelope-o"></i>
        support@kodilla.com
    </a>
    <span>lub</span>
    <a href="javascript:openChat();">
        <i class="fa fa-comments"></i>
        porozmawiaj na czacie
    </a>
</li>
                                </ul>
            <ul class="nav navbar-nav pull-right">
                                <li class="nav-item">
                    <a href="https://kodilla.com/pl/informator" class="nav-link" target="_blank">
        Informator
    </a>
                </li>
                <li class="nav-item hidden-sm-down">
    <a href="https://kodilla.com/pl/account" class="nav-link">Konto</a>
</li>
        <li class="nav-item">
    <a class="analytics-track nav-link nav-link-accent" data-event="account_logout" href="https://kodilla.com/pl/sign-out">Wyloguj</a>
</li>
                            </ul>
        </div>
    </div>
</nav>
<nav class="navbar-main light navbar">
    <div class="container clearfix">
        <a class="navbar-brand"  href="https://kodilla.com/pl">
            <img src="https://kodilla.com/static/img/kodilla-nav-logo.svg?00000" alt="Kodilla - szkoła programowania">
        </a>
        <span class="contact-us-button-container"></span>
        <button class="navbar-toggler pull-right collapsed" type="button" data-toggle="collapse" data-target="#navbar-main">
            <i class="fa fa-bars navbar-ico-open"></i>
            <i class="fa fa-times navbar-ico-close"></i>
        </button>
        <ul id="navbar-main" class="nav navbar-nav pull-right collapse">
            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Szkolenia Bootcamp
    </a>
    <ul class="bootcamp-list">
                    <li class="list-sub list-sub-fe">
                <img src="https://kodilla.com/static/img/svg/menu_fer.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_fer_logo">
                <a href="https://kodilla.com/pl/bootcamp/front-end">
                    <h4 class="bootcamp-name">Front-end: React</h4>
                    <p>Naucz się tworzyć front-end aplikacji w 4 miesiące</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_wd.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_wd_logo">
                <a href="https://kodilla.com/pl/bootcamp/webdeveloper?type=wdp">
                    <h4 class="bootcamp-name">Web Developer</h4>
                    <p>Naucz&nbsp;się tworzyć aplikacje internetowe od&nbsp;podstaw</p>
                    <span class="bootcamp-label">FRONT-END i BACK-END</span>
                </a>
            </li>

            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_java.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_java_logo">
                <a href="https://kodilla.com/pl/bootcamp/java?type=jdp">
                    <h4 class="bootcamp-name">Java Developer</h4>
                    <p>Poznaj najpopularniejszy na&nbsp;świecie język programowania od&nbsp;zera</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_python.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_python_logo">
                <a href="https://kodilla.com/pl/bootcamp/python">
                    <h4 class="bootcamp-name">Python Developer</h4>
                    <p>Zdobądź kompetencje do tworzenia rozwiązań webowych</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_tester.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_tester_logo">
                <a href="https://kodilla.com/pl/bootcamp/tester-automatyzujacy">
                    <h4 class="bootcamp-name">Tester Automatyzujący</h4>
                    <p>Poznaj podstawy testowania automatycznego w Javie</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_game.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_mage_logo">
                <a href="https://kodilla.com/pl/bootcamp/game-dev">
                    <h4 class="bootcamp-name">Mobile Game Developer</h4>
                    <p>Zdobądź kompetencje do tworzenia gier</p>
                    <span class="bootcamp-label">nowość</span>
                </a>
            </li>
            </ul>
</li>

                        <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Szkolenia Pro
    </a>
    <ul>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/mikroserwisy" class="nav-link">Mikroserwisy w Javie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/spring-hibernate" class="nav-link">Spring i Hibernate</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/wielowatkowosc" class="nav-link">Wielowątkowość w Javie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/django" class="nav-link">Aplikacje webowe z Django</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/wizualizacja-danych" class="nav-link">Analiza danych w Pythonie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/machine-learning" class="nav-link">Podstawy Machine Learning</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/bigdata-pyspark" class="nav-link">Big Data z PySpark</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/automatyzacja-testow" class="nav-link">Automatyzacja test&oacute;w</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/vanilla-js" class="nav-link">Advanced Vanilla JS</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/typescript" class="nav-link">TypeScript - kurs praktyczny</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/vue3" class="nav-link">Vue3 - kompletny przewodnik</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/zaawansowany-backend" class="nav-link">Backend zaawansowany</a></li>
    </ul>
</li>
            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Strefa kursanta
    </a>
    <ul>
                    <li><a href="https://kodilla.com/pl/bootcamp-dashboard/407" class="nav-link">Bootcamp WD PLUS 2020-12</a></li>
                    <li><a class="nav-link" href="https://kodilla.com/pl/kursy">Samodzielne kursy</a></li>
                    <li><a class="nav-link" href="https://chat.kodilla.com" target="_blank">Komunikator</a></li>
                    <li><a class="nav-link" href="https://kodilla.com/pl/projects">Moje projekty</a></li>
    </ul>
</li>
                            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        O nas
    </a>
    <ul class="about-us">
        <li><a href="https://kodilla.com/pl/mentorzy" class="nav-link">Mentorzy</a></li>
        <li><a href="https://kodilla.com/pl/zespol" class="nav-link">Zesp&oacute;ł Kodilli</a></li>
        <li><a href="https://kodilla.com/pl/o-nas" class="nav-link">O firmie</a></li>
    </ul>
</li>
                                                                    <li class="nav-item hidden-md-up nav-group">
    <span class="mobile-menu-separator">Szkolenia Bootcamp</span>
    <ul>
                    <li class="nav-item list-sub-fe">
                <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/front-end">Bootcamp Front-end: React
                </a>
            </li>
                <li class="nav-item">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/webdeveloper">Bootcamp Web Developer
                <span class="bootcamp-label">FRONT-END i BACK-END</span>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="https://kodilla.com/pl/bootcamp/java">Bootcamp Java</a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/tester-automatyzuj%C4%85cy">Bootcamp Tester Automatyzujący
            </a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/python">Python Developer
            </a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/game-dev">Mobile Game Developer
                <span class="bootcamp-label">nowość</span>
            </a>
        </li>
    </ul>
</li>
<li class="nav-item hidden-md-up nav-group">
    <a class="nav-link-bold" href="https://kodilla.com/pl/szkolenia-pro">Szkolenia Pro</a>
</li>
            <li class="nav-item hidden-md-up nav-group">
            <span class="mobile-menu-separator">Strefa kursanta</span>
            <ul>
                <li class="nav-item ">
                                            <a class="nav-link" href="https://kodilla.com/pl/bootcamp-dashboard/407">
                            Bootcamp   WD PLUS 2020-12
                        </a>
                                    </li>
                <li class="nav-item ">
                    <a class="nav-link" href="https://kodilla.com/pl/kursy">Samodzielne kursy</a>
                </li>
                                    <li class="nav-item ">
                        <a class="nav-link" href="https://chat.kodilla.com" target="_blank">Komunikator</a>
                    </li>
                                <li class="nav-item">
                    <a class="nav-link" href="https://kodilla.com/pl/projects">Moje projekty</a>
                </li>
            </ul>
        </li>
    
        
            <li class="nav-item hidden-md-up nav-group">
            <span class="mobile-menu-separator">O nas</span>
            <ul>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/mentorzy" class="nav-link">Mentorzy</a>
                </li>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/zespol" class="nav-link">Zesp&oacute;ł Kodilli</a>
                </li>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/o-nas" class="nav-link">O firmie</a>
                </li>
            </ul>
        </li>
    
<li class="nav-item hidden-md-up nav-group">
    <span class="mobile-menu-separator">Pozostałe</span>
    <ul>
                                        
        <li class="nav-item">
            <a href="https://kodilla.com/pl/informator" class="nav-link" target="_blank">
        Informator
    </a>
        </li>
    </ul>

</li>

    <li class="nav-item hidden-md-up">
        <a class="nav-link" href="https://kodilla.com/pl/account">Konto</a>
    </li>
    <li class="nav-item hidden-md-up">
        <a class="nav-link analytics-track" data-event="account_logout" href="https://kodilla.com/pl/sign-out">Wyloguj</a>
    </li>

        
    <li class="nav-item hidden-md-up nav-group">
        <span class="mobile-menu-separator">Skontaktuj się z nami</span>
        <ul>
            <li class="nav-item">
                <a href="mailto:support@kodilla.com" class="nav-link">
                    <i class="fa fa-envelope-o"></i>
                    support@kodilla.com
                </a>
            </li>
            <li class="nav-item">
                <a href="javascript:openChat();" class="nav-link">
                    <i class="fa fa-comments"></i>
                    <span>Porozmawiaj na czacie</span>
                </a>
            </li>
        </ul>
    </li>
        </ul>
    </div>
</nav>
<main class="bootcamp module page-height-fix" id="bootcamp-module">
    <div class="aside-toggle hidden-md-up">
        <button class="navbar-toggler pull-left collapsed" type="button" data-toggle="collapse" data-target="#aside-sticky" aria-expanded="false">
            <i class="fa fa-bars navbar-ico-open"></i>
            <i class="fa fa-times navbar-ico-close"></i>
        </button>
    </div>
    <div class="table-of-contents aside-sticky collapsed collapse" id="aside-sticky">
        <section class="container">
            <div class="row">
                <aside class="module-nav col-md-4 col-md-offset-8">
                    <section class="card">
                        <div class="card-header">
                            <h4 class="card-title">Spis treści modułu</h4>
                        </div>
                        <ul class="list-group list-group-flush">
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1963" class="clearfix">
                                    <p>8.1. Referencje, magiczne słowo this i podstawy OOP</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1964" class="clearfix">
                                    <p>8.2. OOP, czyli programowanie obiektowe</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1965" class="clearfix">
                                    <p>8.3. Otwieramy pizzerię!</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1966" class="clearfix">
                                    <p>8.4. Tworzymy pierwszą klasę</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1967" class="clearfix">
                                    <p>8.5. Uruchamiamy akordeon</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1968" class="clearfix">
                                    <p>8.6. Obliczamy cenę produktu</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1969" class="clearfix">
                                    <p>8.7. Dodajemy obsługę obrazk&oacute;w</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1970" class="clearfix">
                                    <p>8.8. Podsumowanie</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1971" class="clearfix">
                                    <p>8.9. Quiz powt&oacute;rkowy</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                    </ul>
                        <div class="card-block text-center">
                                                                                                <a href="https://kodilla.com/pl/bootcamp-dashboard/407">Powr&oacute;t do dashboardu</a>
                                                                                    </div>
                    </section>
                </aside>
            </div>
        </section>
    </div>
    <section class="container module-content">
        <div class="row">
            <main class="col-md-8">
                <section class="card">
                    <div class="card-block module-header clearfix  completed ">
                        <h1 class="card-title">8. Programowanie obiektowe w JS-ie</h1>
                                                <i class="fa fa-bookmark fa-3x" aria-hidden="true"></i>
                    </div>
                                        <div class="card-block challenge">
                        <h3>Wyzwania:</h3>
                        <ul>
<li>dowiesz się czym jest referencja,</li>
<li>poznasz zasady stojące za ustaleniem wartości <code>this</code> w funkcji,</li>
<li>zapoznasz się z programowaniem obiektowym,</li>
<li>poznasz zagadnienia klas i instancji,</li>
<li>stworzysz kilka funkcjonalności większego projektu.</li>
</ul>
<iframe src="https://docs.google.com/forms/d/e/1FAIpQLScq4C8y9wDeOQDNpWvqCIcRjqZDraXDo5NY__A8jC-T0uJeiw/viewform?embedded=true" width="640" height="730" frameborder="0" marginheight="0" marginwidth="0">Loading…</iframe>
<p><strong>Dziękujemy!</strong></p>
<h3>Wstęp</h3>
<p>Do tej pory udało nam się poznać JS na tyle, aby stworzyć naszą pierwszą aplikację. Możesz jednak mieć wrażenie, że kod naszego bloga był pisany trochę chaotycznie i łatwo w nim się zgubić. Dlatego w tym module skupimy się na <strong>programowaniu obiektowym</strong> (<em>object-oriented programming</em>/<em>OOP</em>), które pozwoli nam na jego znaczne uporządkowanie.</p>
<p>W tej chwili wszystkie funkcje były przechowywane w naszym kodzie niejako "luzem". Funkcja po funkcji, niezależnie od ich roli. Programowanie obiektowe zmieni tę postać rzeczy. Pozwoli nam bowiem na grupowanie funkcjonalności tyczących się konkretnego zadania w pojedyncze obiekty. Tak, że np. wszystkie funkcje odpowiedzialne za działania na tagach znajdziemy w jednym obiekcie, a na autorach w drugim. Dzięki temu w razie potrzeby nie będzie trzeba mozolnie przeszukiwać całego pliku w poszukiwaniu jednej funkcjonalności. Zamiast tego od razu przejdziemy do konkretnego obiektu, co znacznie przyśpieszy jej znalezienie. Zapewne domyślasz się, że może to mieć ogromne znaczenie. Zwłaszcza w większych aplikacjach.</p>
<p>Zanim jednak faktycznie zajmiemy się programowaniem obiektowym, musimy jeszcze na chwilę się zatrzymać. W poprzednich modułach korzystaliśmy z trzech mechanizmów JS-a, których tak naprawdę wprost nie omówiliśmy. Wiesz np. czym są obiekty, ale czy mówi Ci coś słowo "referencja"? Rozumiesz też, że jako parametr metody <code>addEventListener</code> wpisujemy zmienną kierującą do funkcji, ale jak jest jest ona później uruchamiana? Tego już nie wiemy. Korzystaliśmy również ze słowa kluczowego <code>this</code>, ale czy zdajesz sobie sprawę od czego zależy jego wartość? No właśnie. Dlatego też, zanim przejdziemy dalej, zajmiemy się właśnie tymi tematami. Tak, aby to co dotychczas robiliśmy, nie było już dla Ciebie żadną tajemnicą.</p>

                    </div>
                                    </section>
                                    
                <section id="submodule-1963" class="card submodule completed" data-bootcamp-user-submodule-id="604286" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.1. <span>Referencje, magiczne słowo this i podstawy OOP</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <h3>Typy, wartości i referencje</h3>
<p>Zgodnie z planem, zaczniemy od poznania idei referencji. Czym one w ogóle są? Do czego służą? Najłatwiej zrozumiesz to na praktycznym przykładzie. Wyobraź sobie następującą sytuację:</p>
<pre><code class="language-js">let personOne = 'John';
let personTwo = personOne;
personTwo = personOne + ' II';
console.log('Person one', personOne);
console.log('Person two', personTwo);
</code></pre>
<p>Jak myślisz, jaka będzie końcowa wartość zmiennych <code>personOne</code> i <code>personTwo</code>?</p>
<p>Zapewne łatwo odpowiesz na to pytanie. W pierwszej linijce deklarujesz zmienną <code>personOne</code> o wartości <code>John</code>. Następnie tworzysz zmienną <code>personTwo</code>, która ma być kopią <code>personOne</code>. Na końcu modyfikujesz tę kopię (a więc <code>personTwo</code>), dodając jej tekst <code>II</code>. Tym samym na końcu te zmienne powinny mieć następujące wartości: <code>John</code> oraz <code>John II</code>.</p>
<p>Sprawdźmy:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-1.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-1.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Przypuszczamy, że nie pojawiły się tutaj u Ciebie żadne wątpliwości. W takim razie czas na kolejny przykład:</p>
<pre><code class="language-js">const personOne = { firstName:  'John', lastName: 'Doe' };
const personTwo = personOne;
personTwo.firstName = 'Amanda';
console.log('Person one', personOne);
console.log('Person two', personTwo);
</code></pre>
<p>Jak myślisz, co konsola pokaże tym razem po wykonaniu wszystkich instrukcji?</p>
<p>Wydaje się, że całość jest bardzo podobna do pierwszego przykładu. Tworzymy obiekt, następnie kopiujemy go do nowej stałej. Potem modyfikujemy kopie i pokazujemy zawartość obu obiektów. Wydaje się więc, że pierwszy powinien pozostać niezmieniony, ale drugi wyglądać tak: <code>{ firstName: 'Amanda', lastName: 'Doe' }</code>. Jak myślisz, czy tak właśnie będzie?</p>
<p>Jeśli uważasz, że nie, to masz rację.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-2.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-2.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Jak widzisz, zamiast dwóch różnych obiektów, otrzymaliśmy dwa takie same. Oba mają atrybut <code>firstName</code> o wartości <code>Amanda</code>. Jak do tego doszło? Odpowiedź będzie dość krótka.</p>
<p>Jak udało nam się już wcześniej udowodnić, <strong>w przypadku prostych typów danych (tzw. prymitywów) JS, przy próbie przypisania, kopiuje wartość.</strong> Dzieje się tak więc ze stringami (jak na przykładzie pierwszym), ale tak samo JS zachowałby się w przypadku liczb, wartości boolean oraz innych typów prostych.</p>
<p>Poniżej przykład z innym “prymitywem”, czyli typem number.</p>
<pre><code class="language-js">let personAgeOne = 10;
let personAgeTwo = personAgeOne;
personAgeTwo += 2;
console.log('Person one', personAgeOne); //10
console.log('Person two', personAgeTwo); //12
</code></pre>
<p>Złożone typy danych będą już jednak zachowywały się inaczej. <strong>W przypadku typów złożonych (np. obiekty, tablice, funkcje) JS stosuje mechanizm referencji</strong>. Na czym on polega? Wartości złożonych typów danych z reguły są dość duże. Oczywiście w jednym przypadku mogą być ogromne, a w innym znacznie mniejsze, ale co do zasady – są znacznie bardziej “pamięciożerne” niż wartości typów prostych. Dlatego też JS, zamiast bezmyślnie je kopiować, w przypadku przypisania do nowej zmiennej czy stałej, przekazuje im tylko “adres” do oryginalnego obiektu. Zatem nie tworzymy kopii, lecz ta nowa zmienna/stała staje się tylko czymś w rodzaju “linku” (referencją) kierującego do oryginału.</p>
<p>Dlaczego JS tak postępuje? Ze względu na wydajność. Po co trzymać w pamięci dwa lub więcej takich samych obiektów? Przecież tylko niepotrzebnie zajmowałyby tam miejsce.</p>
<p>Mając taką wiedzę, wróćmy na chwilę do naszego przykładu numer dwa:</p>
<pre><code class="language-js">const personOne = { firstName:  'John', lastName: 'Doe' };
const personTwo = personOne;
personTwo.firstName = 'Amanda';
console.log('Person one', personOne);
console.log('Person two', personTwo);
</code></pre>
<p>Teraz już wiemy co tu się naprawdę dzieje.</p>
<pre><code class="language-js">const personOne = { firstName:  'John', lastName: 'Doe' };
</code></pre>
<p>Najpierw JS tworzy nową stałą o nazwie <code>personOne</code> i <strong>przypisuje do niej adres (referencję) do nowo utworzonego obiektu w pamięci</strong> – <code>{ firstName: 'John', lastName: 'Doe' }</code>. Dlaczego adres, a nie kopię zawartości? To już wiemy, bo w przypadku typów złożonych (a obiekt takim jest) JS domyślnie przypisuje zamiast kopii tylko adres (referencję). <strong><code>personOne</code> tym samym od początku jest tylko i wyłącznie odnośnikiem do miejsca w pamięci, gdzie jest przechowywany nasz nowy obiekt.</strong></p>
<p>Następnie tworzona jest nowa stała <code>personTwo</code>, która jako wartość <strong>również otrzymuje adres (referencję) do <code>personOne</code></strong>. Tak naprawdę można powiedzieć, że <code>personTwo</code> od samego początku nie jest “własnym bytem”. Zamiast tego od razu również <strong>staje się tylko odnośnikiem (referencją) do tego samego obiektu co <code>personOne</code></strong>.</p>
<p>W kolejnym kroku staramy się zmienić wartość właściwości <code>firstName</code> obiektu <code>personTwo</code>. Tylko że czym w tej chwili jest tak naprawdę ta stała? Adresem do tego samego obiektu co <code>personOne</code>. Dlatego też, próbując dostać się do <code>personTwo.firstName</code>, tak naprawdę dostajemy się do tego samego miejsca, do którego pokierowałoby nas również <code>personOne.firstName</code>. Czyli modyfikując <code>personTwo.firstName</code>, zmieniamy tak naprawdę tylko jeden pierwotny obiekt, do którego kierują zarówno <code>personOne</code>, jak i <code>personTwo</code>.</p>
<pre><code class="language-js">console.log('Person one', personOne);
</code></pre>
<p>Pod koniec pokazujemy w konsoli wartość obu stałych. <code>console.log('Person one', personOne)</code> skieruje nas za pomocą referencji bezpośrednio do pierwotnego obiektu, a więc konsola pokaże nam obiekt <code>{ firstName: 'Amanda', lastName: 'Doe' }</code>.</p>
<pre><code class="language-js">console.log('Person two', personTwo);
</code></pre>
<p>Ta linijka kodu powinna nam pokazać wartość <code>personTwo</code>. Jednak czym jest <code>personTwo</code>? Odnośnikiem do tego samego obiektu w pamięci co <code>personOne</code>, a więc w konsoli zobaczymy dokładnie to samo, co wyżej – wartość zmodyfikowanego obiektu pierwotnego.</p>
<p>Podsumowując, tak naprawdę od samego początku <strong><code>personOne</code> i <code>personTwo</code> kierowały nas do tego samego obiektu w pamięci.</strong> Nie ważne więc czy próbowaliśmy modyfikować <code>personOne</code> czy <code>personTwo</code>, modyfikowaliśmy jeden i ten sam obiekt.</p>
<p>Możemy podsumować dotychczasową wiedzę następująco: <strong>przy próbie przypisania do zmiennej/stałej wartości typu prostego, JS przypisze jej kopię, a w przypadku typu złożonego – jej referencję.</strong></p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-3.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-3.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Dla utrwalenia zróbmy jeszcze jeden mały przykład:</p>
<pre><code class="language-js">const namesOne = ['John', 'Amanda'];
const namesTwo = namesOne;
namesTwo.push('Thomas');

console.log(namesOne);
console.log(namesTwo);
</code></pre>
<p>Jaki będzie wynik działania powyższej funkcji? Co pojawi się w konsoli? Zastanów się na spokojnie.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-zUemmFQq3-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-zUemmFQq3-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-zUemmFQq3-toggle" class="collapse">
<p>W konsoli wyświetli się dwa razy ta sama zmodyfikowana tablica <code>['John', 'Amanda, 'Thomas']</code>.</p>
<pre><code class="language-js">const namesOne = ['John', 'Amanda'];
</code></pre>
<p>W pierwszej linijce JS tworzy nowy obiekt w pamięci (tablicę <code>['John', 'Amanda']</code>) i przypisuje jego referencję do nowej stałej <code>namesOne</code>. Dlaczego przypisuje ten obiekt w formie referencji, a nie kopii? Bo obiekt to typ złożony, a przy tych JS, jak pisaliśmy już wcześniej, korzysta właśnie z mechanizmu referencji.</p>
<pre><code class="language-js">const namesTwo = namesOne;
</code></pre>
<p>Następnie tworzymy stałą <code>namesTwo</code> i staramy się przypisać jej wartość <code>namesOne</code>. Stała <code>namesOne</code> jest jednak tylko referencją do obiektu pierwotnego, dlatego <code>namesTwo</code> również staje się referencją (adresem) do tej samej tablicy.</p>
<p>Zauważ więc, że od tej chwili mamy dwie stałe, ale obie kierują tak naprawdę do tego samego obiektu w pamięci, naszej tablicy z imionami.</p>
<pre><code class="language-js">namesTwo.push('Thomas');
</code></pre>
<p>W kolejnym kroku staramy się dodać do <code>namesTwo</code> nowy element. <code>namesTwo</code> jest tylko referencją do naszej tablicy imion w pamięci (podobnie, jak <code>namesOne</code>), więc <code>push</code> jest wykonywane właśnie na niej. Nasza tablica zapisana w pamięci otrzymuje na tym etapie nowy element <code>Thomas</code>.</p>
<pre><code class="language-js">console.log(namesOne);
console.log(namesTwo);
</code></pre>
<p>Na końcu pokazujemy wartość obu stałych. Obie kierują pod ten sam obiekt w pamięci, więc pokażą dokładnie to samo – tablicę z trzema elementami.</p>
</div>
<p>Jeśli na tym etapie wszystko jest dla Ciebie jasne, to możemy iść dalej. Jeśli jednak nie czujesz się zbyt pewnie, to postaraj się przerobić oba przykłady jeszcze raz. Na spokojnie.</p>
<h3>Referencje, kopie i funkcje</h3>
<p>Jak wygląda sytuacja z funkcjami? Czy przekazując jakieś dane w formie parametru, też przekazujemy – zależnie od typu – kopię albo referencję? Jak najbardziej!</p>
<p>Pamiętaj, że ustawienie wartości parametru, koniec końców, nie różni się zbytnio od procesu zwykłej deklaracji zmiennej. Pozwala ono po prostu na przypisanie do zakresu funkcji jakiejś zmiennej o nazwie równej nazwie parametru i wartości równej przekazanemu argumentowi. Zatem skoro tutaj też dochodzi do przypisywania wartości, to musimy trzymać się tych samych zasad co wcześniej.</p>
<pre><code class="language-js">const label = 'Names of people';
const names = ['John', 'Amanda'];

function prepareAndShowNames(namesArr, title) {
  title = '==' + title + '==';
  namesArr.push('Thomas');
  console.log(title, namesArr);
}

prepareAndShowNames(names, label);
</code></pre>
<p>Nie ma tu niczego specjalnie skomplikowanego, ale żeby nie było żadnych wątpliwości, powiedzmy najpierw, co dokładnie ma tu robić funkcja <code>prepareAndShowNames</code>. Powinna ona otrzymywać tablicę imion, a także tytuł. Zadaniem tej funkcji jest dodanie do tablicy nowego imienia (<code>Thomas</code>), a następnie pokazanie jej zawartości zaraz po tytule.</p>
<p>Postaraj się uruchomić ten kod, np. na CodePenie. Jeśli to zrobisz, to od razu rzucą Ci się w oczy dwie rzeczy.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-4.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-4.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Po pierwsze okazuje się, że JavaScript nie ma problemu z tym, że staramy się przypisywać coś do parametru. JS spokojnie poradził sobie z linijką <code>title = '==' + title + '=='</code>. Potwierdza się tylko to, o czym pisaliśmy wcześniej. Ustalenie parametru funkcji kończy się, tak czy inaczej, zadeklarowaniem zmiennej (w tej sytuacji o nazwie <code>title</code>), dlatego też nie otrzymujemy w konsoli żadnego komunikatu, jakoby <code>title</code> była niezadeklarowana. Nie widzimy tego wprost, ale "pod maską" JS naprawdę deklaruje parametr jako zwykłą zmienną i tak ją potem traktuje. Dlatego też bez problemu przypisuje do niej nową wartość, bo w istocie była zadeklarowana – właśnie na etapie inicjacji wykonania funkcji.</p>
<p>Po drugie, okazuje się, że po wykonaniu funkcji zmodyfikowana została nie tylko tablica <code>namesArr</code>, wewnątrz której pracowaliśmy, ale również przekazywany w formie parametru oryginał – tablica dostępna pod stałą <code>names</code>. Za to <code>label</code> pozostał bez zmian. Dlaczego?</p>
<p>Jeśli wiemy już, że w przypadku przekazywania danych do funkcji stosujemy te same zasady co przy najprostszym przypisywaniu, to możemy łatwo rozszyfrować, co tu się właściwie stało.</p>
<pre><code class="language-js">const label = 'Names of people';
</code></pre>
<p>Zacznijmy od pierwszej linijki. Tworzymy nową stałą i przypisujemy do niej kopię wartości tekstowej stringa. Dlaczego kopię, a nie referencję? To już wiemy. W przypadku przypisywania wartości typów prostych JS kopiuje wartość.</p>
<p>Zatem możemy powiedzieć, że stała <code>label</code> faktycznie ma wartość tekstową <code>Names of people</code>.</p>
<pre><code class="language-js">const names = ['John', 'Amanda'];
</code></pre>
<p>Następnie staramy się stworzyć drugą stałą, tym razem o nazwie <code>names</code>. Tutaj mamy już jednak próbę przypisania obiektu, więc JS skorzysta z mechanizmu referencji. Co tu się właściwie stanie?</p>
<p>JS utworzy w pamięci nowy obiekt – tablicę <code>['John', 'Amanda']</code>, a adres (referencja) do niej zostanie przypisany do nowoutworzonej stałej <code>names</code>. Krótko mówiąc, od tego momentu <code>names</code> jest tylko i wyłącznie odnośnikiem do właśnie utworzonego obiektu w pamięci – naszej tablicy <code>['John', 'Amanda']</code>.</p>
<pre><code class="language-js">prepareAndShowNames(names, label);
</code></pre>
<p>Zapewne zdajesz sobie sprawę, że JS po zauważeniu deklaracji funkcji od razu jej nie wykona. Możemy więc założyć, że zapisze ją w pamięci, ale nie uruchomi, tylko pójdzie dalej. I dopiero teraz, już w tej konkretnej powyższej linijce, w końcu tę funkcję włączy.</p>
<p>Od czego zacznie JS przy jej wykonywaniu? Od zadeklarowania zmiennych z parametrów. Do <code>namesArr</code> postara się przypisać wartość stałej <code>names</code>, a do <code>title</code> wartość stałej <code>label</code>. Zauważ, że faktycznie dochodzi tu do próby przypisania.</p>
<p>Teraz, znając już zasady, możemy łatwo ustalić, jakie wartości przyjmą nasze parametry. Skoro <code>names</code> odnosi się swoją referencją do obiektu złożonego (tablicy), to do <code>namesArr</code> przypiszemy również po prostu referencję do miejsca w pamięci, gdzie ten obiekt się znajduje. W przypadku <code>title</code> mamy typ prosty, możemy więc założyć, że w tej sytuacji JS po prostu skopiuje do <code>title</code> wartość stałej <code>label</code>.</p>
<p>Zatem na tym etapie wiemy już, że przy wywołaniu <code>prepareAndShowNames</code> w funkcji tej pojawiają się dwie zmienne: <code>namesArr</code>, która jest referencją do tego samego obiektu w pamięci co <code>names</code>, czyli również kieruje nas do tablicy <code>['John', 'Amanda']</code>, oraz <code>title</code>, której wartość będzie równa tekstowi <code>Names of people</code>.</p>
<pre><code class="language-js">title = '==' + title + '==';
</code></pre>
<p>W następnej linijce staramy się tylko lekko udekorować otrzymany tytuł, np. <code>Names</code> zostanie zamienione na <code>==Names of people==</code>.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Stała czy zmienna?</h4>
<p>Na tym etapie może pojawić się w Twojej głowie jedno pytanie. Mówimy, że ustalając parametry w funkcji, tak naprawdę deklarujemy dodatkowe zmienne w jej zakresie. Tylko czy na pewno zmienne, a może stałe? Skąd mamy to wiedzieć? Najlepiej spojrzeć na nasz mały eksperyment.</p>
<p>Zauważ, że linijka kodu <code>title = '==' + title + '==';</code> nie spowodowała błędu. To dowodzi, że <code>title</code> (czyli drugi parametr) jest deklarowany jako zmienna. Gdyby był stałą, to nie można by było zmodyfikować jego wartości, a konsola pokazałaby błąd.</p>
</div>
<p>W takim razie idźmy dalej.</p>
<pre><code class="language-js">namesArr.push('Thomas');
</code></pre>
<p>W kolejnym kroku JS postara się dodać do <code>namesArr</code> nowy element. Co istotne <code>namesArr</code>, jak już wiemy, jest tylko referencją do naszej tablicy z imionami, którą przechowujemy w pamięci. Tym samym, próbując dodać coś do <code>namesArr</code>, za każdym razem odnosimy się do tej samej tablicy w pamięci, do której prowadzi również stała <code>names</code>. Jednej i tej samej tablicy.</p>
<pre><code class="language-js">console.log(title, namesArr)
</code></pre>
<p>Kolejną linijkę na pewno jesteś w stanie łatwo rozszyfrować. Staramy się pokazać wartość <code>title</code> i <code>namesArr</code>. <code>title</code> to zwykły tekst <code>==Names of people==</code> i on zostanie pokazany jako pierwszy. <code>namesArr</code> kieruje za to pod adres w pamięci, gdzie jest nasza zmodyfikowana przed chwilą tablica z imionami. Zatem jako druga, zostanie pokazana właśnie ona.</p>
<pre><code class="language-js">console.log(label, names);
</code></pre>
<p>Po wykonaniu funkcji pozostaje nam jeszcze jedna instrukcja. Jako <code>label</code> konsola pokaże wartość tekstową stałej <code>label</code>, czyli wciąż <code>Names</code>. Jak wiemy, do funkcji była przekazywana tylko kopia <code>label</code>, więc żadne modyfikacje poczynione w funkcji na kopii nie wpłynęły na oryginał. Za to już jako <code>names</code> JS pokaże nam dokładnie to samo, co przed chwilą widzieliśmy jako <code>namesArr</code>. Dlaczego? Bo i <code>names</code> i <code>namesArr</code> prowadzą tak naprawdę do tego samego jednego elementu.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Kopiowanie złożonych danych</h4>
<p>Coraz lepiej orientujesz się w temacie. Powstaje jednak jedno pytanie. Czy JS zawsze zamiast kopiować złożone dane, przekazuje tylko referencje do nich? Czy da się go jakoś zmusić, żeby zachował się inaczej? W końcu w naszym przykładzie wyżej na pewno wolelibyśmy otrzymać kopię danych, do których prowadzi <code>names</code>. Dzięki temu <code>namesArr</code> mogłoby być w naszej funkcji dowolnie modyfikowane, bez obaw, że "zepsujemy" coś w oryginale.</p>
<p>Odpowiedź jest prosta – da się. Nie będziemy jednak póki co zaprzątać sobie tym głowy. Na razie wystarczy, że wiesz, iż taka opcja istnieje. A jaka dokładnie? Opowiemy o tym trochę później, kiedy faktycznie będziemy musieli skorzystać z tej wiedzy w praktyce.</p>
</div>
<h3>Ćwiczenia</h3>
<p>Czas podsumować nową dawkę wiedzy krótkim quizem.</p>
<h4>Pytanie 1</h4>
<p>Przy próbie przypisywania wartości, JS – zależnie do typu – kopiuje wartość lub przekazuje referencję (adres). Od czego to zależy?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse--ZTzp2U2eh-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse--ZTzp2U2eh-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse--ZTzp2U2eh-toggle" class="collapse">
<p>Od typu. Wartości typów złożonych (czyli np. tablice, obiekty, funkcje) są przekazywane przez referencję, a prostych (liczby, tekst itd.) jako kopia.</p>
</div>
<h4>Pytanie 2</h4>
<p>W jaki sposób są przekazywane dane do funkcji? W formie kopii czy referencji?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-34ZHlOLH10-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-34ZHlOLH10-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-34ZHlOLH10-toggle" class="collapse">
<p>To zależy od typu danych, które przekazujemy. Wartości typów złożonych (czyli np. tablice, obiekty, funkcje) są przekazywane przez referencję, a prostych (liczby, tekst itd.) jako kopia.</p>
</div>
<h4>Pytanie 3</h4>
<pre><code class="language-js">const namesOne = ['John', 'Amanda'];

let namesTwo = namesOne;
namesTwo.push('Thomas');
namesTwo = [];

console.log(namesOne);
console.log(namesTwo);
</code></pre>
<p>Jakie będą końcowe wartości <code>namesOne</code> i <code>namesTwo</code>?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-1vIxdWIX5L-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-1vIxdWIX5L-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-1vIxdWIX5L-toggle" class="collapse">
<p>To trochę podchwytliwe pytanie.</p>
<p><code>namesOne</code> będzie referencją do tablicy o wartości <code>['John', 'Amanda', 'Thomas']</code>.</p>
<p><code>namesTwo</code> będzie referencją do pustej tablicy.</p>
<p>Zauważ, że w instrukcji <code>namesTwo = []</code> mówimy JS-owi: utwórz nową tablicę i przypisz referencję do niej jako wartość <code>namesTwo</code>. A to oznacza, że od tej chwili <code>namesTwo</code> przestaje być odnośnikiem do pierwszej tablicy, a staje się odnośnikiem do drugiej – tej nowej i pustej. <code>namesOne</code> i <code>namesTwo</code> prowadzą więc od tego momentu do innych tablic.</p>
</div>
<h4>Pytanie 4</h4>
<pre><code class="language-js">const person = { firstName: '', lastName: '' };
const name = person.firstName;

const personOne = person;
personOne.firstName = 'John';
personOne.lastName = 'Doe';

const personTwo = person;
personTwo.firstName = 'Amanda';
personTwo.lastName = 'Doe';

console.log(name, personOne, personTwo);
</code></pre>
<p>Co pokaże się w konsoli?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-AYY2aJH5dS-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-AYY2aJH5dS-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-AYY2aJH5dS-toggle" class="collapse">
<pre><code class="language-js">  '',
  { firstName: 'Amanda', lastName: 'Doe' },
  { firstName: 'Amanda', lastName: 'Doe' }
</code></pre>
<p>W przypadku <code>personOne</code> i <code>personTwo</code> zapewne nie masz wątpliwości. <code>person</code>, <code>personOne</code> i <code>personTwo</code> są referencją do dokładnie tego samego obiektu w pamięci. Nie ważne więc, gdzie robisz zmiany, modyfikujesz ten sam jeden obiekt.</p>
<pre><code class="language-markup">const name = person.firstName;
</code></pre>
<p>Ta linijka mogła Cię zmylić, ale pamiętaj, że <code>person.firstName</code> to zwykły string (typ prosty), a jako taki został przypisany do <code>name</code> jako kopia. Tym samym, żadne dalsze zmiany w obiekcie, do którego kierował <code>person</code> nas nie interesują. Jego wartość pozostanie do końca taka sama (pusty string).</p>
</div>
<h4>Pytanie 5</h4>
<p>Czy istnieje opcja skopiowania obiektu?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-5ygJHuRAoa-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-5ygJHuRAoa-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-5ygJHuRAoa-toggle" class="collapse">
<p>Tak.</p>
</div>
<h3>Funkcje callback</h3>
<p>Dość szczególnym wykorzystaniem mechanizmu referencji są funkcje callback. Korzystaliśmy już z nich w poprzednim module. Chociażby wtedy, kiedy przekazywaliśmy referencję do naszych funkcji, jako parametr metody <code>addEventListener</code>.</p>
<p>Np.</p>
<pre><code class="language-js">link.addEventListener('click', tagClickHandler);
</code></pre>
<p>Idea jest tutaj dość prosta. Przekazujemy jako jeden z argumentów funkcji inną funkcję i ta jest wywoływana wtedy, kiedy pierwsza z nich uzna, że jest taka potrzeba, np. kiedy funkcja pierwsza skończy jakiś proces.</p>
<p>Spójrz tylko na przykład:</p>
<pre><code class="language-js">function hello(name) {
  console.log('Hey', name);
}

function runOtherFunc(callback) {
  const val = prompt('Pass the value!');
  callback(val);
}

runOtherFunc(hello);
</code></pre>
<p>Jak zadziała powyższy kod?</p>
<p>Na samym początku zostaną zadeklarowane dwie funkcje – <code>hello</code> i <code>runOtherFunc</code>. Oczywiście wiesz już, że na tym etapie nie zostaną one automatycznie uruchomione, a zaledwie zapisane w pamięci.</p>
<pre><code class="language-js">runOtherFunc(hello);
</code></pre>
<p>Dopiero ostatnia linijka faktycznie uruchamia jedną z nich, funkcję <code>runOtherFunc</code>. Spójrz dokładnie na to, co jest przekazywane jako parametr <code>callback</code> tej funkcji.</p>
<p>Jako parametr przekazujemy kolejną funkcję! A dokładnie referencję do funkcji dostępnej pod <code>hello</code>. Oznacza to, że po wywołaniu, funkcja <code>runOtherFunc</code> od razu zadeklaruje w swoim scope (zakresie) zmienną <code>callback</code> o wartości… no właśnie o wartości czego? Jak już wiesz, w tym momencie dochodzi do próby przypisania wartości do zmiennej. Wiemy też, że JS zależnie od sytuacji przekazuje kopię albo referencję – zależy to od typu danych, tego, czy jest on złożony, czy prosty. Jaki jest on w tej sytuacji? Funkcja to ewidentnie typ złożony, tym samym <strong>do funkcji <code>runOtherFunc</code> nie trafi kopia funkcji <code>hello</code>, lecz tylko referencja (adres) do niej</strong>. Możemy skrócić to do następującego stwierdzenia: <strong><code>callback</code> i <code>hello</code> kierują tak naprawdę do tej samej funkcji — tego samego miejsca w pamięci</strong>. To bardzo istotne, bo dzięki temu wiemy, że wywołując potem w kodzie <code>callback</code>, tak naprawdę uruchamiamy po prostu tę samą funkcję, którą uruchomiłoby wywołanie <code>hello</code>.</p>
<p>Po ustaleniu zawartości <code>callback</code>, funkcja przechodzi do zapytania o wartość, którą ma przypisać do stałej <code>val</code>. Naturalnie może to być dowolny string. Funkcja w żaden sposób nie waliduje tego, co dostanie. Zamiast tego przechodzi po prostu dalej.</p>
<p>I tu dochodzimy do najciekawszego fragmentu tego kodu. Uruchamiamy <code>callback</code> z parametrem, przy czym jego wartość ma być równa temu, co wpisano właśnie przed chwilą do <code>val</code>.</p>
<p>Wiemy już do czego prowadzi <code>callback</code> – do funkcji, która jest też przypisana pod <code>hello</code>. Wywołując <code>callback</code>, uruchamiamy więc tak naprawdę tę funkcję:</p>
<pre><code class="language-js">function (name) {
  console.log('Hey', name);
}
</code></pre>
<p>Wiemy też, że wywołując ją, jako pierwszy parametr (<code>name</code>) przekazujemy do niej wartość <code>val</code> (<code>callback(val)</code>). Tym samym, wpisując w pole wygenerowane przez prompta np. wartość <code>John</code>, możemy oczekiwać, że efektem działania programu będzie wyświetlanie w konsoli tekstu <code>Hey John</code>. Możesz to łatwo przetestować.</p>
<p>Jakie jest zastosowanie funkcji callback? Bardzo szerokie. Jej idea to jeden z podstawowych konceptów języka. Jest wykorzystywana m.in. w wielu wbudowanych w JS-a metodach jak <code>addEventListener</code>, <code>map</code> czy <code>reduce</code> (tych dwóch ostatnich jeszcze nie używaliśmy). Dobrze sprawdza się również w przypadku funkcji asynchronicznych, czyli takich, które potrafią wykonywać coś "w tle", niezależnie od wątku głównego. Często wykorzystuje się wtedy <code>callback</code>, jako referencję do funkcji, która ma być wywołana dopiero w momencie zakończenia asynchronicznej operacji. O tego typu funkcjach powiemy jednak trochę dalej. W tym module jeszcze się tym nie zainteresujemy.</p>
<h4>Na co warto uważać?</h4>
<p>W przypadku wykorzystywania funkcji callback musimy jednak uważać na jedną rzecz. Pamiętaj, aby przekazywać referencję do funkcji, a nie to, co ona zwraca. Spójrz tylko na poniższy kod.</p>
<pre><code class="language-js">function hello(name) {
  console.log('Hey', name);
}

function runOtherFunc(callback) {
  const val = prompt('Pass the value!');
  callback(val);
}

runOtherFunc(hello());
</code></pre>
<p>O ile wcześniejszy przykład, w którym przy <code>hello</code> nie pojawiły się nawiasy, zadziałał bezbłędnie, to tutaj mielibyśmy już problem. Dla JS-a dwa skierowane do siebie nawiasy są równoznaczne z rozkazem “wykonaj tę funkcję”. Tym samym funkcja zostanie wykonana, w naszej sytuacji zwróci wartość <code>undefined</code> (brak słowa kluczowego <code>return</code> jest równe <code>return undefined</code>) i to właśnie ona zostanie przekazane jako wartość parametru <code>callback</code>. Tym samym <code>runOtherFunc</code> będzie starało się wywołać… wartość <code>undefined</code>, a jak zapewne się domyślasz, to nie ma prawa się udać.</p>
<p>Czasem jednak chcemy przekazać funkcję, od razu informując, z jakim argumentem ma się ona wykonać. Zresztą, taka sytuacja zdarzyła nam się nawet w aplikacji z grą kamień, papier, nożyce. Mieliśmy nasłuchiwacz, który powinien włączać funkcję <code>playGame</code> i od razu przekazywać jej informację, co wybrał gracz. Właśnie poprzez argument. Co w takiej sytuacji zrobić? Z jakich technik możesz skorzystać? Najprościej możemy po prostu “opakować” wywołanie takiej funkcji w inną funkcję. Właśnie tak na pewno udało Ci się to rozwiązać również w module z grą, prawda?</p>
<pre><code class="language-js">function hello(name) {
  console.log('Hey', name);
}

function runOtherFunc(callback) {
  const val = prompt('Pass the value!');
  callback();
}

runOtherFunc(function() { hello('John'); });
</code></pre>
<p>Spójrz tylko na powyższy przykład.</p>
<p>Tym razem jako <code>callback</code> przekazujemy referencję do zupełnie nowej prostej funkcji <code>function { hello('John'); }</code>. Co istotne, nie włączamy jej (nie ma tu nawiasów <code>()</code>), przekazujemy tylko referencję. Zatem udało nam się załatwić pierwszy problem. <code>callback</code> będzie tutaj referencją do funkcji <code>function() { hello('John'); }</code>, a nie tylko wartością działania funkcji, jak to było wcześniej.</p>
<p>A co stanie się dalej, kiedy dojdzie do wykonania funkcji <code>callback</code> w <code>runOtherFunc</code>? Uruchamiając <code>callback</code>, wystartujemy tak naprawdę tę funkcję:</p>
<pre><code class="language-js">function() {
  hello('John');
}
</code></pre>
<p>Co ona w takiej sytuacji zrobi? Jej kod jest bardzo prosty: włączy funkcję, do której kieruje właśnie <code>hello</code>! A jako parametr przekaże tekst <code>'John'</code>! Czyli ostatecznie i tak włączy się funkcja ukryta pod <code>hello</code>, tak jak chcieliśmy od samego początku – i co ważne, jest ona uruchamiana z założonym parametrem.</p>
<p>Jak widzisz, faktycznie udało nam się przemycić wywołanie <code>hello</code> do funkcji <code>runOtherFunc</code> wraz z informacją o wartości parametru. Oczywiście potrzebowaliśmy tutaj konia trojańskiego (pośrednika) w postaci dodatkowej funkcji, ale… udało się!</p>
<p>Zapewne podobnie wyglądało to w Twojej aplikacji z grą:</p>
<pre><code class="language-js">rockBtn.addEventListener('click', function() { playGame(1); });
</code></pre>
<p>Mamy rację? ;) Czyli już wcześniej zdarzyło Ci się skorzystać z tej techniki. Tylko że teraz już wiesz, dlaczego była nam ona w ogóle potrzebna.</p>
<h4>Tajemniczy argument w <code>addEventListener</code></h4>
<p>Przy okazji wyjaśniła się kolejna magiczna rzecz z poprzednich modułów, a mianowicie argument <code>event</code> w metodzie <code>addEventListener</code>. Zapewne pamiętasz, że niektóre funkcje w aplikacji z blogiem, oczekiwały na pewien tajemniczy argument <code>event</code>. Mówiliśmy, że jest to obiekt z informacjami o zdarzeniu, a jedną z jego metod jest <code>preventDefault</code>, a więc funkcja, która potrafi blokować domyślne zachowanie przeglądarki. Skąd jednak on pochodził? Tego nie powiedzieliśmy. A w końcu, przy samym dodawaniu nasłuchiwacza, nic o żadnym obiekcie <code>event</code> nie wspominamy.</p>
<p>Spójrz tylko na jedną z pętli z tamtego projektu.</p>
<pre><code class="language-js">for(let link of links) {
  link.addEventListener('click', tagClickHandler);
}
</code></pre>
<p>Staramy się tutaj przejść po każdym linku z kolekcji linków (<code>links</code>) i dla każdego z nich dodajemy nasłuchiwacz. Określamy, że JS ma obserwować każdy z linków i oczekiwać na event (zdarzenie) kliknięcia. Jeśli je wykryje, musi uruchomić funkcję <code>tagClickHandler</code>. Nie ma tu jednak słowa o tym, że funkcja ta otrzyma jakieś informacje. Skąd się więc one biorą?</p>
<p>Cóż, skoro już wiesz, jak działają funkcję callback, to możesz się tego łatwo domyślić.</p>
<p>Najprawdopodobniej metoda <code>addEventListener</code> wygląda mniej więcej tak:</p>
<pre><code class="language-js">addEventListener: function(eventType, callback) {
  // ...
  const eventObj = { preventDefault: ..., target: ...}
  callback(eventObj)
}
</code></pre>
<p>Jest to po prostu funkcja, która oczekuje na dwa argumenty – informacje o typie zdarzenia, który chcemy obserwować (<code>eventType</code>) oraz referencje do funkcji, która ma się uruchomić po jego wykryciu (<code>callback</code>). Oczywiście jako callback przekazujemy zawsze referencje do funkcji, to już wiesz. Z taką wiedzą, łatwo możemy zrozumieć, co dzieje się dalej.</p>
<p>Kiedy JS wykryje, że dane zdarzenie rzeczywiście ma miejsce w obserwowanym elemencie, uruchamia argument <code>callback</code>. Jest on tylko referencją do przekazanej wcześniej funkcji. Tym samym uruchamiając <code>callback</code>, tak naprawdę uruchamiamy oryginalną przekazaną do tego parametru funkcję. W naszym przykładzie wyżej tą funkcją był <code>tagClickHandler</code>. Włączając więc <code>callback</code>, metoda <code>addEventListener</code> włączyłaby tak naprawdę <code>tagClickHandler</code>.</p>
<p>Jeszcze ważniejsze jest jednak to, w jaki sposób ją wywołujemy. Zobacz, że ta funkcja nie tylko jest uruchamiana, ale dodatkowo otrzymuje jeszcze jakieś dane! Właśnie wspomniany wcześniej obiekt z informacjami o zdarzeniu! Teraz wystarczy, żeby taka funkcja faktycznie taki argument "odbierała".</p>
<pre><code class="language-js">function tagClickHandler(event) {
  ...
}
</code></pre>
<p>Jeśli to zrobi, to może potem z niego skorzystać, np. uruchamiając metodę <code>preventDefault</code>. Oczywiście, jeśli w funkcji, którą przekazujemy, nie przygotujemy żadnego parametru, nic się nie stanie. Metoda <code>addEventListener</code> i tak taką funkcję uruchomi. Owszem, przekazany obiekt ze zdarzeniem nie będzie odebrany, ale czy musi? Wcale nie. Podsumowując, metoda <code>addEventListener</code> zawsze uruchamia otrzymaną funkcję <code>callback</code> wraz z obiektem z informacjami o zdarzeniu i jeśli chcemy, to możemy je odebrać. Wystarczy, że nasza funkcja <code>callback</code> będzie oczekiwała na przynajmniej jeden argument. Jeśli będzie, to właśnie on zostanie obdarowany takim obiektem.</p>
<h3>Ćwiczenia</h3>
<h4>Pytanie 1</h4>
<p>Jak myślisz, czy funkcja może przyjąć jako parametry więcej niż jedną funkcję <code>callback</code>? Czy nazwy tych parametrów mogą być dowolne?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-g2vxdH7p9D-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-g2vxdH7p9D-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-g2vxdH7p9D-toggle" class="collapse">
<p>Jak najbardziej. Działa to tak samo, jak z każdym innym typem danych. Podobnie jak możemy przekazywać dwa, trzy albo i więcej stringów czy obiektów, tak samo możemy czynić to z funkcjami.</p>
<p>Np.</p>
<pre><code class="language-js">function foo(cbOne, cbTwo) {
  cbOne();
  cbTwo();
}

foo(function() { console.log('One!'); }, function() { console.log('Two!'); })
</code></pre>
<p>...pokaże w konsoli tekst <code>One!</code> oraz <code>Two!</code>.</p>
<p>Nazwy parametrów mogą być oczywiście dowolne, chociaż często dla ułatwienia czytelności kodu korzystamy z nazw <code>callback</code> lub <code>cb</code>.</p>
</div>
<h4>Pytanie 2</h4>
<p>Jak uważasz, czy funkcja przekazywana jako <code>callback</code> do metody <code>addEventListener</code> może odbierać obiekt z informacjami o zdarzeniu do argumentu o innej nazwie niż <code>event</code>?</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-V1OWYJb4pZ-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-V1OWYJb4pZ-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-V1OWYJb4pZ-toggle" class="collapse">
<p>Oczywiście. Metoda <code>addEventListener</code> uruchamia funkcję przekazaną jako <code>callback</code> zawsze z jednym argumentem. Przekazuje w nim obiekt z informacjami o zdarzeniu. Jeśli ta funkcja będzie posiadała przynajmniej jeden parametr, to właśnie on otrzyma ten obiekt, ale jego nazwa nie ma znaczenia. Może to być <code>event</code>, może to być <code>e</code> albo i nawet <code>abc</code>. Chociaż oczywiście te dwie pierwsze mają znacznie więcej sensu ;)</p>
<p>Jeśli masz jeszcze jakieś wątpliwości, to przypomnij sobie, jak działają funkcje.</p>
<p>Np.</p>
<pre><code class="language-js">function foo(name) {
  console.log(name)
}

foo('bar');
foo('baz');

// alternate version
function foo(param) {
  console.log(param)
}

foo('bar');
foo('baz');

</code></pre>
<p>Wywołując funkcję <code>foo</code>, nie przejmujemy się, jak nazywa się parametr, pod który przekażemy daną wartość. Może to być <code>name</code>, a może to być <code>param</code>. Ważna jest jedynie kolejność. Pierwszy parametr zawsze dostanie pierwszą wartość, drugi drugą itd. Jednak nazwa może być dowolna.</p>
<p>Stąd też funkcja <code>callback</code> zawsze dostanie pod pierwszym argumentem informacje o evencie. Nieważne, czy nazywa się on <code>e</code>, <code>event</code> czy <code>abc</code>.</p>
</div>
<h4>Pytanie 3 (dla ambitnych)</h4>
<p>Czy poniższy kod jest poprawny? Co pokaże się w konsoli po jego wykonaniu?</p>
<pre><code class="language-js">function foo(cb, text) {
  cb(text);
}

function bar(textOne, textTwo) {
  console.log(textOne, textTwo);
}

foo(function(txt) { bar(txt, 'World') }, 'Hello');
</code></pre>
<p>To znacznie trudniejszy przykład, spróbuj jednak go rozwikłać.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-fnjk6x-EW5-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-fnjk6x-EW5-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-fnjk6x-EW5-toggle" class="collapse">
<p>Kod jest poprawny. Konsola wyświetli napis <code>Hello World</code>. Napis <code>Hello</code> pochodzi z argumentu <code>text</code>, który <code>bar</code> dostaje po wywołaniu <code>cb</code> (czyli funkcji <code>function(txt) { bar(txt, 'World') }</code>). <code>World</code> jest za to dostarczany do <code>bar</code> bezpośrednio.</p>
<p>To bardziej zawiły przykład. Nie oczekujemy, że masz go rozwiązać ot tak. Spróbuj go przeanalizować kilka razy, a w razie wątpliwości poproś o pomoc Mentora. Jeśli uda Ci się go zrozumieć bez dodatkowej pomocy, naprawdę może rozpierać Cię duma.</p>
</div>
<h3>Magiczne słowo <code>this</code></h3>
<p>W poprzednim module pojawiło się jeszcze jedno tajemnicze słowo – <code>this</code>. Jak zapewne pamiętasz, pojawiało się w funkcjach i najczęściej wskazywało na kliknięty element. Czy zawsze tak jest? Niestety nie. Skąd w takim razie mamy wiedzieć czym będzie <code>this</code> w danej sytuacji?</p>
<p>Wbrew pozorom, to nie będzie aż takie trudne. Możliwości, czym <code>this</code> będzie w danej sytuacji, nie ma wcale aż tak dużo i opierają się ona na kilku prostych zasadach. Znając je, będziesz w stanie zawsze bezboleśnie i z pewnością stwierdzić, czego się spodziewać.</p>
<p>Przedstawimy je za chwilę w odwrotnej kolejności – od najmniej ważnej do tej, która dla silnika JS będzie kluczowa. Każda kolejna zasada będzie miała więc większy priorytet.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Uwaga!</h4>
<p>Wszystkie te zasady tyczą się ustalania <code>this</code> w funkcji. W kontekście globalnym (czyli poza jakąkolwiek funkcją) <code>this</code> będzie zawsze równe obiektowi globalnemu, czyli <code>window</code>.</p>
</div>
<h4>Default rule – Window vs Undefined</h4>
<p>Pierwsza z nich jest dość krótka: <strong>jeśli skrypt jest wykonany w strict mode, to <code>this</code> w funkcji przyjmuje wartość <code>undefined</code>. Jeśli nie, to przyjmuje wartość obiektu globalnego</strong>, czyli obiektu <code>window</code>.</p>
<p>Proste? Proste! Aby to uwiarygodnić, sprawdź dwa poniższe przykłady:</p>
<pre><code class="language-js">'use strict';

console.log(this);

function foo() {
  console.log(this);
}

foo();
</code></pre>
<p>W kontekście globalnym (czyli poza jakąkolwiek funkcją) <code>this</code> to naturalnie obiekt <code>window</code>. W funkcji <code>foo</code>, zgodnie z treścią w ramce powyżej – również będzie to już <code>undefined</code>.</p>
<p>To teraz przykład bez <code>use strict</code>, żeby udowodnić drugą tezę:</p>
<pre><code class="language-js">console.log(this);

function foo() {
  console.log(this);
}

foo();
</code></pre>
<p>Oczywiście <code>this</code> w kontekście globalnym się nie zmieniło. Tak jak mówiliśmy, jest to bowiem zawsze <code>window</code>. Zmienił się jednak <code>this</code> w funkcji <code>foo</code>, który teraz zgodnie z zasadą również wskazuje na <code>window</code>.</p>
<p>Jak widzisz, pierwsza zasada okazała się dość prosta. W takim razie możemy iść dalej.</p>
<h4>Implicit binding rule – wywoływanie metody</h4>
<p>Druga jest już trochę ciekawsza. Na razie tworzyliśmy głównie bardzo proste obiekty, takie jak np. <code>allTags</code>.</p>
<pre><code class="language-js">const allTags = {
  code: 1,
  news: 2,
  ...
}
</code></pre>
<p>Mogą być one jednak znacznie ciekawsze. Właściwości obiektu nie muszą być bowiem proste. Nie muszą być tylko tekstem, czy liczbą (jak w przykładzie wyżej). Mogą być również tablicą, kolejnym obiektem, czy nawet funkcją!</p>
<p>Spójrz tylko na poniższy przykład:</p>
<pre><code class="language-js">const JohnDoe = {
  firstName: 'John',
  lastName: 'Doe',
  hobbies: ['sport', 'movies'],
  sayHello: function() {
    console.log('Hello!');
  }
}
</code></pre>
<p>Dostęp do właściwości <code>sayHello</code> nie będzie inny niż w przypadku chociażby <code>firstName</code>. Dojdziemy do niej po "kropce".</p>
<pre><code class="language-js">JohnDoe.sayHello();
</code></pre>
<p>Kiedy już to wiemy, to możemy przejść do zasady numer dwa. <strong>Jeśli wywołujemy metodę (właściwość, która jest funkcją) jakiegoś obiektu, to wskazuje on właśnie na ten obiekt.</strong></p>
<p>Dwa krótkie przykłady:</p>
<pre><code class="language-js">const foo = {
  bar: function() {
    console.log(this);
  }
}

foo.bar();
</code></pre>
<p>Na co wskaże <code>this</code>? Zgodnie z tą zasadą, na obiekt <code>foo</code>. To jeszcze jeden:</p>
<pre><code class="language-js">function func() {
  console.log(this);
}

const foo = {
  bar: func
}

foo.bar();
</code></pre>
<p>Drugi przykład jest znacznie ciekawszy. Czym będzie <code>this</code> tym razem? Zgodnie z zasadą – również <code>foo</code>.</p>
<p>Metoda <code>bar</code> to tylko referencja do funkcji znanej jako <code>func</code>. Uruchamiając więc <code>foo.bar</code>, tak naprawdę uruchamiamy funkcję:</p>
<pre><code class="language-js">function() {
  console.log(this);
}
</code></pre>
<p>A skoro uruchamiamy ją "na obiekcie" (<code>foo.bar</code>), no to <code>this</code> będzie wskazywać również właśnie na ten obiekt.</p>
<p>Pokazuje to jedną bardzo istotną rzecz: <strong>nieważne, gdzie funkcja jest zapisana w kodzie. Ważne gdzie jest wywoływana</strong>. Zauważ, że w naszym przykładzie funkcja <code>bar</code> jest tak naprawdę “trzymana” poza obiektem <code>foo</code>. Atrybut <code>bar</code> z tego obiektu jest tylko referencją do niej. Jednak mimo tego, że sama funkcja jest poza tym obiektem, to przy wywołaniu wskazuje właśnie na niego. Czyli jeszcze raz, zapamiętaj – <code>this</code> tyczy się miejsce wywołania funkcji (tzw. "call site"), a nie jej fizycznej pozycji w kodzie.</p>
<p>Żeby zostało Ci to w głowie, spójrz na ostatni przykład:</p>
<pre><code class="language-js">function func() {
  console.log(this);
}

const obj1 = {
  name: 'object 1',
  bar: func
}

const obj2 = {
  name: 'object 2',
  bar: func
}

obj1.bar(); // this = obj1
obj2.bar(); // this = obj2
</code></pre>
<p>Czym będzie this w przypadku wywołania <code>obj1</code>, a czym w przypadku wywołania <code>obj2</code>? Zgodnie z zasadą – obiektem, na którym włączamy tę funkcję. Raz będzie to więc <code>obj1</code>, a za drugim razem <code>obj2</code>. Zatem widzisz, ponownie mimo tego, że kierujemy do jednej i tej samej funkcji i nie zmieniła ona położenia, to <code>this</code> zależnie od miejsca jej wywołania (call site), wskaże na inną wartość.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-5.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-5.png" alt="image" style="width: auto; max-width: 50%;"></a>
<h4>Explicit binding rule – wymuszenie kontekstu</h4>
<p>W wielu przypadkach dwie pierwsze zasady mogą Ci wystarczyć, ale znajdą się wciąż takie, w których bez znajomości kolejnych, nie zrozumiemy, co się dzieje.</p>
<p>Spójrz chociażby na ten przykład:</p>
<pre><code class="language-js">const button = document.querySelector('#btn');

function foo(event) {
  console.log(event, this);
}

button.addEventListener('click', foo);
</code></pre>
<p>Załóżmy, że stała button kieruje nas do faktycznie istniejącego przycisku nas stronie. Jak myślisz, co pokazałoby się w konsoli po kliknięciu?</p>
<p>Zapewne wiesz już z poprzednich modułów, że będzie to obiekt z informacjami o evencie (parametr <code>event</code>) oraz referencja do samego buttona (<code>this</code>). Dlaczego jednak w tej sytuacji <code>this</code> jest tym, czym jest? Dlaczego jest buttonem? W końcu żadne z naszych znanych zasad takiego przypadku nie omawiają. Jak widzisz, musimy drążyć dalej.</p>
<p>Aby zrozumieć ten przykład, musimy wrócić do omówienia, jak może być zbudowana funkcja <code>addEventListener</code>.</p>
<pre><code class="language-js">addEventListener: function(eventType, callback) {
  // ...
  const eventObj = { preventDefault: ..., target: ...}
  callback(eventObj)
}
</code></pre>
<p>Przypomnijmy, zapewne przyjmuje ona w formie parametrów informacje, na jakie zdarzenie JS ma zwrócić uwagę oraz referencję do funkcji <code>callback</code>, która ma się wykonać w momencie jego wykrycia.</p>
<p>W momencie wykrycia zdarzenia zapewne tworzony jest obiekt ze szczegółowymi informacjami na jego temat, a gdy jest już gotowy, dochodzi do wywołania funkcji <code>callback</code> wraz z przekazaniem tego obiektu poprzez pierwszy parametr.</p>
<p>Taki scenariusz tłumaczy skąd możliwość “odebrania” tego obiektu pod parametrem <code>event</code> w naszym przykładzie.</p>
<pre><code class="language-js">const button = document.querySelector('#btn');

function foo(event) {
  console.log(event, this);
}

button.addEventListener('click', foo);
</code></pre>
<p>No dobrze, ale co z samym elementem <code>this</code>? Dlaczego wskazuje on na button? Spokojnie, zaraz do tego dojdziemy.</p>
<p>Na pewno <code>addEventListener</code> musi wiedzieć, na jaki element powinien zwracać uwagę, obserwować. Skąd? Tu odpowiedź będzie bardzo prosta.</p>
<p>Spójrz na wywołanie tej funkcji w naszym przykładzie:</p>
<pre><code class="language-js">button.addEventListener('click', foo);
</code></pre>
<p>Czy któraś z poznanych Ci już zasad się w tym miejscu sprawdzi? Tak. Zasada <strong>Implicit binding rule</strong>, czyli jeśli włączamy metodę na obiekcie, to <code>this</code> w kontekście wywołania takiej funkcji wskaże właśnie na ten obiekt. A więc na co wskaże <code>this</code> w kontekście wywołania <code>addEventListener</code> w naszym przypadku? Na przycisk (stała <code>button</code>)! Pamiętaj bowiem, że element DOM to obiekt jak każdy inny.</p>
<p>Dobrze, wiemy już wewnątrz funkcji <code>addEventListener</code>, że <code>this</code> wskaże tu nasz button, ale jak to możliwe, że potem ten <code>this</code> został przekazany dalej do funkcji <code>foo</code>? Jak rozwiązali to twórcy tej funkcji?</p>
<p>Na pewno nasz pomysł jest tutaj zbyt prosty.</p>
<pre><code class="language-js">addEventListener: function(eventType, callback) {
  const targetElement = this;
  console.log(targetElement); // button
  // ...
  const eventObj = { preventDefault: ..., target: ...}
  callback(eventObj)
}
</code></pre>
<p>Wiemy, że wewnątrz funkcji <code>addEventListener</code> mamy dostęp do odpowiedniego <code>this</code>, ale czy wywołanie <code>callback</code> też go dostanie? Nie. Dla wywołania funkcji JS ustala <code>this</code> od nowa. Która ze znanych Ci już zasad byłaby więc brana pod uwagę przy jego ustaleniu dla funkcji <code>callback</code>? Nie jest to funkcja wywoływana na obiekcie, więc zgodnie z hierarchią trafiamy do zasady <strong>default rule (domyślnej)</strong>.</p>
<p>Zakładając, że nie używamy w naszym przykładzie <code>strict mode</code>, zgodnie z zasadą <code>callback</code> (czyli <code>foo</code>) wskaże nam jako <code>this</code> obiekt globalny <code>window</code>.</p>
<p>Wszystko dotychczas jest jasne? <code>addEventListener</code> jest wywoływana na obiekcie DOM, więc <code>this</code> w kontekście wywołania tej metody wskazuje na ten obiekt właśnie – przycisk. Funkcja <code>callback</code> (czyli właściwie <code>foo</code>) nie jest wywoływana na obiekcie, nie mamy również <code>strict mode</code>, więc zgodnie z poznanymi zasadami jej <code>this</code> wskaże na obiekt <code>window</code>.</p>
<p>Pozostaje nam w takim razie jedna kwestia – jak wymusić na <code>foo</code>, żeby pokazywała jako <code>this</code> coś innego, to co chcemy?</p>
<h5>Metody <code>call</code> i <code>apply</code></h5>
<p>To jest nasza odpowiedź. Obie powyższe metody pozwalają na wywoływanie funkcji z dowolnymi parametrami i dowolną wartością <code>this</code>. Oznacza to, że możemy wywołać funkcję w taki sposób, że <code>this</code> nie będzie ustalane przez JS-a, tylko przez nas! Różnica między nimi jest tylko taka, że w <code>call</code> parametry wypisujemy po kolei jak przy standardowym wywołaniu:</p>
<pre><code class="language-js">func.call(thisArg, param1, param2);
</code></pre>
<p>Natomiast w przypadku <code>apply</code> parametry funkcji są przekazywane w formie tablicy:</p>
<pre><code class="language-js">func.apply(thisArg, [argsArray]);
</code></pre>
<p>W każdym razie obie nadadzą się idealnie, w sytuacji, gdy chcemy wprowadzić do danego kontekstu funkcji własne <code>this</code>. Mając nową wiedzę, możemy łatwo zmodyfikować nasz przykład.</p>
<pre><code class="language-js">function addEventListener(eventType, callback) {

  const targetElement = this;

  /* ... then when JS observes eventType, it reacts. */

  /* eventData object with details is created and.. */

  callback.call(targetElement, eventData);
}
</code></pre>
<p>Metoda <code>call</code> nadal będzie w stanie wywołać funkcję ukrytą pod <code>callback</code>, ale tym razem wartość <code>this</code> w takiej funkcji będzie równa <code>targetElement</code>… czyli tak naprawdę <code>thisowi</code> z kontekstu funkcji <code>addEventListener</code>! Koniec końców funkcja <code>callback</code> przy takim uruchomieniu będzie miała więc faktycznie ten sam <code>this</code> co kontekst funkcji <code>addEventListener</code>. Zatem w końcu, przekazana do nasłuchiwacza <code>foo</code>, pokaże nam, zgodnie z planem, jako <code>this</code> nasz button.</p>
<p>Jak widzisz, nie było to aż takie trudne, ale okazuje się, że bez znajomości tej zasady i wiedzy, że w ogóle można wymusić na kontekście funkcji własne <code>this</code>, zrozumienie, co tu się właściwie stało, nie byłoby możliwe.</p>
<p>Nie oczekujemy, że masz ten przykład zapamiętać. Prawdopodobnie podczas niniejszego kursu, nigdy nie będzie potrzeby skorzystania ze wspomnianych metod. Pokazaliśmy ten przykład głównie dlatego, żeby udowodnić Ci, że za JS-em nie stoi żadna magiczna siła. To wszystko z czegoś wynika. Tak naprawdę wystarczy, że wyniesiesz z tego jedno, iż <strong>funkcja <code>callback</code> uruchamia przez nasłuchiwacz domyślnie zawsze wskaże jako <code>this</code> ten element, na którym uruchomiona była sama metoda <code>addEventListener</code></strong>.</p>
<p>Oczywiście nie tylko <code>addEventListener</code> może korzystać z metody <code>.call</code>. To zwykła metoda, sami też możemy jej użyć w naszym kodzie i jako <code>this</code> podstawić cokolwiek tylko chcemy.</p>
<p>Spójrz na ten przykład:</p>
<pre><code class="language-js">function foo() {
  console.log(this);
}

foo.call({ bar: 'baz' });
</code></pre>
<p>Otrzymamy w konsoli:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-6.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-6.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Podsumowując: <strong>za pomocą metody <code>call</code> lub <code>apply</code> możemy wymusić dowolną wartość <code>this</code> w danym kontekście, nie zważając nawet, jaka byłaby domyślnie</strong>.</p>
<h5>Hard binding</h5>
<p>Metody <code>call</code> i <code>apply</code> pozwalają wymusić dowolną wartość tylko <code>this</code> przy konkretnym wywołaniu. Na stałe już nie. Istnieje jednak inna metoda, która jest w stanie to zrobić!</p>
<p>To metoda <code>bind</code>. Potrafi ona na podstawie dowolnej funkcji stworzyć nową, która po otrzymaniu na starcie założonego z góry <code>this</code>, zawsze będzie się go trzymać, nieważne, w którym miejscu w kodzie (call site) ją wywołamy. Brzmi nieźle? Jak najbardziej i działa równie prosto.</p>
<p>Spójrz tylko na poniższy przykład:</p>
<pre><code class="language-js">function foo(param) {
  console.log(this, param);
}

const lockedFoo = foo.bind({ bar: 'baz' });

const obj = {
  foo: lockedFoo
};

lockedFoo('Spam!');
obj.foo('Spam!'); // this = { bar: 'baz' }
</code></pre>
<p>I na efekt jego działania:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-7.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-7.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Nieważne, czy włączamy tę funkcję w kontekście globalnym, czy jako metodę obiektu <code>obj</code>, to <code>this</code> jest za każdym razem taki sam. Co więcej, wciąż da się przekazać jakieś parametry!</p>
<p>W jakiej sytuacji <code>bind</code> ma zastosowanie? Kiedy np. <code>this</code> ma ogromne znaczenie dla działania funkcji, ta jest wywoływana w wielu miejscach, a my chcemy mieć pewność co do jego wartości. Wbrew pozorom <code>bind</code> nie jest aż tak często używane, ale na pewno jest to metoda, którą warto znać.</p>
<p>Podsumujmy tę, ale i wcześniejszą zasadę. Za pomocą metody <code>call</code> lub <code>apply</code> możemy wymusić wartość dowolną <code>this</code> przy konkretnym wywołaniu funkcji, nie zważając nawet, jaka byłaby domyślnie. Metoda <code>bind</code> pozwala nam za to stworzyć nową funkcję na bazie już istniejącej, która na zawsze z domysłu będzie miała z góry założoną wartość <code>this</code>, nie zważając na miejsce wykonania.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1964" class="card submodule completed" data-bootcamp-user-submodule-id="604287" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.2. <span>OOP, czyli programowanie obiektowe</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <h3>Słowo kluczowe <code>new</code></h3>
<p>Istnieje jeszcze jedna zasada, która ujawni coś naprawdę niezwykle... ciekawego. Otóż, jeśli wywołując funkcję skorzystasz ze słowa kluczowego <code>new</code>, to JS utworzy nowy pusty obiekt i udostępni go w tej funkcji właśnie pod <code>this</code>. Brzmi to dziwnie, ale naprawdę tak się stanie! Co więcej, ta funkcja z automatu zacznie też taki obiekt zwracać.</p>
<p>No cóż, chyba musisz to zobaczyć na żywo.</p>
<p>Najpierw spróbuj uruchomić następujący przykład:</p>
<pre><code class="language-js">function foo() {
  this.bar = 'baz';
  console.log(this);
}

foo();
</code></pre>
<p>Mamy tutaj jedną funkcję – <code>foo</code>. Po włączeniu powinna ona dodać do <code>this</code> (niezależnie czym on będzie) nową właściwość (<code>bar</code>) o wartości <code>baz</code>, a następnie pokazać jego zawartość.</p>
<p>Przy wywołaniu (<code>foo()</code>) raczej nie masz wątpliwości. Funkcja nie jest włączana na obiekcie ani nie uruchamiamy jej przy użyciu <code>.call</code>, <code>.apply</code>, czy z <code>.bind</code>. W takim razie jedyna z zasad, która ma zastosowanie to pierwsza. Ta, która mówi, że jeśli skrypt nie jest odpalany w <code>strict mode</code>, to funkcja zwróci obiekt <code>window</code>. I tak się faktycznie stanie.</p>
<p>Tym samym nasza funkcja <code>foo</code> przypisze <code>bar</code> do <code>window</code>, a potem pokaże w konsoli właśnie zawartość obiektu globalnego.</p>
<p>Tutaj pewnie wszystko jest jeszcze jasne. Zmodyfikujmy więc nasz kod i dodajmy kolejne wywołanie. Tym razem ze słowem kluczowym <code>new</code>.</p>
<pre><code class="language-js">function foo() {
  this.bar = 'baz';
  console.log(this);
}

foo();
const obj = new foo();
console.log(obj);
</code></pre>
<p>Zajrzyj teraz do konsoli. Okaże się, że pierwsze wywołanie tej funkcji przyniesie takie same rezultaty. To oczywiste. Jednak już drugie... no właśnie...</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-8.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-8.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Spójrz tylko. Okazało się, że tym razem <code>this</code> to jakiś obiekt z jedną właściwością <code>bar</code>. Co to oznacza? Wygląda na to, że przy włączeniu funkcji <code>foo</code>, <code>this</code> domyślnie stał się pustym obiektem. Nasza instrukcja <code>this.bar = 'baz'</code> dodała więc do niego nową właściwość <code>bar</code>. Dlatego też konsola jako <code>this</code> pokazała właśnie <code>{ bar: 'baz' }</code>.</p>
<p>Wygląda to dziwnie, ale właśnie tak się stało! Co więcej, zwróć uwagę co otrzymaliśmy w konsoli jako <code>obj</code>. Ten sam obiekt! Wygląda więc na to, że mimo tego, że w naszej funkcji nie użyliśmy słowa kluczowego <code>return</code>, to ta i tak coś w takiej sytuacji zwróciła. A konkretnie właśnie ten obiekt, który widzieliśmy też pod <code>this</code>.</p>
<p>Jak możesz sobie to wytłumaczyć? Najprościej zapamiętaj to w taki sposób, że słowo kluczowe <code>new</code> przy wywołaniu funkcji dodaje do niej dwie "niewidoczne" linijki.</p>
<pre><code class="language-js">function() {
  const this = {};
  ...
  return this;
}
</code></pre>
<p>Jeśli tak to sobie to wyobrazimy, to łatwiej możemy zrozumieć, co się właściwie stało przy drugim wywołaniu:</p>
<pre><code class="language-js">function foo() {
  const this = {}
  this.bar = 'baz';
  console.log(this);
  return this;
}
</code></pre>
<p>Spójrz tylko. Wszystko od razu staje się jaśniejsze. Funkcja <code>foo</code> się uruchamia, tworzy nowy pusty obiekt i zapisuję go pod <code>this</code>, następnie dodajemy do niego właściwość <code>bar</code>, pokazujemy w konsoli i zwracamy.</p>
<p>W takiej sytuacji łatwiej możemy też zrozumieć, skąd taka niespodziewana wartość <code>obj</code>.</p>
<pre><code class="language-js">const obj = new foo();
console.log(obj);
</code></pre>
<p>Skoro wiemy, że nasza funkcja <code>foo</code> w takiej sytuacji zwraca po prostu wcześniej utworzony obiekt (a dokładnie referencję do niego), to łatwo możemy zrozumieć, że <code>obj</code> zwyczajnie ją przyjmuje. Tym samym pokazując w konsoli <code>obj</code>, pokazujemy właśnie ten utworzony wcześniej obiekt – <code>{ bar: 'baz' }</code>.</p>
<p>Musisz przyznać, że teraz staje się to już trochę bardziej czytelne. Wystarczy więc, że zapamiętasz, iż <strong>przy wywołaniu funkcji za pomocą słowa kluczowego <code>new</code>, JS utworzy nowy pusty obiekt i przypisze go do <code>this</code> tej funkcji oraz zadba o to, aby go zwracała.</strong></p>
<h4>Interesujący use-case</h4>
<p>Takie zachowanie funkcji może wydawać się dziwne, ale... wbrew pozorom daje nam bardzo ciekawą zaletę.</p>
<p>Wyobraź sobie, że mamy trzy bardzo podobne obiekty.</p>
<pre><code class="language-js">const JohnDoe = { firstName: 'John', lastName: 'Doe', age: 22 };
const AmandaDoe = { firstName: 'Amanda', lastName: 'Doe', age: 30 };
const ThomasJefferson = { firstName: 'Thomas', lastName: 'Jefferson', age: 25 };
</code></pre>
<p>Wszystkie obiekty są identyczne, co do swojej budowy. Mimo to jednak, deklarujemy je jako trzy osobne byty. Oczywiście, my jesteśmy w stanie szybko zauważyć, że to bardzo podobne obiekty, ale JS wcale ich ze sobą nie powiąże. W takiej sytuacji, gdybyśmy np. pomylili się i w jednym z obiektów zamiast właściwości <code>firstName</code> wpisali <code>firtName</code>, to JS wcale nie podniesie alarmu. Dla niego nie będzie problemem to, że jakiś obiekt ma właściwość <code>firstName</code>, a inny <code>firtName</code>, właśnie dlatego, że są to dwa niepowiązane ze sobą obiekty.</p>
<p>Znając jednak działanie słowa kluczowego <code>new</code>, możemy tę sytuację zmienić. Możemy stworzyć funkcję, która będzie działać jako swego rodzaju konstruktor. Taki, który będzie generował obiekty o założonym schemacie. W jaki sposób?</p>
<p>Bardzo prosto:</p>
<pre><code class="language-js">function Person(firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
}

const JohnDoe = new Person('John', 'Doe', 22);
const AmandaDoe = new Person('Amanda', 'Doe', 30);
const ThomasJefferson = new Person('Thomas', 'Jefferson', 25);
</code></pre>
<p>Co tu się właściwie dzieje? Trzy razy włączamy funkcję <code>Person</code> przy użyciu słowa kluczowego <code>new</code>. Za każdym razem funkcja ta tworzy pod <code>this</code> zupełnie nowy obiekt, dodaje do niego trzy właściwości o wartościach zgodnych z argumentami, a na koniec zwraca referencje do niego. Tym samym <code>JohnDoe</code> staje się referencją do obiektu <code>{ firstName: 'John', lastName: 'Doe', age: 22 }</code>, <code>AmandaDoe</code> do obiektu <code>{ firstName: 'Amanda', lastName: 'Doe', age: 30 }</code>, a <code>ThomasJefferson</code> do <code>{ firstName: 'Thomas', lastName: 'Jefferson', age: 25 }</code>.</p>
<p>Czyli koniec końców... otrzymamy dokładnie te same obiekty! Tym razem jednak są one tworzone przez jedną funkcję, która zawsze użyje tych samych nazw właściwości. Nie ma takich opcji, że raz będzie to <code>firstName</code>, a innym razem <code>firtName</code>. Można powiedzieć, że teraz tworzymy obiekty w oparciu o jeden i ten sam schemat. A dodatkowo nasze zmiany spowodowały również lekkie skrócenie kodu.</p>
<p>Jeśli działanie tego kodu nie do końca jest dla Ciebie jasne, to pamiętaj, że najprościej wyobrazić sobie to tak, że JS dodaje przy użyciu <code>new</code> do takiej funkcji dwie niewidoczne linijki.</p>
<pre><code class="language-js">function Person(firstName, lastName, age) {
  const this = {}; // it's hidden from us
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
  return this; // it's hidden from us
}
</code></pre>
<p>I jak? Pewnie teraz ma to już większy sens, prawda?</p>
<h3>Podsumowanie <code>this</code></h3>
<p>Podsumujmy teraz wszystko co wiemy o słowie kluczowym <code>this</code>.</p>
<p>W przypadku kontekstu globalnego (czyli poza funkcjami) wartość <code>this</code> jest zawsze równa referencji do obiektu globalnego, czyli obiektu <code>window</code>.</p>
<p>W przypadku funkcji stosuje się odpowiednie zasady:</p>
<ol>
<li>Jeśli użyto przed funkcją/konstruktorem klasy słowa kluczowego <code>new</code>, to <code>this</code> w tej funkcji zawsze będzie równe referencji do nowo utworzonego obiektu.</li>
<li>Jeśli funkcja została utworzona przy pomocy metody <code>bind</code>, to jej wartość <code>this</code> będzie zawsze równa temu, co zostało ustalone przy jej kreacji. Podobnie jak w przypadku <code>call</code> oraz <code>apply</code>, kontekst (<code>this</code>) jest przypisywany z pierwszego argumentu funkcji.</li>
<li>Jeśli funkcja jest wywoływana za pomocą metody <code>call</code> lub <code>apply</code>, to <code>this</code> w kontekście wywoływanej funkcji zawsze będzie równe wartości podanej jako pierwszy parametr tej metody.</li>
<li>Jeśli funkcja została wywołana “na obiekcie”, to <code>this</code> będzie wskazywał właśnie na ten obiekt.</li>
<li>Domyślnie, jeśli żadna z wcześniejszych zasad nie dotyczy wywołania danej funkcji, <code>this</code> będzie wskazywać na obiekt globalny (<code>window</code>) lub w przypadku użycia <code>strict mode</code> wartość <code>undefined</code>.</li>
</ol>
<p>Kolejność jest tu istotna. Zastanawiając się nad wartością <code>this</code> w danym kontekście, sprawdzaj, czy pasują do niego poszczególne zasady od góry do dołu. Przykładowo, dopiero jeśli ustalisz, że w danym wywołaniu nie ma mowy o słowie kluczowym <code>new</code>, należy zastanawiać się nad zasadą numer 2. Tak samo dopiero jeśli nie ma dalej słowa kluczowego <code>bind</code>, to warto sprawdzić zasadę nr 3 itd.</p>
<p>Jak widzisz, to nie było takie trudne. Mając taką krótką listę zasad, już nigdy nie będziesz mieć problemu z ustaleniem wartości <code>this</code> w danej funkcji. Nie staraj się nauczyć tego koniecznie na pamięć. W razie potrzeby zawsze możesz wrócić do tej listy.</p>
<h3>Podsumowanie</h3>
<p>Zdajemy sobie sprawę, że ten submoduł mógł Cię mocno wymęczyć. Prawdopodobnie wszystko, co w nim poznaliśmy, udało Ci się, koniec końców, przyswoić, jednak wątpliwe, że czujesz się w tych tematach bardzo pewnie. Raczej jeszcze nie do końca. Nie musisz się jednak tym martwić. Tak naprawdę wcale jeszcze tego od Ciebie nie oczekujemy.</p>
<p>Co musisz zapamiętać po tym submodule? Informację, na czym polega referencja, ideę funkcji callback, fakt że jest kilka zasad, które kierują ustaleniem <code>this</code> w funkcji oraz że słowo <code>new</code> użyte na funkcji tworzy i zwraca nowy obiekt. Tylko tyle. To jak brzmią dokładnie zasady ustalania <code>this</code>, jak może wyglądać funkcja <code>addEventListener</code>, czy jak radzić sobie w bardziej skomplikowanych przykładach, nie jest teraz zbyt istotne. W razie potrzeby, po prostu możesz wrócić do treści tego submodułu. Nie staraj się zapamiętywać wszystkiego na siłę. Podczas kolejnych submodułów, ciągle będziemy do tych tematów jeszcze wracać i o nich przypominać. Prędzej czy później, wszystko "wejdzie" Ci więc do głowy samoistnie.</p>
<p>Oczekujemy tylko tego, że masz mieć już "jakieś" pojęcie na temat tego, co przedstawiliśmy. Tak, żeby podczas dalszej części modułu, np. <code>this</code> czy <code>referencje</code> nie były dla Ciebie zupełną nowością. Szczegóły zawsze przypomnimy.</p>
<p>Wyposażeni w nową wiedzę, w końcu na dobre możemy przejść do tematu programowania obiektowego.</p>
<h3>Czym różni się OOP od programowania funkcyjnego?</h3>
<p>Do tej pory stosowaliśmy <strong>programowanie funkcyjne</strong>. Oznacza to, że cały kod naszej aplikacji dzieliliśmy na funkcje. Mieliśmy z góry zaplanowane, co dana funkcja ma zrobić – np. wygenerować listę linków, albo zwrócić wynik jakichś obliczeń.</p>
<p>Dzięki funkcjom mogliśmy wywoływać ten sam kod wiele razy, z różnymi argumentami. Pozwoliło nam to również trochę uporządkować kod naszej aplikacji. No właśnie – <em>trochę</em>. Utrzymanie porządku w podejściu funkcyjnym jest dość trudne. Łatwiej nam będzie zadbać o przejrzystość kodu w OOP.</p>
<p>Zacznijmy może od tego, że w OOP też używamy funkcji i są one bardzo ważne, ale nie są najwyższym poziomem organizacji kodu – ta rola przypada <strong>klasom i instancjom</strong>.</p>
<p>Klasa jest wzorcem/schematem – definicją tego, jak będą "wyglądały" instancje tej klasy. A instancje są obiektami stworzonymi wedle tego wzorca. To trochę jak w naszym przykładzie z poprzedniego submodułu. Mieliśmy "schemat", czyli funkcję <code>Person</code> i instancje, czyli obiekty, które na bazie tego schematu utworzyliśmy.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Gdzie są obiekty w OOP?</h4>
<p>W JS-ie łatwo się pogubić, jeśli chodzi o określenie "obiekt", bo bardzo dużo rzeczy jest obiektem. Wynika to z ogólnej definicji obiektu – jest to zbiór właściwości i metod. Właściwościami są wartości przechowywane w obiekcie, a metodami – funkcje.</p>
<p>Formalnie rzecz biorąc, instancje są obiektami, więc będziemy tych określeń używać naprzemiennie. Pamiętaj jednak, że nie każdy obiekt, musi być instancją jakiejś klasy. Istnieją też inne proste  obiekty – np. tworzone za pomocą nawiasów klamrowych <code>{ }</code>.</p>
<p>Np. obiekt <code>const params = { min: 0, max: 99999 };</code> z poprzedniego modułu wcale nie jest instancją żadnej klasy. Tym samym instancje możemy nazywać obiektami, ale nie wszystkie obiekty można określić jako instancje. Spokojnie, zaraz trochę się to rozjaśni :)</p>
</div>
<p>Załóżmy, że tworzymy bazę pracowników. Czy chcielibyśmy, za każdy razem tworzyć zupełnie nowy obiekt? Nie. Raczej wolelibyśmy zdefiniować jeden schemat – <strong>klasę</strong> <code>Employee</code> (<em>pracownik</em>), która będzie szablonem dla każdego obiektu reprezentującego pracownika. W tej klasie ustalamy, że pracownik będzie miał imię, nazwisko, stanowisko czy wysokość pensji. Podobnie w tej klasie ustalimy, że pracownik ma mieć metodę <code>raise</code> (<em>podwyżka</em>), która podnosi jego pensję np. o <code>5%</code>.</p>
<p>Na poziomie klasy nie wiemy, jaka będzie pensja poszczególnego pracownika. Metoda <code>raise</code> musi tylko wiedzieć, że pracownik będzie miał przypisaną jakąś pensję, i że ma ją podnieść o <code>5%</code>.</p>
<p>Dopiero po napisaniu klasy (schematu) możemy tworzyć jej <strong>instancje</strong>, czyli poszczególnych pracowników. Wtedy podajemy, jak nazywa się dany pracownik, jakie ma stanowisko i jaką pensję. Po jakimś czasie (<em>kiedy pracownik sobie na to zasłuży</em>) możemy też wywołać jego metodę <code>raise</code> – nie musieliśmy tej metody pisać specjalnie dla niego, ponieważ odziedziczył ją z klasy <code>Employee</code>.</p>
<p>Zanim przejdziemy dalej, zapoznaj się ze <strong><a href="https://poradnik-js.kodilla.com/oop-classes" target="_blank">składnią klasy i instancji</a></strong>. Nie musisz wszystkiego rozumieć ani tym bardziej zapamiętywać – warto jednak już teraz przyjrzeć się ich składni. Dzięki temu łatwiej będzie Ci zrozumieć, czym jest klasa.</p>
<p>W tym momencie warto również wrócić na chwilę do poprzedniego submodułu i przykładu z funkcją <code>Person</code>. Zauważ, że tworzenia nowej instancji bardzo mocno przypomina to, jak tworzyliśmy obiekty właśnie przy użyciu tejże funkcji. Nawet korzystamy z tego samego słowa kluczowego – <code>new</code>.</p>
<p>Skąd takie podobieństwo? Stąd, że tak naprawdę w JS, w odróżnieniu od innych popularnych języków programowania, nie ma prawdziwego mechanizmu tworzenia klas. Tak naprawdę, słowo kluczowe <code>class</code> i zapisy, które widzisz w dokumentacji, to tylko "lukier składniowy". Oznacza to tyle, że jesteśmy w stanie pisać kod trochę w bardziej czytelny sposób, ale, koniec końców, jest on konwertowany do innej bardziej skomplikowanej postaci. Dokładnie tak jest też w naszej sytuacji.</p>
<p>Tak naprawdę poniższy przykład:</p>
<pre><code class="language-js">class Employee{
  constructor(name, age, yearlySalary){
    const thisEmployee = this;

    thisEmployee.name = name;
    thisEmployee.age = age;
    thisEmployee.yearlySalary = yearlySalary;

    thisEmployee.calculateMonthlySalary();
  }

  calculateMonthlySalary(){
    const thisEmployee = this;

    thisEmployee.monthlySalary = thisEmployee.yearlySalary / 12;
  }

  showDetails(){
    const thisEmployee = this;

    console.log(thisEmployee.name, thisEmployee.age, thisEmployee.monthlySalary);
  }
}

const john = new Employee('John Doe', 20, 12000);
</code></pre>
<p>...jest konwertowany "pod maską" na:</p>
<pre><code class="language-js">function Employee(name, age, yearlySalary) {
    const thisEmployee = this;

    thisEmployee.name = name;
    thisEmployee.age = age;
    thisEmployee.yearlySalary = yearlySalary;

    thisEmployee.calculateMonthlySalary();
  }
}

Employee.prototype.calculateMonthlySalary = function() {
  const thisEmployee = this;
  
  thisEmployee.monthlySalary = thisEmployee.yearlySalary / 12;
}

Employee.prototype.showDetails = function() {
  const thisEmployee = this;

  console.log(thisEmployee.name, thisEmployee.age, thisEmployee.monthlySalary);
}

const john = new Employee('John Doe', 20, 12000);
</code></pre>
<p>Obie wersje dałyby więc dokładnie taki sam rezultat. Chyba jednak nie trudno Ci zrozumieć, po co ta "maskarada". Zauważ, że w oryginalnym zapisie, całość wygląda znacznie mniej czytelnie. Musimy zastanawiać się, czy <code>function</code> jest w danej sytuacji funkcją, czy może ma udawać "klasę"? Pojawia się też tajemnicza właściwość <code>prototype</code>. Delikatny lukier składniowy sporo nam tutaj uczytelnia. Upodobania przy tym składnię JS-a do tego, jak klasy czy metody (funkcje w klasach) deklaruje się w innych językach. My do końca kursu będziemy już zawsze używać właśnie tej "polukrowanej" składni. Nie musisz więc zaprzątać sobie głowy tym, jak ten kod będzie wyglądać "pod maską".</p>
<p>Podsumujmy teraz krótko naszą wiedzę.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Metafora – klasy i instancje</h4>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/cake.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/cake-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/cake.png 2x" class="img-inline img-right">
<p>Najłatwiej będzie Ci zapamiętać te zagadnienia na przykładzie ciasta.</p>
<p><strong>Klasa</strong> jest jak przepis na ciasto: mówi, jakie składniki i naczynia będą Ci potrzebne, a także jakie operacje będzie trzeba wykonać.</p>
<p><strong>Instancja</strong> jest jak ciasto upieczone na podstawie tego przepisu – jest obiektem stworzonym wedle szablonu, jakim jest przepis.</p>
<p>Ważne, żeby nie mylić tych rzeczy ze sobą – po obiedzie nie częstujemy przepisem, a do regału nie odkładamy ciasta. ;)</p>
</div>
<p>Podobnie jak deklaracja funkcji nie wie, jakie będą argumenty, tak klasa nie wie, jakie dane będą przekazane instancji tej klasy. W trakcie pisania klasy możemy jednak zaplanować, że będziemy chcieli, aby to było np. imię i nazwisko pracownika.</p>
<p>W wielkim skrócie, na tym polega programowanie obiektowe. Będziemy tworzyć klasy, aby służyły za wzorzec wielu instancjom. Każda klasa jest zamkniętym ekosystemem, dzięki czemu łatwiej będzie nam odnaleźć się w kodzie, i bez problemu tworzyć coraz bardziej skomplikowane projekty. Pierwszy z nich zaczynamy już za chwilę...</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1965" class="card submodule completed" data-bootcamp-user-submodule-id="604288" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.3. <span>Otwieramy pizzerię!</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Projektem, który za chwilę rozpoczniemy, będzie strona pizzerii! To nie byle jaka strona – umożliwi złożenie zamówienia z dostawą!</p>
<h3>Specyfikacja projektu</h3>
<p>Chcemy, aby nasza strona pizzerii miała następujące funkcjonalności:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/pizza-slice.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/pizza-slice-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/pizza-slice.png 2x" class="img-inline img-right">
<ul>
<li>menu ma wyświetlać listę produktów,</li>
<li>każdy produkt ma rozwijany panel z opisem i opcjami zamówienia,</li>
<li>każdy produkt może mieć dowolną liczbę opcji w postaci checkboxów, radio-buttonów, oraz selectów,</li>
<li>każda opcja produktu może zmieniać jego cenę,</li>
<li>można zamówić kilka produktów tego samego typu,</li>
<li>zamawiane produkty mają trafiać do koszyka,</li>
<li>koszyk ma podawać cenę zamówienia z uwzględnieniem stałego kosztu dowozu,</li>
<li>dla każdej pozycji w koszyku ma być możliwość usunięcia, zmiany ilości oraz edycji opcji tej pozycji,</li>
<li>lista projektów nie będzie zawarta w plikach JS ani HTML, ale będzie pobierana z serwera już po wczytaniu strony,</li>
<li>składane zamówienia będą zapisywane na serwerze,</li>
<li>strona ma być publicznie dostępna w internecie.</li>
</ul>
<p>Na tym zakończymy projekt – nie będziemy implementować kosztów dowozu zależnych od odległości ani osobnej strony <em>checkout</em> z formularzem na dane osobowe, adres czy wybór formy płatności. Pozostawiamy te aspekty projektu Tobie – po kursie możesz wrócić do projektu i uzupełnić go. Nawet bez nich będzie to wyzwanie, ponieważ mamy przed sobą naukę nowego podejścia do programowania. Dlatego wykonanie całej funkcjonalności tego projektu zajmie nam dwa tygodnie.</p>
<p>Prawie zapomnieliśmy o jeszcze jednej funkcjonalności naszej strony – każdy produkt może mieć swoją ilustrację, która może zmieniać się w zależności od wybranych opcji! Dzięki temu użytkownik będzie widział rysunek dokładnie takiej pizzy lub sałatki, jaką chce zamówić!</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-01.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-01.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Skutkiem ubocznym wyboru takiej tematyki projektu może być wzmożony apetyt, za co serdecznie przepraszamy. ;)</p>
<h3>Uruchomienie projektu</h3>
<p>Zależy nam, żebyśmy w tym module mogli skupić się na programowaniu obiektowym. Dlatego przygotowaliśmy dla Ciebie początkowe pliki projektu. Znajdziesz w nich trochę pomocnych funkcji, ale również zupełnie nowy task runner.</p>
<p>Zacznij od stworzenia nowego repozytorium na GitHubie – może nazywać się np. <code>project-pizzeria</code>. Sklonuj to repozytorium, a następnie rozpakuj do niego pliki projektu, które przygotowaliśmy. Zapisz commit i wypchnij go na zdalne repozytorium.</p>
<p class="text-center">
  <a href="https://uploads.kodilla.com/bootcamp/fer/07.oop/project-pizzeria.zip" class="btn btn-primary">Pobierz pliki projektu</a>
</p>
<p>Na razie niczego nie zmieniaj w tych plikach – zaczniemy od omówienia stanu początkowego.</p>
<div class="bc-note alert-danger">
<h4 class="alert-heading text-center">Początkowy wygląd strony</h4>
<p>Nie zdziw się, że na początku strona będzie wyglądała na pustą. W menu nie będzie żadnych pozycji, ponieważ za chwilę będziemy wstawiać je za pomocą szablonu.</p>
</div>
<h3>Struktura plików</h3>
<p>Pierwszą nowością jest struktura plików. W tym projekcie zastosujemy bardzo często spotykaną strukturę, w której pliki tworzone przez nas będą umieszczone w katalogu <code>src</code> – jest to skrót od słowa <em>source</em>, czyli <em>źródło</em>. Dlatego też pliki w tym folderze będziemy nazywać <strong>plikami źródłowymi</strong>.</p>
<p>W katalogu <code>src</code> zobaczysz znajomą strukturę – tu znajduje się plik <code>index.html</code> oraz katalogi <code>sass</code>, <code>js</code> i <code>images</code>.</p>
<p>W parze z <code>src</code> będziemy mieli katalog <code>dist</code>, czyli skrót od <em>distribution</em>. Zostanie on utworzony po uruchomieniu task runnera i będzie zawierał automatycznie generowane pliki strony na podstawie źródłowych. W naszym projekcie tylko w katalogu <code>src/sass</code> będziemy mieć pliki <code>.scss</code>, z których będą generowane pliki <code>.css</code> w <code>dist/css</code>.</p>
<p>Pamiętaj, aby nie edytować ani dodawać żadnych plików do <code>dist</code> – ten katalog będzie regularnie czyszczony z całej zawartości. Wszystkie pliki znajdujące się w nim będą kasowane, a na ich miejsce będą tworzone nowe. Będzie to rolą naszego task runnera.</p>
<p>Co więcej, katalog <code>dist</code> nie będzie dodawany do repozytorium. Będzie służył nam tylko do lokalnego podglądu strony. W następnym module dowiemy się też w jaki sposób publikować stronę w internecie – tam również będzie dostępna ta sama zawartość, którą znajdziemy w <code>dist</code>.</p>
<h5>Plik <code>src/index.html</code></h5>
<p>W tym pliku znajdziesz podstawową strukturę HTML. Najważniejsze elementy w tym pliku, to:</p>
<ul>
<li>odwołania do plików <code>.css</code> i <code>.js</code>,</li>
<li>dwa puste divy (<code>#menu</code> i <code>#cart</code>), które mają pozostać puste,</li>
<li>szablon Handlebars produktu, który omówimy sobie nieco później.</li>
</ul>
<p>Plik jest gotowy do pracy i na razie nie będziemy w nim niczego zmieniać.</p>
<h5>Katalog <code>src/sass</code></h5>
<p>W ramach tego projektu mało będziemy zajmować się stylami strony – chyba że będziesz mieć ochotę przerobić cały jej wygląd. Warto jednak zatrzymać się na chwilę przy tym katalogu i przestudiować jego zawartość.</p>
<p>Głównym plikiem jest jak zwykle <code>style.scss</code>. Tym razem jednak znajdziesz w nim tylko deklaracje importujące zawartość innych plików. Zwróć uwagę, że nazwy pozostałych plików zaczynają się od podkreślenia <code>_</code> – dzięki temu Sass będzie wiedział, aby nie generować z nich plików <code>.css</code>.</p>
<p>Zamiast tego, ich zawartość będzie wykorzystana tam, gdzie zostały zaimportowane – czyli w <code>style.css</code> zamiast deklaracji <code>@import</code> znajdziesz zawartość poszczególnych plików <code>_*.scss</code>.</p>
<p>Takie podejście jest bardzo częste w projektach. Im większy projekt, tym bardziej da się odczuć korzyści płynące z podziału stylów na mniejsze pliki. Nie musisz już przewijać setek linii, aby znaleźć deklaracje zmiennych – doskonale wiesz, że znajdują się w pliku <code>_settings.scss</code> i możesz zawsze do nich zajrzeć. Dzięki temu łatwiej jest zachować porządek w stylach i myśleć o nich jako o komponentach.</p>
<p>Poświęć 10-15 minut na przeglądanie tych plików. Warto poznać zarówno strukturę plików <code>.scss</code>, jak i stylów w tych plikach. Jest to świetny przykład dobrej organizacji kodu i podejścia komponentowego, które jest podstawą rozwijalności projektu.</p>
<h3>Pliki JS</h3>
<p>Przyjmy się teraz samym plikom JS, z którymi za chwilę zaczniemy pracować.</p>
<h5>Plik <code>src/js/functions.js</code></h5>
<p>W tym pliku umieściliśmy kilka funkcji, które będą nam potrzebne w trakcie realizacji projektu. Wszystkie znajdują się w obiekcie <code>utils</code> – to skrót od słowa <em>utilities</em>, czyli <em>narzędzia</em>.</p>
<p>Komentarze na początku pliku mogą przykuć Twoją uwagę – są to deklaracje dla ESLinta, aby nie wykrywał błędów:</p>
<ul>
<li>w przypadku <code>Handlebars</code>, ustawiamy tę zmienną jako globalną – inaczej ESLint twierdziłby, że używamy zmiennej, która nie została zadeklarowana; i faktycznie, w tym pliku nie jest zadeklarowana, pochodzi z innego pliku;</li>
<li>w przypadku deklaracji stałej <code>utils</code>, ESLint informowałby o tym, że deklarujemy stałą, która nie została nigdzie wykorzystana; z tego względu powiedzieliśmy mu, aby w tej linii zignorował błąd tego typu.</li>
</ul>
<p>Poszczególne metody <code>utils</code> będziemy omawiać przy ich wykorzystaniu.</p>
<h5>Plik <code>src/js/data.js</code></h5>
<p>W tym pliku znajdziesz obiekt <code>dataSource</code>, również z komentarzem dla ESLinta. W tym obiekcie znajduje się cała konfiguracja produktów, które będzie oferować nasza pizzeria. Są to dane, które wkrótce wykorzystamy już w naszej aplikacji. Np. w celu wygenerowania zawartości menu produktów.</p>
<p>Omówimy to sobie szczegółowo nieco później – na razie tylko zapoznajemy się ze strukturą plików.</p>
<h5>Plik <code>src/js/script.js</code></h5>
<p>To plik, w którym będziemy robić najwięcej zmian, i to już za chwilę! Zapoznajmy się najpierw z początkową zawartością tego pliku.</p>
<p>Na samym początku możesz zauważyć deklaracje globalnych zmiennych dla ESLinta, oraz komentarz wyłączający wykrywanie błędu w tej linii. Jak wspomnieliśmy wcześniej, są one potrzebne, aby ESLint nie zgłaszał błędów dotyczących np. użycia <code>Handlebars</code> czy <code>utils</code>, zdefiniowanych w innych plikach.</p>
<p>Następnym elementem w tym pliku jest otwarcie nawiasu klamrowego. Jak zapewne pamiętasz, zakresem zmiennych <code>let</code> i stałych <code>const</code> jest blok kodu zamknięty w te nawiasy. Dzięki temu zmienne i stałe z naszego skryptu nie będą dostępne w innych plikach. Upewniamy się w ten sposób, że żaden inny skrypt nie nadpisze naszych zmiennych i stałych.</p>
<p>Zauważ, że nie mogliśmy zastosować tego samego podejścia w plikach <code>functions.js</code> i <code>data.js</code>, ponieważ obiekty tworzone w tych plikach będą nam potrzebne w <code>script.js</code>.</p>
<p>Wróćmy jednak do pliku <code>script.js</code> – dalej znajdziesz w nim:</p>
<ul>
<li><code>select</code> – obiekt zawierający selektory, które będą nam potrzebne w tym module,</li>
<li><code>classNames</code> – nazwy klas, którymi nasz skrypt będzie manipulował (nadawał i usuwał),</li>
<li><code>settings</code> – ustawienia naszego skryptu, wszystkie wartości, które wygodniej będzie zmieniać w jednym miejscu,</li>
<li><code>templates</code> – szablony Handlebars, do których wykorzystujemy selektory z obiektu <code>select</code>,</li>
<li><code>app</code> – obiekt, który pomoże nam w organizacji kodu naszej aplikacji,</li>
<li><code>app.init();</code> – wywołanie metody, która będzie uruchamiać wszystkie pozostałe komponenty strony.</li>
</ul>
<p>Dzięki takiej organizacji pliku będzie nam łatwiej zachować porządek. Z założenia, jedynym wywołaniem (uruchomieniem) funkcji poza <code>app</code> ma być <code>app.init()</code>. To ta metoda uruchomi kolejne, które uruchomią kolejne, etc.</p>
<p>To podejście również spotkasz często w innych projektach. Dzięki temu, że uruchamiamy jedną funkcję, łatwo jest sprawdzić, co ona robi i w jakiej kolejności.</p>
<p>Metoda <code>app.init</code> musi być możliwie krótka, więc będzie tylko uruchamiać inne metody z <code>app</code>. W ten sposób stanie się swoistą "listą treści" naszego skryptu. Na razie zawiera kilka linii z <code>console.log</code>, które pomogą nam wygodniej przeglądać dane zapisane w obiektach.</p>
<p>Będziemy się też starać, aby pozostałe metody w <code>app</code> były również możliwie krótkie. Będą one mocno polegały na klasach, które stworzymy w ramach podejścia obiektowego. Tak, że obiekt <code>app</code> będziemy mogli traktować jako swego rodzaju inicjator. Jego rolą będzie tworzenie nowych instancji i ich wykorzystywanie, ale konkretna logika aplikacji będzie ukryta już właśnie w klasach. Bardzo pomoże to nam w uporządkowaniu kodu. Za chwilę zobaczysz to w praktyce.</p>
<h3>Task runner i lintery</h3>
<p>Jak wspomnieliśmy mamy w tym projekcie nowy task runner. Jest on rozwinięciem tego, z którego korzystaliśmy wcześniej. Uwzględnia jednak strukturę z katalogami <code>src</code> i <code>dist</code>. Zawiera także konfigurację dla ESLinta i StyleLinta.</p>
<p>Uruchamiamy projekt jak zwykle – jednorazowo <code>npm install</code> zainstaluje wszystkie niezbędne pakiety, następnie <code>npm run watch</code> będzie uruchamiał nasz task runner i podgląd projektu.</p>
<p>Pamiętaj, aby codziennie uruchamiać testy, aby nie gromadzić błędów formatowania w plikach! Możesz to zrobić wyłączając task runner i ponownie uruchomiając <code>npm run watch</code>. Alternatywnie, możesz w osobnym oknie terminala uruchomić <code>npm run test</code>, aby wyświetlić wynik testów, nawet podczas działania task runnera.</p>
<p>No, ale wystarczy już przeglądania plików! Uruchom task runnera i zaczynamy!</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1966" class="card submodule completed" data-bootcamp-user-submodule-id="604289" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.4. <span>Tworzymy pierwszą klasę</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Wiemy już trochę o podejściu obiektowym – czas zacząć je stosować!</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/menu.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/menu-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/menu.png 2x" class="img-inline img-left">
<p>Naszą pierwszą klasą (schematem) będzie <code>Product</code>. Każdy produkt w menu naszej pizzerii będzie instancją tej klasy. Będzie ona odpowiedzialna za:</p>
<ul>
<li>dodanie produktu do menu na stronie, wykorzystując szablon Handlebars,</li>
<li>uruchomienie akordeonu, czyli funkcjonalności pokazywanie i ukrywanie opcji produktu,</li>
<li>obliczanie ceny produktu z wybranymi opcjami.</li>
</ul>
<p>Nie przejmuj się, jeśli nie masz pomysłu, jak się do tego zabrać – zaczniemy od podstaw i krok po kroku stworzymy te funkcjonalności.</p>
<h3>Tworzenie klasy</h3>
<p>Zaczynamy od stworzenia pustej klasy <code>Product</code>, która zawiera tylko konstruktor wyświetlający wiadomość w konsoli.</p>
<p>Pamiętaj, żeby mieć pod ręką otwarte informacje o <a href="https://poradnik-js.kodilla.com/oop-classes" target="_blank">składni klasy i instancji</a>. Pomogą Ci lepiej zrozumieć, co robi nasz kod JS.</p>
<p>W pliku <code>src/js/script.js</code>, przed deklaracją <code>app</code> wstaw ten fragment kodu:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-02.png" style="width: auto;">
<p>To na razie cała deklaracja klasy, która zawiera prosty konstruktor. Pewnie już wiesz, czym jest konstruktor (z naszego <a href="https://poradnik-js.kodilla.com/oop-classes" target="_blank">poradnika</a>), ale przypomnimy – to specjalna metoda, która uruchomi się przy tworzeniu każdej instancji.</p>
<h3>Tworzenie pierwszej instancji</h3>
<p>Klasa to tylko schemat. Aby sprawdzić, jak działa, musimy stworzyć pierwszą instancję. Od razu przygotujemy sobie również metodę obiektu <code>app</code>, która będzie tworzyć instancje klasy <code>Product</code>.</p>
<p>Dodaj deklarację metody <code>app.initMenu</code> przed <code>app.init</code>, i umieść w niej ten kod:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-03.png" style="width: auto;">
<p>Następnie na końcu <code>app.init</code> dodaj linię:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-04.png" style="width: auto;">
<p>Teraz Twój obiekt <code>app</code> powinien wyglądać tak:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-05.png" style="width: auto;">
<p>Zauważ, że oczekujemy iż <code>thisApp</code> (a więc <code>this</code>) ma wskazywać w metodzie <code>init</code> na cały obiekt <code>app</code>. Czy słusznie? Jak najbardziej! Metoda <code>init</code> była uruchamiana w taki sposób – <code>app.init</code>, a więc na obiekcie <code>app</code>. Dlatego też zgodnie z zasadą "Implicit binding rule" wskaże właśnie na <code>app</code>.</p>
<p>Sprawdź komunikaty, które teraz wyświetlają się w konsoli. Powinny pokazać się dwie nowe linie:</p>
<pre><code class="language-plaintext">new Product: Product {}
testProduct: Product {}
</code></pre>
<p>Pierwsza z nich została wyświetlona przez konstruktor klasy, a druga w metodzie <code>app.initMenu</code>. Obie informują nas, że wyświetlają obiekt klasy <code>Product</code>, który nie ma żadnych właściwości.</p>
<p>Wygląda na to, że wszystko działa poprawnie i stworzyliśmy naszą pierwszą instancję klasy! Na razie nie robi ona zbyt wiele, ale zaraz to się zmieni!</p>
<h3>Instancja dla każdego produktu</h3>
<p>Jak zapewne pamiętasz, definicje naszych produktów zapisaliśmy w obiekcie <code>dataSource</code> w pliku <code>data.js</code>. Możesz otworzyć ten plik, żeby przypomnieć sobie jego zawartość, ale nie musisz w nim niczego zmieniać.</p>
<p>Chcemy, by nasza aplikacja korzystała z tego źródła danych, ale w przyszłości dane będą wczytywane z serwera. Stwórzmy więc od razu metodę <code>app.initData</code>. Na razie bardzo prostą, będzie tylko przygotowywać dostęp do danych z obiektu <code>dataSource</code>. W przyszłości jednak mocno ją zmodyfikujemy, tak aby dane były pobierane z serwera.</p>
<p>Nad deklaracją metody <code>app.init</code> wstaw ten kod:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-06.png" style="width: auto;">
<p>Tak jak mówiliśmy, na razie przygotowujemy tylko "wygodniejszy" dostęp do danych, przypisując referencję do nich pod właściwość <code>data</code>. Dlaczego referencję? Bo jak już zapewne pamiętasz, kiedy JS widzi próbę przypisania do zmiennej czy właściwości złożonego obiektu, to zawsze domyślnie daje nam właśnie tylko adres (referencję) do oryginalnego obiektu. Tym samym <code>thisApp.data</code> to tylko referencja do tych samych danych, do których kieruje też stała <code>dataSource</code>.</p>
<p>A w <code>app.init</code>, tuż nad <code>thisApp.initMenu();</code> dodaj:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-07.png" style="width: auto;">
<p>Teraz przenosimy się do metody <code>app.initMenu</code> – zaczniemy od sprawdzenia, czy dane są gotowe do użycia. Na początku tej metody dodaj:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-08.png" style="width: auto;">
<p>Sprawdź, czy w konsoli wyświetla się <code>thisApp.data</code> z zawartością. Jeśli nie, sprawdź poprzednie kroki – przede wszystkim czy w <code>app.init</code> metoda <code>thisApp.initData();</code> jest uruchamiana przed <code>thisApp.initMenu();</code>.</p>
<p>Kiedy sprawdzisz w konsoli zawartość <code>thisApp.data</code>, zobaczysz, że znajduje się w nim obiekt <code>products</code>, który zawiera poszczególne produkty. Stworzymy więc pętlę <code>for...in</code>, iterującą po obiekcie <code>thisApp.data.products</code>.</p>
<p>W tej pętli będziemy tworzyć nową instancję dla każdego produktu. Nie będziemy tych instancji zapisywać do żadnej stałej czy zmiennej, ponieważ nie mamy takiej potrzeby – na razie w <code>app</code> nie potrzebujemy mieć do nich dostępu.</p>
<p>Zastąp zawartość metody <code>app.initMenu</code> następującym kodem:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-09.png" style="width: auto;">
<p>Teraz w konsoli zobaczysz cztery linie:</p>
<pre><code class="language-plaintext">new Product: Product {}
new Product: Product {}
new Product: Product {}
new Product: Product {}
</code></pre>
<p>To nasze cztery produkty! Te linie są wyświetlane przez konstruktor przy tworzeniu każdej instancji.</p>
<p>Zauważ, że tworząc nową instancję, przekazujemy do konstruktora aż dwa argumenty. Jako pierwszy chcemy przekazać <code>productData</code>. Czym jest ona w naszej sytuacji? Pętla <code>for...in</code> przechodzi po właściwościach obiektu i <strong>pod zmienną przechowuje zawsze tylko i wyłącznie nazwę aktualnie "obsługiwanej" właściwości</strong>.</p>
<p>Np.</p>
<pre><code class="language-js">const obj = {
  firstName: 'John',
  lastName: 'Doe'
}

for(let param in obj) {
  console.log(param);
}
</code></pre>
<p>...pokaże nam w konsoli tylko nazwy właściwości, a więc <code>firstName</code> i <code>lastName</code>. Pętla nie przejmie się ich wartościami. Możemy się jednak do nich dostać za pomocą składni <code>obiekt[nazwa-parametru]</code>. Jeśli jej nie pamiętasz, to zerknij szybko do <a href="https://poradnik-js.kodilla.com/objects" target="_blank">dokumentacji</a>.</p>
<pre><code class="language-js">const obj = {
  firstName: 'John',
  lastName: 'Doe'
}

for(let param in obj) {
  console.log(param, obj[param]);
}
</code></pre>
<p>Dokładnie ten sam zamysł wykorzystujemy w naszej pętli for, aby przekazać do konstruktora klasy nie tylko nazwę właściwości (a więc nazwę produktu), ale i też obiekt, który się pod nią kryje.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-09.png" style="width: auto;">
<p>Czyli, koniec końców przekazujemy np. następujące argumenty. Jako pierwszy nazwę właściwości, a więc <code>cake</code>, a jako drugi obiekt:</p>
<pre><code class="language-js">{
  class: 'small',
  name: 'Zio Stefano\'s Doughnut',
  price: 9,
  description: 'Treat yourself with this soft, freshly baked cookie. The recipe has been handed down from generation to generation in our family and it has won us several first place prizes in local competitions.',
  images: [
    '&lt;img class=&quot;active&quot; src=&quot;images/doughnut.svg&quot;&gt;',
  ],
},
</code></pre>
<p>Analogicznie tworzymy też oczywiście w tej pętli instancje pozostałych produktów. A więc innym razem przekazujemy <code>pizza</code> jako pierwszy argument, a jako drugi zawartość obiektu, który pod tą właściwością się kryje. Jeszcze innym razem <code>breakfast</code> itd.</p>
<h3>Zapisywanie argumentów konstruktora</h3>
<p>Nasze instancje na razie są jeszcze puste. Co prawda, w pętli przekazaliśmy argumenty konstruktorowi, ale ten... jeszcze na nie oczekuje. Musimy więc zmienić konstruktor w klasie <code>Product</code>, aby zaczął z nich korzystać.</p>
<p>Zaczynamy od nazwania argumentów, które otrzymuje konstruktor. W tym celu zmień linię ze słowem <code>constructor</code> na następującą:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-10.png" style="width: auto;">
<p>Jak widzisz, argumenty konstruktora deklarujemy w ten sam sposób, w jaki deklarowaliśmy argumenty funkcji – co ma sens, bo konstruktor jest po prostu funkcją.</p>
<p>Jeśli teraz zapiszesz plik i zajrzysz do konsoli, zobaczysz, że nic się jeszcze nie zmieniło. Nasze instancje nadal są pustymi obiektami. Aby to zmienić, musimy zapisać wartości naszych argumentów do właściwości instancji.</p>
<p>Jak możemy to zrobić? Wystarczy skorzystać z <code>this</code> (lub <code>thisProduct</code>, które też prowadzi do tego samego obiektu). Jak zapewne pamiętasz, <code>this</code> jest właśnie odnośnikiem do obiektu, który jest utworzony przez klasę podczas inicjacji, a więc w momencie uruchomienia instrukcji <code>new Product</code>. Zapisując właściwości do <code>thisProduct</code>, przypiszemy je więc po prostu do danej instancji.</p>
<pre><code class="language-js">      thisProduct.id = id;
      thisProduct.data = data;
</code></pre>
<p>Teraz zmieniło się coś w konsoli! Każda z instancji ma swoje <code>id</code> oraz obiekt <code>data</code>, zawierający wszystkie właściwości tego produktu! Dopiero teraz możesz się przekonać, że każdy z tych produktów jest inny.</p>
<p>Zwróć uwagę, że zmianę wprowadziliśmy tylko w klasie, czyli we wzorcu, wedle którego jest tworzona każda instancja. Dzięki temu każdy produkt zachowuje się tak samo, ma tyle samo właściwości, a za chwilę będzie miał też wspólne metody!</p>
<h3>Renderowanie produktu</h3>
<p>Stworzymy teraz metodę <code>renderInMenu</code>, która będzie <strong>renderować</strong> – czyli tworzyć – nasze produkty na stronie.</p>
<p>W deklaracji klasy <code>Product</code>, pod konstruktorem, dodaj nową metodę:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-11.png" style="width: auto;">
<p>Natomiast w konstruktorze, nad <code>console.log</code>, dodaj linię:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-12.png" style="width: auto;">
<p>Zadba ona o to, żeby nasz konstruktor uruchomił tę funkcję od razu po utworzeniu instancji.</p>
<p>Teraz musimy przygotować algorytm metody <code>renderInMenu</code>. Ta metoda ma za zadanie:</p>
<ul>
<li>wygenerować kod HTML pojedynczego produktu,</li>
<li>stworzyć element DOM na podstawie tego kodu produktu,</li>
<li>znaleźć na stronie kontener menu,</li>
<li>wstawić stworzony element DOM do znalezionego kontenera menu.</li>
</ul>
<p>Po zapisaniu tego algorytmu nasza klasa <code>Product</code> powinna wyglądać tak:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-13.png" style="width: auto;">
<h4>Krok 1 – generowanie HTML</h4>
<p>Za chwilę omówimy sobie nasz szablon pojedynczego produktu dokładniej, ale najpierw chcemy go użyć. Będzie nam łatwiej zrozumieć jego działanie, patrząc na wygenerowane elementy na stronie.</p>
<p>Spójrz na szczyt pliku, na obiekt <code>select</code>. Znajdziesz w nim obiekt <code>templateOf</code>, a w nim – właściwość <code>menuProduct</code>. Zawiera ona selektor do naszego szablonu produktu.</p>
<p>Wykorzystujemy ten selektor nieco niżej, w obiekcie <code>templates</code>, w którym metoda <code>menuProduct</code> jest tworzona za pomocą biblioteki <code>Handlebars</code>.</p>
<p>Dzięki temu wszystko, co potrzebujemy zrobić w metodzie <code>renderInMenu</code>, to wywołać metodę <code>templates.menuProduct</code> i przekazać jej dane produktu:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-14.png" style="width: auto;">
<p>Możesz sprawdzić za pomocą <code>console.log</code>, czy jest generowany kod HTML, ale jego czytanie byłoby bardzo żmudne. Poczekamy z tym do końca pracy nad metodą <code>renderInMenu</code>.</p>
<h4>Krok 2 – tworzenie elementu DOM</h4>
<p>Kod HTML to jednak zwykły tekst, a my potrzebujemy elementu DOM, który będziemy w stanie naprawdę "wcisnąć" gdzieś na naszą stronę. Najlepiej zapamiętaj to tak: HTML to zwykły string, a element DOM to obiekt wygenerowany przez przeglądarkę na podstawie kodu HTML. Obiekt, który ma właściwości (np. <code>innerHTML</code> czy metody (np. <code>getAttribute</code>).</p>
<p>JS nie ma wbudowanej metody, która służy do tego celu – dlatego skorzystamy z jednej z funkcji zawartych w obiekcie <code>utils</code>. Przygotowaliśmy go dla Ciebie, aby usprawnić nam pracę nad tym projektem. W tym wypadku użyjemy metody <code>utils.createDOMFromHTML</code>. Przyjmie ona jako argument kod HTML (tekst) i zwróci element DOM na nim oparty.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-15.png" style="width: auto;">
<p>Zauważ, że stworzony element DOM zapisujemy od razu jako właściwość naszej instancji. To dobra praktyka. Dzięki temu będziemy mieli do niego dostęp również w innych metodach instancji. Nie tylko w <code>renderInMenu</code>.</p>
<h4>Krok 3 - znajdujemy kontener menu</h4>
<p>Ten krok nie powinien już stanowić dla Ciebie problemu – użyjemy metody <code>querySelector</code> do znalezienia kontenera produktów, którego selektor mamy zapisany w <code>select.containerOf.menu</code>. Znaleziony element zapiszemy w stałej <code>menuContainer</code>.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-16.png" style="width: auto;">
<h4>Krok 4 – dodajemy stworzony element na stronę</h4>
<p>Wreszcie, ostatni krok – za pomocą metody <code>appendChild</code> dodajemy stworzony element do menu!</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-17.png" style="width: auto;">
<h5>Produkty już się renderują!</h5>
<p>Teraz możemy się w końcu przyjrzeć, jak wyglądają produkty oferowane przez naszą pizzerię. Jak widzisz, każdy produkt ma:</p>
<ul>
<li>nagłówek z tytułem i ceną,</li>
<li>opis,</li>
<li>opcje (tylko w niektórych produktach),</li>
<li>wybór ilości produktów,</li>
<li>ponownie wyświetloną cenę,</li>
<li>oraz guzik dodania do koszyka.</li>
</ul>
<p>Oczywiście, na razie tylko wyświetlamy produkty – zmiana opcji czy ilości jeszcze nie ma stworzonej funkcjonalności.</p>
<p>Może Cię zdziwić ponowne wyświetlanie ceny – cena w nagłówku jest ceną "bazową", tzn. przy zaznaczeniu domyślnych opcji i wybraniu jednej sztuki produktu. Cena przy guziku dodania do koszyka będzie natomiast ceną z uwzględnieniem opcji oraz ilości. Tę funkcjonalność wspólnie napiszemy nieco później.</p>
<h3>Analiza danych źródłowych i szablonu</h3>
<p>Zanim przejdziemy dalej, chcemy wytłumaczyć, jak to się stało, że za sprawą paru linijek kodu wygenerowały się produkty na stronie.</p>
<p>Otwórz pliki <code>src/index.html</code> oraz <code>src/js/data.js</code>. Najlepiej będzie, jeśli oba pliki będą widoczne jednocześnie.</p>
<p>Cała magia tego rozwiązania polega na tym, że szablon (w <code>index.html</code>) jest dostosowany do danych (z <code>data.js</code>). Kod JS naszej klasy <code>Product</code>, którą przed chwilą napisaliśmy, w ogóle nie musi (na razie) wiedzieć jakie informacje znajdują się w obiekcie z danymi produktu – po prostu przekazuje je do szablonu.</p>
<h5>Podstawowe właściwości</h5>
<p>Nasz szablon generuje pojedynczy produkt, więc parametry takie jak <code>name</code>, <code>price</code> czy <code>description</code> brane są bezpośrednio z właściwości pojedynczego produktu w <code>dataSource.products</code>.</p>
<h5>Wstawianie obrazków</h5>
<p>Teraz przejdźmy na chwilę na sam koniec szablonu. Znajdziemy tam pętlę. Spójrz na źródło danych – znajdź w nim tablicę <code>images</code> z kodem HTML obrazków. Zdecydowaliśmy się na takie rozwiązanie, aby dało się wstawić kilka obrazków dla każdego produktu.</p>
<p>Jeśli dziwi Cię użycie <code>{{{ this }}}</code>, już tłumaczymy. Słowo <code>this</code> odnosi się tutaj do pojedynczego elementu, po którym iteruje pętla <code>{{#each images}}</code>. W to miejsce zostanie wstawiony pojedynczy element tablicy <code>images</code>.</p>
<p>A dlaczego użyliśmy potrójnych nawiasów klamrowych? Handlebars traktuje właściwości wstawiane za pomocą podwójnych nawiasów klamrowych jako tekst. Możesz zmienić te nawiasy na podwójne – zobaczysz wtedy, że zamiast obrazków wyświetlił się kod HTML. Gdybyśmy chcieli wyświetlać np. fragment kodu w kursie programowania, ten tryb tekstu byłby całkiem przydatny.</p>
<p>W naszym przypadku jednak chcemy, aby kod HTML był traktowany jak kod HTML, a nie jak tekst do wyświetlenia. Użycie potrójnych nawiasów klamrowych umożliwia nam właśnie tę zmianę zachowania szablonu.</p>
<h5>Opcje produktu</h5>
<p>Teraz przechodzimy do najciekawszej części – opcji produktu. Opcje podzieliliśmy na "kategorie", które nazwaliśmy <code>params</code> (skrót od <em>parameters</em>, czyli właściwości). W naszej strukturze danych, np. dla pizzy, parametrem będzie rodzaj ciasta, rodzaj sosu, czy zestaw składników na pizzy. Zobaczmy najpierw, jak wygląda struktura danych.</p>
<p>Spójrz np. właśnie na <code>params</code> w pizzy (plik <code>data.js</code>):</p>
<pre><code class="language-js">    params: {
      sauce: {
        label: 'Sauce',
        type: 'radios',
        options: {
          tomato: {label: 'Tomato', price: 0, default: true},
          cream: {label: 'Sour cream', price: 2},
        },
      },
      toppings: {
        label: 'Toppings',
        type: 'checkboxes',
        options: {
          olives: {label: 'Olives', price: 2, default: true},
          redPeppers: {label: 'Red peppers', price: 2, default: true},
          greenPeppers: {label: 'Green peppers', price: 2, default: true},
          mushrooms: {label: 'Mushrooms', price: 2, default: true},
          basil: {label: 'Fresh basil', price: 2, default: true},
          salami: {label: 'Salami', price: 3},
        },
      },
      crust: {
        label: 'pizza crust',
        type: 'select',
        options: {
          standard: {label: 'standard', price: 0, default: true},
          thin: {label: 'thin', price: 2},
          thick: {label: 'thick', price: 2},
          cheese: {label: 'cheese in edges', price: 5},
          wholewheat: {label: 'wholewheat', price: 3},
          gluten: {label: 'with extra gluten', price: 0},
        },
      },
    },
</code></pre>
<p>Każdy parametr ma:</p>
<ul>
<li><code>label</code>, czyli swoją nazwę wyświetlaną na stronie,</li>
<li><code>type</code>, czyli typ parametru, który decyduje o tym, czy wyświetli się lista checkboksów (można wybrać wiele opcji), lista radio-buttonów czy select,</li>
<li><code>options</code>, czyli zestaw możliwych opcji dla danego parametru.</li>
</ul>
<p>Każda z opcji ma:</p>
<ul>
<li><code>label</code>, czyli swoją nazwę wyświetlaną na stronie,</li>
<li><code>price</code>, czyli cenę za ten dodatek,</li>
<li><code>default</code>, czyli opcjonalne ustawienie, które mówi, że ta opcja ma być domyślnie wybrana i została już wliczona w cenę tego produktu.</li>
</ul>
<p>W szablonie tworzymy pętlę, która będzie iterować po wszystkich elementach obiektu <code>params</code>. Znajdź tę linię kodu:</p>
<pre><code class="language-html">{{#each params as |param paramId| }}
</code></pre>
<p>Ta pętla wygląda nieco inaczej niż poznane wcześniej pętle, ponieważ zdecydowaliśmy się na nazwanie kluczy i wartości w każdej iteracji. Będą to: klucz <code>paramId</code> oraz wartość <code>param</code>.</p>
<p>Ten zapis może wydawać się dziwny, ale sama zasada działania jest prosta – to po prostu pętla. Gdybyśmy pisali ją w JS-ie, wyglądałaby tak:</p>
<pre><code class="language-js">for(let paramId in params){
  const param = params[paramId];
  // ...
}
</code></pre>
<p>Potrzebowaliśmy nazwać klucz parametru, ponieważ będziemy go wykorzystywać wewnątrz kolejnych pętli.</p>
<p>Idąc dalej, używamy np. <code>{{#ifEquals type &quot;checkboxes&quot;}}</code> do rozpoznania, czy dany <code>param</code> ma <code>type</code> równe <code>checkbox</code>. Handlebars nie ma wbudowanej metody <code>ifEquals</code> – ma wbudowane tylko <code>if</code>, które potrafi sprawdzać wyłącznie wartości prawdziwe i fałszywe (a konkretniej – <a href="https://poradnik-js.kodilla.com/conditions" target="_blank">truth i false</a>).</p>
<p>Handlebars umożliwia jednak dodawanie własnych bloków. W pliku <code>src/js/functions.js</code> zawarliśmy definicję bloku <code>ifEquals</code>, aby umożliwić nam wybór pomiędzy checkboksami, radio-buttonami, a selectem. Nie musisz rozumieć działania kodu w <code>functions.js</code> – zastosowaliśmy po prostu jedno z rozwiązań dostępnych w internecie po wyszukaniu frazy "Handlebars if equals". Podobnie, jeśli będziesz mieć potrzebę rozbudowania jakiegoś pluginu, możesz szukać w internecie rozwiązań podpowiedzianych przez innych. ;)</p>
<p>Wreszcie, w każdym z przypadków (checkboxy, radio-buttony i select) wyświetlamy <code>label</code> parametru, a następnie tworzymy pętlę iterującą po wszystkich opcjach tego parametru. Dla każdej z nich wstawiamy odpowiedni kawałek kodu HTML, zawierający:</p>
<ul>
<li><code>label</code>, czyli nazwę tej opcji (nie parametru!),</li>
<li><code>price</code>, czyli cenę tej opcji,</li>
<li><code>paramId</code>, czyli klucz parametru,</li>
<li><code>@key</code>, czyli klucz opcji,</li>
<li>oraz warunek sprawdzający, czy ta opcja jest domyślna.</li>
</ul>
<p>Niewielkim wyjątkiem jest select, w którym <code>paramId</code> używamy na <code>&lt;select&gt;</code>, a nie w pętli iterującej po opcjach.</p>
<p>Ta cała pętla dla parametrów, zawierająca bloki <code>ifEqual</code>, z których każdy ma swoją pętlę, w której używamy kluczy parametrów i kluczy opcji – to może przyprawiać o zawrót głowy. Nie przejmuj się, to faktycznie jest trochę skomplikowane.</p>
<p>Dlatego poświęć chwilę na lepsze zrozumienie tego kodu. Wybierz sobie jedną opcję (np. jeden składnik na pizzę) i znajdź go w strukturze danych. Zobacz, jakie ma właściwości, jaki ma klucz, i w jakim obiekcie (parametrze) się znajduje.</p>
<p>Następnie na stronie zbadaj element, który wyświetla ten składnik. Zobacz, gdzie są wykorzystane klucze parametru i opcji, a gdzie nazwa i cena. Wtedy spójrz jeszcze raz na szablon w <code>index.html</code> i znajdź fragment szablonu odpowiedzialny za wygenerowanie tej opcji na stronie.</p>
<p>Te wszystkie aspekty łączą się ze sobą w jedną całość! W źródle danych produkt ma parametry, które mają opcje. Na stronie mamy wyświetlone "kategorie opcji", i w nich opcje. W szablonie mamy pętlę dla parametrów, a w niej pętle dla opcji.</p>
<p>Zrób to samo ćwiczenie jeszcze parę razy dla różnych opcji w różnych parametrach różnych produktów. Z każdym kolejnym podejściem będzie nieco łatwiej zrozumieć, że dane źródłowe, szablon i elementy na stronie są tylko różnymi aspektami tej samej struktury danych.</p>
<p>Nie martw się, jeśli wydaje Ci się to skomplikowane. Faktycznie takie jest, i dlatego omawiamy kod, który dla Ciebie przygotowaliśmy, zamiast tworzyć go wspólnie. Nie myśl sobie jednak, że napisaliśmy tę strukturę danych ot tak. Robiliśmy to tak samo, jak piszemy ten skrypt – krok po kroku, zaczynając od prostej struktury danych i prostego szablonu, i rozwijając je na przemian. Dodawaliśmy kolejne obiekty w danych źródłowych i dostosowywaliśmy szablon do tych zmian. I tak w kółko...</p>
<p>No, ale dość o tym. Wystarczy, że rozumiesz ogólny zarys działania naszego skryptu – klasa <code>Product</code> za pomocą metody <code>renderInMenu</code> bierze dane źródłowe produktu, "wrzuca je" do szablonu, i tak powstaje kod HTML pojedynczego produktu. Ponieważ metoda <code>renderInMenu</code> jest uruchamiana w konstruktorze klasy, to przy tworzeniu każdej nowej instancji dla danego produktu, od razu renderuje się on na stronie.</p>
<p>Jak widzisz, stworzenie naszej pierwszej klasy było mniej skomplikowane, niż wytłumaczenie struktury danych źródłowych i szablonu. Jednak w naszych plikach projektu nie kryje się już nic do wytłumaczenia – teraz możemy spokojnie przejść do rozbudowy klasy <code>Product</code>, aby dodawać kolejne funkcjonalności naszym produktom w menu.</p>
<h3>Podsumowanie</h3>
<p>Zanim ruszymy dalej, podsumujmy krótko, jak na tym etapie działa nasza aplikacja. JS zaczyna swoje działanie od uruchomienia metody <code>app.init</code>. Ta wywołuje dwie kolejne – <code>initData</code> i <code>initMenu</code>.</p>
<p>Pierwsza (<code>app.initData</code>) ma zadanie przygotować nam łatwy dostęp do danych. Przypisuje więc do <code>app.data</code> (właściwości całego obiektu <code>app</code>) referencję do <code>dataSource</code>, czyli po prostu danych, z których będziemy korzystać z aplikacji. Znajduje się tam m.in. obiekt <code>products</code> ze strukturą naszych produktów.</p>
<p>Druga metoda (<code>app.initMenu</code>) jest wywoływana po pierwszej, gdyż korzysta z przygotowanej wcześniej referencji do danych (<code>thisApp.data</code>). Jej zadaniem jest przejście po wszystkich obiektach produktów z <code>thisApp.data.products</code> (<code>cake</code>, <code>breakfast</code> itd.) i utworzenie dla każdego z nich instancji klasy <code>Product</code>. Przy tworzeniu każdej instancji uruchamia się funkcja konstruktora, która uruchamia dla danego obiektu metodę <code>renderInMenu</code>. Ta tworzy element DOM wygenerowany na podstawie szablonu HTML reprezentujący właśnie dany produkt i "dokleja" go do strony. Czyli najprościej mówiąc, metoda <code>app.initMenu</code> przejdzie po każdym produkcie z osobna i stworzy dla niego instancję <code>Product</code>, czego wynikiem będzie również utworzenie na stronie reprezentacji HTML każdego z produktów w <code>thisApp.data.products</code>.</p>
<p>Czy na tym etapie wszystko jest dla Ciebie jasne? Jeśli nie, to zatrzymaj się na moment i przeanalizuj swój kod jeszcze raz.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1967" class="card submodule completed" data-bootcamp-user-submodule-id="604290" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.5. <span>Uruchamiamy akordeon</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Na stronie naszej pizzerii już pojawiły się produkty, ale przez te wszystkie opcje produktów trochę ciężko jest się zorientować w menu. Znacznie czytelniej byłoby, gdyby domyślnie na stronie widoczne były tylko nazwy produktów, może opisy i ew. ceny. W końcu dokładnie informacje mogłyby się pojawiać dopiero po kliknięciu na produkt. Przyznaj, że zapewniłoby to znacznie lepszy UX (User Experience). Dlatego domyślnie ukryjemy opcje – zostawimy tylko nagłówki i opisy, a opcje będą widoczne po kliknięciu!</p>
<h3>Do czego dążymy</h3>
<p>Efekt, który chcemy osiągnąć powinien być następujący:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-9.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-9.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Domyślnie wszystkie produkty powinny być "zwinięte". Kliknięcie na nagłówek produktu powinno "rozwinąć" produkt, jeśli jest aktualnie "zwinięty" oraz "zwinąć" jeśli jest aktualnie "rozwinięty". Do tego, jeśli podczas próby rozwinięcia jakiegoś produktu, jest aktywny również inny (np. był rozwinięty wcześniej), to trzeba go "zwinąć". Taki mechanizm nazywa się często akordeonem.</p>
<h3>Zmiana w szablonie</h3>
<p>Domyślnie wszystkie produkty powinny być "zwinięte". W stylach jest nawet odpowiednia reguła, która zapewnia, że opcje są chowane. Dlaczego więc u nas, ona nie działa? Dlatego, że na razie ten styl nadpisujemy.</p>
<p>W szablonie nadano domyślnie produktom klasę <code>active</code>, która nadpisuje wspomniany wcześniej styl i zapewnia części z opcjami widoczność. Skąd taki pomysł? No cóż, masz nas. Przygotowaliśmy tę klasę  właśnie z myślą o dodaniu do strony mechanizmu akordeonu.</p>
<p>Obecność takiej klasy to dla nas bardzo dobra wiadomość. Wystarczy bowiem, że usuniemy klasę <code>active</code> z szablonu produktów, a elementy zaczną być "domyślnie" zwinięte. Następnie będziemy musieli dopisać tylko funkcję, która po kliknięciu na nagłówek produktu, taką klasę doda (aby produkt rozwinąć) albo zabierze (aby produkt rozwinąć) i... gotowe! Tak naprawdę więc metoda, którą za chwilę napiszemy, będzie jedynie nadawać i odbierać klasę <code>active</code> – a konkretniej, klasę zdefiniowaną w <code>classNames.menuProduct.wrapperActive</code>. Brzmi prosto?</p>
<p>Ale po kolei. Pierwsza zmiana, którą musimy zrobić, to usunięcie tej klasy z szablonu. Zlokalizuj go w pliku <code>index.html</code>, znajdź w nim element <code>&lt;article&gt;</code> z klasami <code>product</code> i <code>active</code>, a następnie skasuj klasę <code>active</code>.</p>
<p>Teraz na stronie powinny być widoczne wszystkie produkty z opisami, ale bez opcji, wyboru ilości i guzika dodania do koszyka.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-10.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-10.png" alt="image" style="width: auto; max-width: 50%;"></a>
<h3>Przygotowanie nowej metody</h3>
<p>Pozostaje nam teraz przejście do JS-a i przygotowanie wspomnianej wcześniej metody. W klasie <code>Product</code> odnajdź więc deklaracją metody <code>renderInMenu</code> i dodaj pod nią nową – <code>initAccordion</code>. Pamiętaj, aby dodać do niej tę samą pierwszą linię, co w pozostałych metodach, czyli deklarację stałej <code>thisProduct</code>. Jak zawsze – dla czytelności. Następnie w konstruktorze dodaj wywołanie metody <code>initAccordion</code>, tuż pod wywołaniem metody <code>renderInMenu</code>. Dlaczego? Przypomnijmy. To, że inicjujemy instancję danej klasy, nie oznacza, że z automatu uruchomią się metody w niej obecne. Tak naprawdę uruchamiana jest tylko jedna funkcja – <code>constructor</code>. Jeśli więc chcemy, żeby jakaś metoda uruchamiała się przy utworzeniu instancji, to po prostu musimy ją wywoływać w konstruktorze. W naszym przypadku to o tyle ważne, że faktycznie chcielibyśmy, żeby produkty od razu, od samego początku mogły być zwijane/rozwijane.</p>
<h3>Planowanie algorytmu metody</h3>
<p>Zastanówmy się teraz, jak ma działać metoda <code>initAccordion</code>.</p>
<p>Wiemy, że zmiana widoczności opcji ma się odbywać na kliknięcie – w tym celu mamy już nawet stworzony selektor <code>select.menuProduct.clickable</code>, który ułatwi nam dojście do nagłówka produktu. To właśnie nagłówek powinien być dla nas najważniejszym elementem. To na nim uruchomimy nasłuchiwacz, który po wykryciu kliknięcia będzie uruchamiać proces "zwijania/rozwijania". Oczywiście eventem, na który będziemy oczekiwać, powinien być <code>click</code>.</p>
<p>Nasłuchiwacz oprócz informacji o tym, na jaki event ma nasłuchiwać, przyjmuje również referencje do funkcji callback, którą powinien włączyć w momencie jego wykrycia. Co ta funkcja powinna robić?</p>
<p>Najprościej mówiąc:</p>
<ul>
<li>znaleźć aktywny produkt i (o ile istnieje) zabrać mu klasę <code>active</code> (<code>classNames.menuProduct.wrapperActive</code>),</li>
<li>nadawać lub odbierać (<em>toggle</em>) klasę zdefiniowaną w <code>active</code> (<code>classNames.menuProduct.wrapperActive</code>) na elemencie bieżącego produktu (<code>thisProduct.element</code>).</li>
</ul>
<p>Do drugiego założenia potrzebna jest znajomość nowej wbudowanej metody. Oprócz <code>remove</code> i <code>add</code> obiekt <code>classList</code> na elemencie DOM ma jeszcze jedną ciekawą metodę, właśnie <code>toggle</code>. Działa ona tak, że jeśli danej klasy nie ma, to jest ona dodawana. Jeśli już jest, to jest ona zabierana. Można więc powiedzieć, że to trochę bardziej inteligentne połączenie metod <code>remove</code> i <code>add</code>.</p>
<p>Zobaczmy, jak będzie wyglądać ta funkcja z algorytmem wpisanym w komentarzach:</p>
<pre><code class="language-js">    initAccordion(){
      const thisProduct = this;

      /* find the clickable trigger (the element that should react to clicking) */
      const clickableTrigger = ???;

      /* START: add event listener to clickable trigger on event click */
      clickableTrigger.addEventListener('click', function(event) {
        /* prevent default action for event */

        /* find active product (product that has active class) */

        /* if there is active product and it's not thisProduct.element, remove class active from it */

        /* toggle active class on thisProduct.element */
      });

    }
  }
</code></pre>
<p>Jak widzisz, część kodu już dla Ciebie przygotowaliśmy. Twoją rolą będzie tylko jego dokończenie zgodnie z podpowiedziami w komentarzach.</p>
<p>Jeden komentarz może być dla Ciebie niejasny. Chodzi o:</p>
<pre><code class="language-js">// if there is active product and it's not thisProduct.element, remove class active from it
</code></pre>
<p>Zauważ, że nie tylko chcemy sprawdzić, czy udało się znaleźć aktywny produkt, ale również, czy nie jest on czasem tym produktem, na który klikamy. Dlaczego?</p>
<p>Pomyśl nad taką sytuacją. Powiedzmy, że aktualnie na stronie jest rozwinięty jeden produkt – pizza. Co stałoby się w momencie kliknięcia, gdybyśmy nie sprawdzali, czym jest znaleziony aktywny produkt? Oczekiwalibyśmy oczywiście, że kliknięcie na aktywny produkt, spowoduje jego zwinięcie. A co naprawdę by się stało?</p>
<p>Nasza funkcja najpierw jako aktywny produkt znalazłaby... naszą pizzę i ją zwinęła. Następnie nasz kod niżej, który ma "togglować" klasę na klikniętym produkcie, ustaliłby, że na naszym elemencie (pizzy) klasy <code>active</code> nie ma, więc by ją... ponownie dodał. Tym samym nasza pizza znowu by się rozwinęła. Chyba nie o to nam chodzi, prawda? ;)</p>
<p>Dlatego też, zanim schowasz aktywny produkt, to sprawdź, czy nie jest on czasem równy <code>thisProduct.element</code>. Chodzi nam o schowanie innego aktualnie aktywnego produktu, o ile taki jest. Nie tego, na który właśnie klikamy.</p>
<h3>Składnia handlera w listenerze eventu</h3>
<p>W poprzednich modułach używaliśmy tego typu składni listenera i handlera:</p>
<pre><code class="language-js">function titleClickHandler(){
  console.log('clicked');
}

const buttonTest = document.getElementById('button-test');

buttonTest.addEventListener('click', titleClickHandler);
</code></pre>
<p>Teraz, kiedy już lepiej rozumiesz ich działanie, zastosujemy składnię, z którą dużo częściej się spotkasz. Zmodyfikujemy powyższy przykład, aby pokazać Ci, jak będziemy pisać od teraz:</p>
<pre><code class="language-js">const buttonTest = document.getElementById('button-test');

buttonTest.addEventListener('click', function(){
  console.log('clicked');
});
</code></pre>
<p>Zamiast używać funkcji o nazwie <code>titleClickHandler</code>, podajemy anonimową (nienazwaną) funkcję jako drugi argument metody <code>addEventListener</code>.</p>
<p>To podejście jest często preferowane, ponieważ zmniejsza liczbę nazwanych funkcji i ułatwia zrozumienie kodu. Będziemy się jednak starać, aby kod funkcji handlera nie był zbyt długi – gdyby miał nie mieścić się w całości na ekranie monitora (bez scrollowania), to część kodu możemy przenieść (zgodnie ze starym pomysłem) do osobnej metody. Wtedy funkcję handlera można ograniczyć do wywołania kilku metod naszego produktu.</p>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">dokończenie akordeonu</span></h3>
                        <div class="task-content">
                            <p>Dokończenie funkcji <code>initAccordion</code> jest Twoim zadaniem w tym submodule. Wszystkie operacje, które są do wykonania, były już wykorzystywane przez nas w poprzednim projekcie.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/accordion.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/accordion-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/accordion.png 2x" class="img-inline img-left">
<h5>Oczekiwany efekt</h5>
<p>Po odświeżeniu strony, pod żadnym z produktów nie powinny być widoczne opcje (razem z wyborem ilości i guzikiem dodania do koszyka).</p>
<p>Efektem tego zadania powinna być funkcjonalność, dzięki której po kliknięciu w nazwę produktu, opcje powinny się pokazać, ale tylko dla tego produktu.</p>
<p>Jeśli jeden produkt ma wyświetlone opcje, to kliknięcie w nazwę innego produktu powinno zamknąć opcje wcześniej otwartego produktu, i jednocześnie pokazać opcje produktu, którego nazwę kliknęliśmy.</p>
<p>Jeśli czujesz się pewnie, to od razu bierz się do pracy. Jeśli jednak masz jakieś problemy, skorzystaj z poniższych wskazówek.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-1RT54a0ue-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż podpowiedzi</a>
    <a href="#collapse-1RT54a0ue-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj podpowiedzi</a>
  </span>
</p>
<div id="collapse-1RT54a0ue-toggle" class="collapse">
<p>Do rozwiązania tego zadania przydadzą Ci się te informacje:</p>
<ul>
<li>aby odnaleźć <code>clickableTrigger</code>, użyj selektora <code>select.menuProduct.clickable</code>,</li>
<li>zastanów się, czy szukać elementu <code>clickableTrigger</code> w całym dokumencie, czy może jednak dokładniej?</li>
<li>element bieżącego produktu to <code>thisProduct.element</code>, czyli to na tym elemencie będziemy dodawać i usuwać (<em>toggle</em>) klasę zdefiniowaną w <code>select.menuProduct.clickable</code>,</li>
<li>aby sprawdzić, czy dany element DOM udało się znaleźć, wystarczy sprawdzić, czy nie jest nullem <code>if(activeProduct)</code>,</li>
<li>do sprawdzenia, czy dany aktywny produkt jest różny od elementu bieżącego produktu, wystarczy wykorzystać takiego samego <a href="https://poradnik-js.kodilla.com/operators" target="_blank">operatora porównania</a>, jak przy porównywaniu liczb.</li>
</ul>
</div>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/604290" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/28a649b7df04f117a83982efab00185d6d9b45a6">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1968" class="card submodule completed" data-bootcamp-user-submodule-id="604291" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.6. <span>Obliczamy cenę produktu</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Mamy już akordeon, który pokazuje opcje pojedynczego produktu – ale na razie same opcje niczego nie robią. Możemy zaznaczać czy odznaczać dane wybory, ale to... niczego nie zmieni. Czas się za to zabrać!</p>
<h3>Obsługa opcji produktu</h3>
<p>Cel jest następujący. Chcemy, żeby zmiana jakiejkolwiek opcji produktu, z automatu powodowała ponowne przeliczenie ceny. Tak, aby odpowiadała ona wybranym dodatkom. W końcu pizza z dodatkowym ananasem, czy salami, musi kosztować więcej niż wersja podstawowa, prawda? Tak samo, jak zabranie z pizzy domyślnie dodawanych oliwek, taką cenę powinno zmniejszyć.</p>
<p>Załóż, że cena produktu zawarta w danych źródłowych (w <code>data.js</code>) uwzględnia domyślnie zaznaczone opcje. To ważna informacja. Musimy bowiem uważać, żeby nie dodawać ceny takich opcji do ceny produktu. Za to, jeśli odznaczymy którąś z domyślnych opcji, cena produktu powinna się zmniejszyć.</p>
<p>Oznacza to po prostu tyle, że:</p>
<ul>
<li>jeśli zaznaczymy opcję, która nie jest domyślna, cena produktu musi się zwiększyć o cenę tej opcji,</li>
<li>jeśli odznaczymy opcję, która jest domyślna, cena produktu musi się zmniejszyć o cenę tej opcji.</li>
</ul>
<p>Brzmi prosto, prawda? Teraz musimy tylko zastanowić się, jak ten algorytm zaimplementować.</p>
<p>Na pewno będzie nam zależało, żeby nasz skrypt reagował na każdą zmianę wartości – np. zaznaczenie którejś opcji. Naturalnie, możesz pomyśleć, że kiedy zaznaczymy jakąś opcję, to jej wartość powinna zostać dodana lub odjęta od ceny produktu. Takie podejście jest jednak ryzykowne, ponieważ jest podatne na błędy.</p>
<div class="bc-note alert-warning">
<h4 class="alert-heading text-center">Potencjalne błędy</h4>
<p>Nie będziemy teraz wchodzić w bardzo techniczne szczegóły potencjalnych problemów z takim podejściem, ale są sytuacje, w których pola formularza mogą zmieniać wartość, a nasz skrypt nie będzie o tym powiadomiony. Przykładem może być wtyczka do przeglądarki, która zapamiętuje stan formularza.</p>
<p>Użytkownik może wejść na stronę, zaznaczyć wszystkie składniki, a następnie odświeżyć stronę – jego wtyczka wtedy mogłaby zaznaczyć wszystkie składniki bez informowania o tym naszego skryptu. Jest to sytuacja, której być może nie da się uniknąć, ale jeszcze gorzej, jeśli użytkownik wtedy zacznie odznaczać składniki, a cena produktu zacznie spadać – może nawet poniżej zera!</p>
</div>
<p>Aby nasz skrypt działał lepiej, zastosujemy inne rozwiązanie – przy jakiejkolwiek zmianie opcji, cena produktu zostanie policzona na nowo, w oparciu o wszystkie wybrane opcje. Przy okazji, to podejście uprości nasz algorytm, bo nie będziemy musieli przejmować się tym, która z opcji została zmieniona. Przy każdej zmianie będziemy wykonywać te same obliczenia.</p>
<h3>Wyszukanie elementów DOM</h3>
<p>Zanim rozpoczniemy pisanie obsługi opcji produktu, zadbajmy nieco o porządek. Różne metody naszej klasy będą potrzebowały odnosić się do poszczególnych elementów DOM, stworzonych niedawno na podstawie szablonu Handlebars. Raz będziemy chcieli odnieść się do formularza z opcjami, innym razem do diva z ceną itd. Bez sensu za każdym razem szukać tych elementów w danej metodzie. Lepiej przygotować te referencje raz i to w taki sposób, żeby były dostępne we wszystkich metodach, a więc zapisując je jako właściwości <code>this</code>. Może za to odpowiadać nawet jedna metoda.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/cash.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/cash-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/cash.png 2x" class="img-inline img-right">
<p>Dzięki temu będziemy mieć jedną metodę służącą odnalezieniu elementów w kontenerze produktu, a inne będą tylko z tych przygotowanych referencji korzystały. Posłuży nam ona trochę za spis treści, dzięki któremu będziemy mieli pewność, że nie wyszukujemy tego samego elementu wielokrotnie.</p>
<p>W klasie <code>Product</code>, pod deklaracją metody <code>renderInMenu</code>, dodaj tę metodę:</p>
<pre><code class="language-js">    getElements(){
      const thisProduct = this;

      thisProduct.accordionTrigger = thisProduct.element.querySelector(select.menuProduct.clickable);
      thisProduct.form = thisProduct.element.querySelector(select.menuProduct.form);
      thisProduct.formInputs = thisProduct.form.querySelectorAll(select.all.formInputs);
      thisProduct.cartButton = thisProduct.element.querySelector(select.menuProduct.cartButton);
      thisProduct.priceElem = thisProduct.element.querySelector(select.menuProduct.priceElem);
    }
</code></pre>
<p>Oczywiście nazwa ta, to jak zawsze, tylko nasze "widzimisię". Musisz przyznać jednak, że dobrze oddaje rolę tej funkcji.</p>
<p>Następnie zadbaj o to, aby była ona uruchamiana w konstruktorze, tuż pod <code>thisProduct.renderInMenu();</code>.</p>
<p>Zauważ, że pierwszym z zapisanych elementów jest <code>thisProduct.accordionTrigger</code>. To referencja do tego samego elementu, którego szukaliśmy wcześniej w <code>initAccordion</code>! Po co nam dwie referencje do tego samego elementu? Skoro teraz ta referencja jest już przygotowana wcześniej (metoda <code>getElements</code> uruchamia się przed <code>initAccordion</code>), to możemy od razu z niej skorzystać, zamiast ponownie wyszukiwać ten sam element. Zrób to teraz:</p>
<pre><code class="language-js">thisProduct.accordionTrigger.addEventListener('click', function(event) {
  ...
</code></pre>
<p>Zauważ, że stała <code>clickableTrigger</code> jest już teraz zbędna.</p>
<p>Kolejne dwa elementy to referencja do formularza z opcjami oraz wszystkich jego kontrolki (checkboksy, selecty, etc.). Zaraz będą nam potrzebne. W końcu będziemy musieli jakoś ustalić, czy dana opcja została wybrana i czy trzeba zmienić cenę.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Przeanalizuj te linie kodu i zobacz, jakie selektory wykorzystujemy (są zapisane w obiekcie <code>select</code>) oraz spróbuj określić, co zostanie wyszukane. Zwróć szczególną uwagę na sytuację, w której szukamy elementów za pomocą <code>querySelector</code> lub <code>querySelectorAll</code>.</p>
<p>Następnie sprawdź za pomocą <code>console.log</code>, czy udało Ci się dobrze przewidzieć rezultat.</p>
</div>
<h3>Dodajemy akcję do formularza</h3>
<p>Na razie nie myślimy o tym, w jaki sposób obliczać cenę produktu. Piszemy nową funkcjonalność krok po kroku. Udało nam się już przygotować dostęp do potrzebnych elementów, więc kolejnym krokiem będzie zadbanie o to, aby reagować na zmiany w tych elementach. A konkretnie właśnie w kontrolkach formularza. Zmiana w polach tekstowych, checkboxach czy selectach powinna być dla nas równoznaczna z włączeniem funkcji, która od nowa przeliczy cenę. Będziemy chcieli więc reagować na zmianę wartości każdej kontrolki formularza. Pomoże nam w tym event <code>change</code>, który jest emitowany domyślnie przez przeglądarkę właśnie w tej sytuacji. Na tym jednak nie koniec.</p>
<p>Warto pamiętać również, że każdy formularz posiada domyślną akcję – wysłanie formularza z przeładowaniem strony. Na razie nie podłączaliśmy żadnej funkcjonalności do pola wyboru ilości sztuk zamawianego produktu – sprawdź, co się stanie, kiedy spróbujesz wpisać inną liczbę sztuk, a następnie naciśniesz enter.</p>
<p>Strona się przeładowała, a w dodatku teraz mamy bardzo długi adres strony – zostały w nim zawarte wszystkie wybrane przez nas opcje tego produktu. Zdecydowanie nie chcemy zostawiać takiej domyślnej akcji! Całe szczęście, formularz wywołuje na sobie event <code>submit</code> tuż zanim będzie wysłany, i to niezależnie od tego, czy wysłanie jest wywołane przez wciśnięcie entera, czy kliknięcie guzika. Dzięki temu będziemy mogli nasłuchiwać na niego i w momencie wykrycia, wykorzystać znane nam już wyrażenie <code>event.preventDefault();</code>, które powstrzyma domyślną akcję – czyli wysłanie formularza z przeładowaniem strony.</p>
<h5>Przygotowanie metod</h5>
<p>Zaczniemy od stworzenia nowych metod. Przejdź w kodzie klasy <code>Product</code> pod deklarację metody <code>initAccordion</code> i dodaj dwie nowe metody: <code>initOrderForm</code> i <code>processOrder</code>. Na razie dodaj w nich tylko <code>const thisProduct = this;</code> oraz <code>console.log</code> informujący o nazwie metody, w której się znajduje.</p>
<p>W konstruktorze dodaj wywołanie nowo stworzonych metod, tuż pod wywołaniem metody <code>initAccordion</code>. W końcu metody same się nie inaczej nie wywołają. W tym momencie w konsoli powinna wyświetlać się nazwa każdej z tych funkcji i to osobno dla każdego z produktów (czyli np. <code>processOrder</code> wyświetli się 4 razy, jeśli mamy 4 produkty na stronie). W końcu każda nowa instancja to wywołanie konstruktora dla nowo utworzonego obiektu.</p>
<p>Mamy przygotowane metody, teraz zajmiemy się napisaniem pierwszej z nich.</p>
<h5>Event listenery dla formularza</h5>
<p>Metoda <code>initOrderForm</code> będzie uruchamiana tylko raz dla każdego produktu. Będzie odpowiedzialna za dodanie listenerów eventów do formularza, jego kontrolek, oraz guzika dodania do koszyka.</p>
<pre><code class="language-js">      thisProduct.form.addEventListener('submit', function(event){
        event.preventDefault();
        thisProduct.processOrder();
      });

      for(let input of thisProduct.formInputs){
        input.addEventListener('change', function(){
          thisProduct.processOrder();
        });
      }

      thisProduct.cartButton.addEventListener('click', function(event){
        event.preventDefault();
        thisProduct.processOrder();
      });
</code></pre>
<p>Jak widzisz, w każdej funkcji callback wywołujemy metodę <code>processOrder</code> bez żadnych argumentów. Dodatkowo, dla eventów <code>submit</code> na formularzu oraz <code>click</code> na guziku blokujemy domyślną akcję – czyli odpowiednio: wysłanie formularza z przeładowaniem strony oraz zmianę adresu strony po kliknięciu w link (nasz guzik tylko wygląda jak guzik – w rzeczywistości jest linkiem).</p>
<p>Dokładnie tak jak tłumaczyliśmy wcześniej, ten kod jest bardzo prosty dzięki podejściu, które przyjęliśmy. Niezależnie od tego, który z tych eventów się wydarzy, wykonamy metodę <code>processOrder</code>, która obliczy cenę produktu. Klikniesz button "Add to cart" – uruchomi się przeliczanie ceny, zmienisz jakąś opcję – włączy się przeliczanie ceny, klikniesz enter (wysyłka formularza) – to samo.</p>
<p>Za jakiś czas wrócimy do tego kodu i w handlerze kliknięcia w guzik dodamy kod, który będzie dodawał ten produkt do koszyka. Na razie jednak wystarczy, że uruchamia metodę <code>processOrder</code>.</p>
<p>Możesz sprawdzić działanie tego kodu – przy każdej zmianie opcji, próbie wysłania formularza lub kliknięcie w guzik, uruchomi się <code>console.log</code> w metodzie <code>processOrder</code> i wyświetli komunikat w konsoli.</p>
<h3>Obliczanie ceny produktu</h3>
<p>Wszystko fajnie, ale ta funkcja musi faktycznie to przeliczanie wykonać. Czas więc na najciekawszą część najnowszej funkcjonalności naszej strony – obliczanie ceny produktu z uwzględnieniem wybranych opcji.</p>
<h5>Jak to w ogóle ma działać?</h5>
<p>Pomysł jest prosty. Funkcja ta musi pobrać domyślną cenę produktu z <code>thisProduct.data</code> oraz sprawdzić jakie opcje są wybrane. Jeśli jakaś opcja jest wybrana, a nie jest domyślna, to cena podstawowa musi się zwiększyć o koszt tego dodatku. Jeśli z kolei opcja jest odznaczona, a była domyślna, to cena podstawowa musi się zmniejszyć. Na końcu taka nowa, przeliczona cena, powinna zostać zaktualizowana na stronie (<code>thisProduct.priceElem</code>).</p>
<p>Będzie to wyglądać następująco:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-11.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-11.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Wydaje się, że mamy dwie drogi, aby dojść do tego celu.</p>
<ol>
<li>Przejdziemy po wszystkich polach formularza i sprawdzimy każdy z nich. Ustalimy, czy pole jest zaznaczone, czy nie, a następnie sprawdzimy, jak dana opcja jest opisana w <code>thisProduct.data.params</code>. Dlaczego tam? Bo to właśnie tam znajdziemy dokładne informacje o tym, jakie opcje są do wyboru, jakie są domyślne i jakie są ich ceny. Dzięki temu będziemy w stanie ustalić, czy trzeba zwiększyć lub zmniejszyć cenę oraz o ile.</li>
</ol>
<p>Dla przypomnienia, spójrz na ten obiekt <code>params</code>. Na przykładzie obiektu <code>breakfast</code>:</p>
<pre><code class="language-js">    params: {
      coffee: {
        label: 'Coffee type',
        type: 'radios',
        options: {
          latte: {
            label: 'Latte',
            price: 1,
            default: true
          },
          cappuccino: {
            label: 'Cappuccino',
            price: 1
          },
          espresso: {
            label: 'Espresso',
            price: 1
          },
          macchiato: {
            label: 'Macchiato ',
            price: 1
          },
        },
      },
    },
</code></pre>
<ol start="2">
<li>Jest jeszcze druga opcja, którą właśnie my podążymy. Przechodzimy po wszystkich opcjach produktu (<code>thisProduct.data.params</code>) i sprawdzamy każdą z nich. Mamy bezpośrednią informację o domyślności (właściwość <code>default</code>) czy cenie (właściwość <code>price</code>). Formularz wykorzystujemy tylko po to, aby ustalić, czy dana opcja była zaznaczona. Tak, aby ustalić, co mamy zrobić z ceną. Zwiększyć ją? Zmniejszyć? A może nie ruszać?</li>
</ol>
<p>Zauważ, że niezależnie od wybranej drogi, musimy mieć dostęp do formularza, a dokładniej do jego pól.</p>
<h5>Odczytywanie wartości z formularza</h5>
<p>Zanim więc przejdziemy do algorytmu obliczania ceny, musimy odczytać, które opcje formularza zostały wybrane. Aby ułatwić to zadanie, przygotowaliśmy funkcję <code>utils.serializeFormToObject</code>. Nie musisz interesować się, jak ona dokładnie działa "pod maską". Dla Ciebie ważne jest to, że potrafi ona po otrzymaniu obiektu formularza przekonwertować go do zwykłego obiektu JS.</p>
<p>To bardzo duże ułatwienie. W teorii można by dostać się do pól formularza przy użyciu metody <code>querySelectorAll</code>, mamy nawet odpowiedni selektor, ale metoda ta jednak zwróci nam tablicę elementów HTML, czyli inputów, selectów itd. To znacznie utrudniłoby nam pracę. Aby dojść do konkretnej wartości zamiast całego elementu (np. <code>&lt;input type=&quot;text&quot; ...</code>), musielibyśmy poczynić dodatkowe kroki... Dzięki funkcji <code>utils.serializeFormToObject</code> otrzymamy od razu prosty i przyjazny obiekt JS z samymi wartościami.</p>
<p>Funkcja ta będzie więc zwracać obiekt, w którym:</p>
<ul>
<li>kluczami będą wartości atrybutów <code>name</code> kontrolek formularza,</li>
<li>wartościami będą tablice, zawierające wartości atrybutów <code>value</code> wybranych opcji.</li>
</ul>
<p>Zatem np. jeśli w formularzu pizzy, ktoś wybrałby jako <code>sauce</code> wartość <code>tomato</code>, a z dodatków (<code>toppings</code>) wskazałby na <code>olives</code> i <code>salami</code>, to otrzymalibyśmy następujący obiekt:</p>
<pre><code class="language-js">{
  sauce: ['tomato'],
  toppings: ['olives', 'salami']
}
</code></pre>
<p>Musisz przyznać, że to dość fajna struktura, a już na pewno lepsza niż lista elementów DOM <code>[&lt;input type=&quot;text&quot; ... /&gt;, &lt;input type=&quot;text&quot; ... /&gt;, ...]</code>. Dzięki niej możemy bardzo łatwo ustalić, czy dana opcja jest wybrana.</p>
<p>Chcesz wiedzieć, czy wybrano <code>olives</code>? Wystarczy sprawdzić, czy ten obiekt zawiera w <code>sauce</code> element <code>olives</code>.</p>
<pre><code class="language-js">if(obj.sauce.includes('olives')) { console.log('Wybrano!'); }
</code></pre>
<p>Metoda <code>includes</code> użyta na tablicy sprawdza właśnie, czy dany element jest w niej dostępny. Jeśli jest, to wiemy, że był zaznaczony, jeśli nie – nie był. Jeszcze do tego wrócimy, ale przyznaj, że zapowiada się to ciekawie.</p>
<p>No dobrze. Chwalimy funkcję <code>utils.serializeFormToObject</code>, mówimy, co nam zwróci, ale chyba najlepiej zobaczyć to na własne oczy! Sprawdźmy, czy faktycznie tak będzie – w metodzie <code>processOrder</code> dodaj następujący kod:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-18.png" style="width: auto;">
<p>Następnie odznacz jedną z dowolnych opcji, np. w pizzy, i zajrzyj do konsoli:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-12.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-12.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Spójrz tylko! Tak jak mówiliśmy. Możesz teraz porównać to, co widzisz aktualnie w formularzu i to, jaki obiekt otrzymaliśmy. Odpowiada on dokładnie temu, co jest zaznaczone.</p>
<h5>Algorytm obliczania ceny</h5>
<p>Teraz, kiedy wiemy już co wybrano w formularzu, wydaje się, że możemy przejść do dalszej części funkcji. Zanim jednak to zrobimy, wytłumaczmy, dlaczego odrzucamy pierwszą ze wspomnianych wcześniej opcji.</p>
<p>Wydaje się, że teraz kiedy mamy już odczytane wartości z formularza, wystarczy dla każdej z nich odczytać cenę i dodać ją (lub odjąć) do ceny produktu, prawda? Chwila, nie tak szybko – sprawdź, co się stanie, kiedy odznaczysz wszystkie domyślne opcje.</p>
<p>Nasz obiekt, zwracany przez <code>utils.serializeFormToObject</code>, zawiera tylko zaznaczone opcje – a przecież w tej sytuacji powinniśmy od ceny produktu odjąć ceny domyślnych opcji, które odznaczyliśmy. To oznacza, że nie możemy iterować po tym obiekcie, bo nie zajęlibyśmy się odznaczonymi opcjami...</p>
<p>Stąd też postawiliśmy na drugą opcję. Aby upewnić się, że przeanalizowaliśmy istniejące możliwości, będziemy po prostu iterować po wszystkich. Ma to sens, prawda?</p>
<p>Tutaj musimy się jednak na moment zatrzymać. Pamiętaj, że opcje do wyboru są skategoryzowane. Spójrz chociażby na <code>params</code> w produkcie <code>pizza</code>.</p>
<pre><code class="language-js">params: {
      sauce: {
        label: 'Sauce',
        type: 'radios',
        options: {
          tomato: {
            label: 'Tomato',
            price: 0,
            default: true
          },
          cream: {
            label: 'Sour cream',
            price: 2
          },
        },
      },
      toppings: {
        label: 'Toppings',
        type: 'checkboxes',
        options: {
          olives: {
            label: 'Olives',
            price: 2,
            default: true
          },
          redPeppers: {
            label: 'Red peppers',
            price: 2,
            default: true
          },
          greenPeppers: {
            label: 'Green peppers',
            price: 2,
            default: true
          },
          mushrooms: {
            label: 'Mushrooms',
            price: 2,
            default: true
          },
          basil: {
            label: 'Fresh basil',
            price: 2,
            default: true
          },
          salami: {
            label: 'Salami',
            price: 3
          },
        },
      },
      crust: {
        label: 'pizza crust',
        type: 'select',
        options: {
          standard: {
            label: 'standard',
            price: 0,
            default: true
          },
          thin: {
            label: 'thin',
            price: 2
          },
          thick: {
            label: 'thick',
            price: 2
          },
          cheese: {
            label: 'cheese in edges',
            price: 5
          },
          wholewheat: {
            label: 'wholewheat',
            price: 3
          },
          gluten: {
            label: 'with extra gluten',
            price: 0
          },
        },
      },
    },
</code></pre>
<p>Nie mamy tutaj listy 5 czy 10 różnych opcji, które mogą być zaznaczone. Zamiast tego jest obiekt "kategorii" (np. <code>sauce</code>, <code>toppings</code>, <code>crust</code>) i dopiero każda z nich ma swoje własne obiekty z opcjami (<code>options</code>). A więc np. <code>sauce</code> ma w sobie opcje <code>tomato</code> i <code>cream</code>, a <code>toppings</code> posiada <code>olives</code>, <code>redPeppers</code> itd.</p>
<p>Jaki z tego wniosek? Nie jesteśmy w stanie "przejść" za pomocą jednej pętli od razu po wszystkich opcjach. Zamiast tego musimy najpierw utworzyć pętlę, która przejdzie po wszystkich kategoriach, a dopiero w środku kolejną (drugą), która dla danej kategorii przejdzie jeszcze po wszystkich jej opcjach.</p>
<p>Wewnątrz tej drugiej pętli będziemy musieli zastosować logikę, o której wspomnieliśmy na początku tego submodułu, czyli:</p>
<ul>
<li>jeśli jest zaznaczona opcja, która nie jest domyślna, cena produktu musi się zwiększyć o cenę tej opcji,</li>
<li>jeśli nie jest zaznaczona opcja, która jest domyślna, cena produktu musi się zmniejszyć o cenę tej opcji.</li>
</ul>
<p>Pozostaje jeszcze pytanie: jak zweryfikować, czy dana opcja jest zaznaczona? Wystarczy, że sprawdzimy:</p>
<ul>
<li>czy w obiekt <code>formData</code> zawiera właściwość o kluczu takim, jak klucz parametru (powinien, ale lepiej się upewnić), oraz</li>
<li>czy w tablicy zapisanej pod tym kluczem znajduje się klucz opcji (wspomniana wcześniej metoda (<code>includes</code>)).</li>
</ul>
<p>Jeśli oba te warunki są prawdziwe, to znaczy, że opcja jest zaznaczona. Jeśli jednocześnie ta opcja nie ma właściwości <code>default</code> (lub jest ona fałszem), to powinniśmy zwiększyć cenę produktu. Jeśli natomiast opcja nie jest zaznaczona, ale ma prawdziwą właściwość <code>default</code> (czyli powinna być domyślna), to zmniejszyć. W obu przypadkach będziemy zmieniać cenę produktu o cenę danej opcji.</p>
<p>Rozpiszmy razem początek tej metody:</p>
<pre><code class="language-js">processOrder() {
  const thisProduct = this;

  // covert form to object structure e.g. { sauce: ['tomato'], toppings: ['olives', 'redPeppers']}
  const formData = utils.serializeFormToObject(thisProduct.form);
  console.log('formData', formData);

  // set price to default price
  let price = thisProduct.data.price;

  // for every category (param)...
  for(let paramId in thisProduct.data.params) {
    // determine param value, e.g. paramId = 'toppings', param = { label: 'Toppings', type: 'checkboxes'... }
    const param = thisProduct.data.params[paramId];
    console.log(paramId, param);

    // for every option in this category
    for(let optionId in param.options) {
      // determine option value, e.g. optionId = 'olives', option = { label: 'Olives', price: 2, default: true }
      const option = param.options[optionId];
      console.log(optionId, option);
    }
  }

  // update calculated price in the HTML
  thisProduct.priceElem.innerHTML = price;
}
</code></pre>
<p>Co tu się dokładnie dzieje? Początek już znasz. Przygotowujemy dostęp do formularza w postaci wygodnego JS-owego obiektu.</p>
<pre><code class="language-js">// set price to default price
let price = thisProduct.data.price;
</code></pre>
<p>Kolejna instrukcja też nie jest raczej niczym niezwykłym. Tworzymy zmienną, w której będziemy trzymać naszą cenę. Startowo otrzymuje ona domyślną cenę produktu, ale oczywiście później, wraz ze sprawdzaniem zaznaczonych opcji jej, wartość będzie odpowiednio zwiększana lub zmniejszana. Zaznaczono dodatkową opcję – <code>price</code> się zwiększy. Odznaczono domyślną opcję – <code>price</code> się zmniejszy.</p>
<p>Co do obu pętli poniżej, to już wytłumaczyliśmy, skąd taki pomysł. Jedyne co może Cię dziwić, to linijki:</p>
<pre><code class="language-js">const param = thisProduct.data.params[paramId];
</code></pre>
<pre><code class="language-js">const option = param.options[optionId];
</code></pre>
<p>Po co nam one? Przypomnijmy, pętla <code>for..in</code> w zmiennej iteracyjnej zwraca zawsze tylko nazwę właściwości. Czyli np. <code>paramId</code> dla <code>toppings</code> będzie niecałym obiektem:</p>
<pre><code class="language-js"> toppings: {
        label: 'Toppings',
        type: 'checkboxes',
        options: {
          olives: {
            label: 'Olives',
            price: 2,
            default: true
            ...
</code></pre>
<p>...tylko samą nazwą właściwości – <code>toppings</code>. Ta dodatkowa linijka dba więc o to, aby dostać się do całego obiektu dostępnego pod tą właściwością.</p>
<p>Dokładnie to samo mamy też w przypadku drugiej pętli. Również chcemy mieć obiekt do całej opcji, a nie tylko jej nazwy.</p>
<pre><code class="language-js">  // update calculated price in the HTML
  thisProduct.priceElem.innerHTML = price;
</code></pre>
<p>Ostatnia linijka nie wymaga komentarza. Po prostu wpisujemy przeliczoną cenę do elementu w HTML-u:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-13.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-13.png" alt="image" style="width: auto; max-width: 50%;"></a>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">wdrożenie obliczania ceny</span></h3>
                        <div class="task-content">
                            <p>Twoim zadaniem będzie dokończenie metody <code>processOrder</code> tak, aby poprawnie modyfikowała <code>price</code>, zgodnie z tym, jakie opcje są zaznaczone w formularzu. Tak naprawdę większość funkcji jest już gotowa. Jedyne miejsce, w którym będziesz pracować, to pętla drugiego poziomu, gdzie przechodzimy po opcjach danej kategorii. To właśnie tam musisz dodać kod, który będzie sprawdzał, czy dana opcja (<code>optionId</code>) danej kategorii (<code>paramId</code>) jest wybrana w formularzu (<code>formData</code>), a następnie ustalał, czy trzeba zwiększyć lub zwiększyć cenę. Albo... nie robić z nią nic, bo i taka sytuacja może się pojawić. Jeśli np. opcja jest bowiem wybrana i jest określona jako domyślna, to jest już wliczona w cenę startową. Nie musimy wtedy modyfikować <code>price</code>. Podobnie w sytuacji, kiedy odznaczona opcja nie jest opcją domyślną.</p>
<p>Algorytm, który opisaliśmy powyżej, powinien być dla Ciebie wystarczający do napisania dokończenia tej metody. Zacznij od zapisania tego algorytmu w formie komentarzy, może Ci to pomóc w rozplanowaniu pracy.</p>
<p>Po wykonaniu każdego kroku, sprawdź jego poprawność za pomocą <code>console.log</code>. Dzięki temu będzie Ci łatwiej zrealizować to zadanie.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Poznaj debugger</h4>
<p>Im większy staje się nasz kod i częściej chcemy sprawdzić, co się w nim właściwie dzieje, tym bardziej męczące staje się korzystanie z <code>console.log</code>. Debugowanie z pomocą tej metody jest możliwe i dotychczas jakoś sobie z tym radziliśmy, ale nie jest to najbardziej komfortowy sposób. Na szczęście przeglądarka Google Chrome udostępnia nam alternatywne narzędzie, które potrafi znacznie przyśpieszyć i ułatwić ten proces – debugger.</p>
<p>Jego znajomość nie jest obowiązkowa, ale daj mu szansę. Jego zalety są przeogromne. Od możliwości zatrzymania działania kodu w dowolnym momencie, poprzez sprawdzanie wartości zmiennych, czy nawet "podglądanie" co dokładnie znajduje się w danym momencie w pamięci.</p>
<p>Zachęcamy do przeczytania krótkiego wprowadzenia w naszej <a href="https://poradnik-js.kodilla.com/debugging" target="_blank">dokumentacji</a>. Jeśli nie masz problemów z angielskim, zachęcamy również do obejrzenia dłuższego materiału z oficjalnego kanału twórców Google Chrome.</p>
<div class="embed-container"><iframe src="https://www.youtube.com/embed/H0XScE08hy8" frameborder='0' allowfullscreen></iframe></div>
</div>
<p>Popracuj nad tym zadaniem co najmniej przez pół godziny (a najlepiej godzinę) – jeśli po tym czasie nie uda Ci się go rozwiązać, możesz sprawdzić poniższe podpowiedzi.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-qh_3ZDwFs-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż podpowiedzi</a>
    <a href="#collapse-qh_3ZDwFs-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj podpowiedzi</a>
  </span>
</p>
<div id="collapse-qh_3ZDwFs-toggle" class="collapse">
<ul class="nav nav-tabs">
	<li class="nav-item"><a href="#task0705-hint1" class="nav-link active show" data-toggle="tab">Podpowiedź #1</a></li>
	<li class="nav-item"><a href="#task0705-hint2" class="nav-link" data-toggle="tab">Podpowiedź #2</a></li>
</ul>
<div class="tab-content">
<div id="task0705-hint1" class="tab-pane card fade active show"><div class="card-block">
<h5>Sugestie pomocne w rozwiązaniu zadania</h5>
<p>Zaczniemy od małej podpowiedzi. Rozpiszemy Ci punkt po punkcie, co Twój algorytm powinien robić.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-J2z2WACGkV-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż sugestie</a>
    <a href="#collapse-J2z2WACGkV-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj sugestie</a>
  </span>
</p>
<div id="collapse-J2z2WACGkV-toggle" class="collapse">
<ol>
<li>Zacznij od ustalenia, czy w <code>formData</code> istnieje właściwość o nazwie zgodnej z nazwą kategorii, a jeśli tak, to czy zawiera ona nazwę sprawdzanej opcji. Jeśli zawiera, to będzie to oznaczać, że opcja jest wybrana.</li>
<li>Jeśli tak jest, to sprawdź, czy opcja ta jest opcją domyślną. Jeśli nie, to musisz zwiększyć <code>price</code> o koszt tej danej opcji.</li>
<li>Jeśli jednak nie jest wybrana, to sprawdź, czy opcja jest domyślna. Jeśli tak, to musisz zmniejszyć <code>price</code> o koszt tej opcji.</li>
</ol>
<p>Dodatkowe wskazówki:</p>
<ul>
<li>Koniecznie przejrzyj w naszym poradniku informacje dotyczące <a href="https://poradnik-js.kodilla.com/objects" target="_blank">obiektów</a> i <a href="https://poradnik-js.kodilla.com/loops" target="_blank">pętli <em>for-in</em></a>, <a href="https://poradnik-js.kodilla.com/arrays" target="_blank">tablic</a> oraz <a href="https://poradnik-js.kodilla.com/operators" target="_blank">operatorów logicznych i przypisania</a>.</li>
<li>Jeśli mamy obiekt <code>option</code>, który ma właściwość <code>default</code> równą <code>false</code>, to wynikiem <code>!option.default</code> będzie prawda. Jeśli ten obiekt nie ma takiej właściwości, to samo wyrażenie będzie również prawdziwe, ponieważ <code>!undefined</code> jest <a href="https://poradnik-js.kodilla.com/conditions" target="_blank"><em>thruthy</em></a>.</li>
<li>Warunki "opcja zaznaczona i niedomyślna" oraz "opcja niezaznaczona i domyślna" nigdy nie będą jednocześnie spełnione dla tej samej opcji, więc zamiast dwóch bloków <code>if</code>, użyj <code>if</code> oraz <code>else if</code>.</li>
<li>Pamiętaj, że <code>thisProduct.priceElem</code> to cena przy guziku dodania do koszyka! Cena w nagłówku produktu nigdy nie będzie się zmieniać! Upewnij się, że patrzysz na właściwą cenę!</li>
</ul>
</div>
</div></div> <!-- /.tab-pane -->
<div id="task0705-hint2" class="tab-pane card fade"><div class="card-block">
<h5>Algorytm metody <code>processOrder</code></h5>
<p>Jeśli pierwsza podpowiedź to dla Ciebie za mało, poniżej możesz znaleźć ten sam pomysł, ale rozpisany już za pomocą komentarzy i z kawałkiem dodatkowego kodu.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-W_6N99dy4y-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż kod z algorytmem</a>
    <a href="#collapse-W_6N99dy4y-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj kod z algorytmem</a>
  </span>
</p>
<div id="collapse-W_6N99dy4y-toggle" class="collapse">
<pre><code class="language-js">        // for every option in this category
        for(let optionId in param.options) {
          // determine option value, e.g. optionId = 'olives', option = { label: 'Olives', price: 2, default: true }
          const option = param.options[optionId];
          console.log(optionId, option);

          // check if there is param with a name of paramId in formData and if it includes optionId
          if(formData[paramId] &amp;&amp; formData[paramId].includes(optionId)) {
            // check if the option is not default
            if(????) {
              // add option price to price variable
            }
          } else {
            // check if the option is default
            if(????) {
              // reduce price variable
            }
          }

        }

</code></pre>
</div>
</div></div> <!-- /.tab-pane -->
</div> <!-- /.tab-content -->
</div>
<hr>
<h5>Oczekiwany efekt</h5>
<p>Po odświeżeniu strony, tak jak do tej pory, wyświetlą się produkty z ukrytymi opcjami. Kiedy wyświetlimy np. opcje dla pizzy, zobaczymy cenę produktu tuż przy guziku dodawania do koszyka.</p>
<p>Kiedy zaznaczymy którąś z domyślnie niezaznaczonych opcji, cena powinna wzrosnąć o koszt tej opcji. Kiedy odznaczymy którąś z opcji, cena powinna spaść.</p>
<p>W rezultacie, po odznaczeniu wszystkich opcji, cena powinna być niższa od początkowej (która jest wyświetlana w nagłówku produktu). I odwrotnie – po zaznaczeniu wszystkich opcji, cena przy guziku powinna być wyższa niż początkowa.</p>
<p>Zmiana zamawianej ilości nie powinna na razie wpływać na cenę – jeszcze nie napisaliśmy kodu obsługującego tę funkcjonalność.</p>
<p>Uwaga! Nie idź dalej, dopóki metoda <code>processOrder</code> nie będzie dla Ciebie całkowicie jasna. W razie potrzeby zapytaj o pomoc na czacie. Nasza aplikacja pizzerii to na tym etapie kursu naprawdę duże wyzwanie i nie da się jej przejść "na pół gwizdka". Nawet małe braki w zrozumieniu na początku pracy mogą powodować wiele problemów na późniejszych etapach. Dlatego nie śpiesz się, realizuj go na spokojnie, dokładnie czytając cały materiał.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/604291" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/93262719e8b8ecd632af2be43ac5f98a618c3e9c">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1969" class="card submodule completed" data-bootcamp-user-submodule-id="604292" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.7. <span>Dodajemy obsługę obrazk&oacute;w</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Jak widzisz, stworzenie dotychczasowych skryptów kosztowało nas sporo pracy. Na szczęście to się opłaca. Nasza strona wygląda coraz ciekawiej. Za chwilę rozwiniemy ją jeszcze bardziej i sprawimy, że ilustracje pizzy i sałatki będą się zmieniać w zależności od wybranych opcji! Zajmie nam to tylko kilka linijek kodu, ale wrażenie będzie świetne i właśnie tych parę linijek sprawi, że każdy, kto obejrzy ten projekt, zapamięta go na długo!</p>
<h3>Analiza danych źródłowych</h3>
<p>Zanim będziemy mogli napisać tę funkcjonalność, musimy zrozumieć, co mamy do zrobienia. Otwórz <code>data.js</code> i znajdź obiekt <code>images</code> dla pizzy. To tablica elementów <code>img</code>, które są wykorzystywane przy renderowaniu diva z prezentacją pizzy.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-14.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-14.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Zwróć uwagę, że tylko jeden obrazek ma wyłącznie klasę <code>active</code> – pozostałe mają oprócz tego jeszcze jedną klasę. Ta klasa składa się z dwóch członów – pierwszy z nich to klucz parametru, a drugi to klucz opcji, np. <code>sauce-tomato</code> czy <code>toppings-salami</code>. Możesz nawet zajrzeć do obiektu <code>params</code> dla pizzy, aby sprawdzić, czy na pewno się zgadzają. Co nam to daje? Wystarczy znać nazwę kategorii i nazwę opcji, aby łatwo przygotować selektor, który wybierze odpowiadający takiej parze obrazek! I właśnie za chwilę to zrobimy.</p>
<p>Jednak najpierw musimy zrobić coś jeszcze, a mianowicie usunąć klasę <code>active</code> z każdego obrazka, który ma jakąkolwiek inną klasę. Nie usuwaj klasy <code>active</code>, jeśli jest to jedyna klasa danego obrazka. Za co odpowiada ta klasa? Obrazki składników są domyślnie ukryte (styl <code>display: none</code>). To klasa <code>active</code> sprawia, że obrazek jest widoczny, nadpisując <code>display</code> – dlatego np. obrazek ciasta pizzy ma mieć klasę <code>active</code>, bo ma być zawsze widoczny. Pozostałe obrazki jednak już jej mieć nie powinny. Odpowiadają bowiem składnikom, które mogą być pokazane, ale nie zawsze muszą. Powinny być widoczne tylko wtedy, kiedy odpowiadające im pola w formularzu będą zaznaczone. Zatem jeśli np. zaznaczymy oliwki w formularzu, to chcielibyśmy, żeby obrazek <code>toppings-olives</code> się pokazał. Musimy mu więc w takiej sytuacji nadać klasę <code>active</code>. Jeśli jednak potem taką opcję odznaczymy, to chcemy go schować (zabrać klasę <code>active</code>). Za dodawanie lub usuwanie klas <code>active</code> dla tych obrazków, będzie również odpowiadać funkcja <code>processOrder</code>.</p>
<h3>Uzupełnienie metody <code>getElements</code></h3>
<p>Zanim jednak do niej przejdziemy, musimy przygotować dostęp do diva, w którym te obrazki się znajdą. Dla czytelności. Moglibyśmy bowiem szukać np. <code>topping-olives</code> w całym <code>thisProduct.element</code>, ale po co? Lepiej przygotować sobie referencje do samego diva, w którym te obrazki są i potem w razie potrzeby to w nim szukać konkretnego obrazka.</p>
<p>Odnajdź więc metodę <code>getElements</code> i dodaj do niej właściwość <code>thisProduct.imageWrapper</code>. Ma być ona referencją do pojedynczego elementu o selektorze zapisanym w <code>select.menuProduct.imageWrapper</code>. Pamiętaj, aby wyszukiwać go w konkretnym produkcie, a nie całym dokumencie.</p>
<h3>Modyfikujemy metodę <code>processOrder</code></h3>
<p>Ponownie wracamy do drugiej pętli. Tej, która przechodzi po wszystkich opcjach z danej kategorii. Na razie zwiększamy tam lub zmniejszamy cenę. Teraz dodatkowo będziemy wyszukiwać obrazek pasujący do danej pary <code>kategoria-opcja</code> i zależnie od tego, czy opcja jest wybrana, pokazywać go lub chować. Oczywiście dzięki wykorzystaniu patentu z klasą <code>active</code>. Tak jak mówiliśmy, dodanie klasy <code>active</code> będzie powodować pokazanie obrazka, zabranie klasy <code>active</code> schowanie.</p>
<p>Ta druga pętla to idealni miejsce na umieszczenie kodu odpowiedzialnego za obrazki, bo mamy w nim informacje:</p>
<ul>
<li>jaki jest klucz parametru,</li>
<li>jaki jest klucz opcji,</li>
<li>czy ta opcja jest zaznaczona.</li>
</ul>
<p>Może spróbujesz dodać ten kawałek kodu bez naszej pomocy?</p>
<h5>Oczekiwany efekt</h5>
<p>W rezultacie zmiana opcji pizzy lub sałatki powinna zmieniać widoczność obrazków. Dzięki temu na stronie powinna wyświetlać się np. pizza ze składnikami, które się wybrało.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/08/08-15.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/08/08-15.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Pamiętaj, że nie wszystkie opcje mają swoje obrazki – nie zdziw się, że w niektórych produktach w ogóle nie zmieniają się. Zastosowaliśmy to rozwiązanie tylko w niektórych z nich.</p>
<h5>Podsumowanie</h5>
<p>Zwróć uwagę, że nadal nasz kod JS nie ma potrzeby wiedzieć, że np. na pizzy mogą być oliwki. Cały czas polega na danych z <code>data.js</code> i operuje na "każdej opcji każdego parametru", a nie na konkretnych wartościach. Dzięki temu nasz skrypt jest bardzo uniwersalny i pozwala na stosowanie tego samego kodu do każdego produktu.</p>
<p>Możesz zastanawiać się, dlaczego zdecydowaliśmy się, aby w danych źródłowych w <code>data.js</code> umieścić osobny obiekt <code>images</code>, zamiast dodać właściwość <code>image</code> do każdej opcji (albo chociaż niektórych). I tak właściwie, dlaczego w <code>data.js</code> wstawiliśmy kod HTML obrazków, zamiast tylko ich adresów <code>src</code>?</p>
<p>Wybraliśmy takie podejście, ponieważ gdyby to był prawdziwy, komercyjny projekt, dawałoby ono większą elastyczność dla administratora strony. Dzięki temu mógłby np. zdefiniować wymiary lub przesunięcia obrazków, albo dodać dowolny kod HTML, jaki byłby potrzebny. Zakładamy, że w komercyjnym projekcie administrator strony miałby do dyspozycji panel administracyjny, w którym obrazki mogłyby być wybierane za pomocą formularza, a nie wpisywane jako kod HTML.</p>
<p>Jednak w tym projekcie nie będziemy zajmować się panelem administracyjnym. Za to strona pizzerii nabiera kolejnych funkcjonalności – w zależności od opcji produktu, zmienia się zarówno cena, jak i obrazek. Jest coraz lepiej, ale nie działa jeszcze wybór ilości. Tym właśnie zajmiemy się w następnym submodule.</p>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">implementacja algorytmu</span></h3>
                        <div class="task-content">
                            <p>Mamy opisany algorytm, została już tylko jego implementacja. Chyba dasz sobie z nim radę? Tym razem nie będzie zbyt dużo podpowiedzi, ponieważ zadanie jest dużo prostsze. Wystarczy, że znajdziesz elementy wedle powyższego opisu i dla każdego ze znalezionych elementów nadasz/usuniesz wspomnianą klasę.</p>
<p>Cały kod, który musisz dodać, będzie dość krótki. To, co należy zrobić, to:</p>
<ol>
<li>Znalezienie obrazka o klasie <code>.paramId-optionId</code> w divie z obrazkami.</li>
<li>Sprawdzenie, czy udało się go znaleźć (pamiętaj, że nie każdy produkt ma obrazki dla opcji).</li>
<li>Jeśli się udało, to sprawdzenie, czy dana opcja jest zaznaczona. Jeśli jest, to należy pokazać taki obrazek. Jeśli nie jest, to należy go schować.</li>
</ol>
<p>Zauważ, że teraz nie ma znaczenia już to, czy opcja była domyślna. Ważne jest tylko to, czy opcja jest wybrana/zaznaczona, czy nie. Jeśli jest, to musi pokazać obrazek, który tej opcji odpowiada. W przeciwnym razie taki obrazek musimy schować.</p>
<p>Uwaga! Nie wpisuj w <code>classList.add</code> czy <code>classList.remove</code> bezpośrednio klasy <code>active</code>, lecz skorzystaj ze stałej <code>classNames.menuProduct.imageVisible</code>. Oczywiście da to nam taki sam efekt, ale trzymajmy się tych samych praktyk przez cały projekt. Skoro wcześniej też przechowywaliśmy nazwy klas w stałych, to róbmy to dalej.</p>
<p>Spróbuj rozwiązać to zadanie bez naszej pomocy. Jeśli jednak naprawdę się zatniesz, to skorzystaj z naszej podpowiedzi, jak zacząć.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-z4XtJ5XX9-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż podpowiedź</a>
    <a href="#collapse-z4XtJ5XX9-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj podpowiedź</a>
  </span>
</p>
<div id="collapse-z4XtJ5XX9-toggle" class="collapse">
<p>Zacznij od znalezienia obrazka odpowiadającego konkretnej parze <code>kategoria-opcja</code>.</p>
<pre><code class="language-js">const optionImage = thisProduct.imageWrapper.querySelector(???);
</code></pre>
<p>Selektor, który musisz przygotować, powinien wyglądać mniej więcej tak <code>.toppings-olives</code>. Dlaczego tak? Bo właśnie tego typu klasy mają wszystkie obrazki odpowiadające opcjom. Mówiliśmy o tym na początku zadania. Oczywiście nazwa kategorii nie powinna być zawsze równa <code>toppings</code>, tylko zależna od tego, do jakiej kategorii (paramu) należy opcja. Podobnie jak zamiast <code>olives</code> powinna być nazwa aktualnej opcji. Obie te informacje masz już w tej pętli <code>for</code> dostępne. Musisz tylko odnaleźć nazwy zmiennych, które je przechowują, a następnie stworzyć z ich pomocą poprawny selektor.</p>
</div>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-ui6R1jEAm5-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż kolejną podpowiedź</a>
    <a href="#collapse-ui6R1jEAm5-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj kolejną podpowiedź</a>
  </span>
</p>
<div id="collapse-ui6R1jEAm5-toggle" class="collapse">
<p>Zastanawiasz się, jak sprawdzić, czy obrazek udało się znaleźć? Metoda <code>querySelector</code>, jeśli nie udało się odnaleźć elementu, zawsze zwraca <code>null</code>. A <code>null</code> użyte w <code>if</code> da nam <code>false</code>... Z drugiej strony, jeśli element uda się znaleźć, to ten użyty w warunku zwróci na <code>true</code>.</p>
<pre><code class="language-js">const optionImage = thisProduct.imageWrapper.querySelector(???);
if(optionImage) {
  // Yes! We've found it!
}
</code></pre>
</div>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Mała refaktoryzacja</h4>
<p>Możesz zauważyć, że po dodaniu Twojego nowego kodu, masz już dwa ify, które sprawdzają ten sam dłuższy warunek.</p>
<pre><code class="language-js">if(formData[paramId] &amp;&amp; formData[paramId].includes(optionId)) {
</code></pre>
<p>Jeśli chcesz, możesz wyciągnąć go do jednej stałej, a potem po prostu wykorzystać w obu miejscach.</p>
<pre><code class="language-js">const optionSelected = formData[paramId] &amp;&amp; formData[paramId].includes(optionId);
if(optionSelected) {

...

if(optionImage) {
  if(optionSelected) {
    ...
  }
}
</code></pre>
</div>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/604292" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/92e77d62ed8639e3401872633321cce0e15fea21">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1970" class="card submodule completed" data-bootcamp-user-submodule-id="604293" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.8. <span>Podsumowanie</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>W tym module udało nam się zaimplementować prawie wszystkie funkcjonalności dotyczące wyłącznie produktów w menu:</p>
<ul>
<li>generujemy elementy DOM produktu w menu pizzerii,</li>
<li>dodajemy obsługę akordeonu, który pokazuje opcje co najwyżej jednego produktu,</li>
<li>obliczamy cenę produktu w zależności od wybranych opcji,</li>
<li>wyświetlamy warstwowe ilustracje, które odzwierciedlają wybrane opcje produktu.</li>
</ul>
<p>Na kolejny zostawimy sobie jeszcze jedną:</p>
<ul>
<li>umożliwiamy wybranie kilku sztuk produktu, przeliczając jego cenę.</li>
</ul>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/table.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/table-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/table.png 2x" class="img-inline img-left">
<p>Efekt naszej pracy to jedno. Ważniejsze jest to, że nauczyliśmy się tworzyć klasy oraz wykorzystywać ich instancje. Dzięki temu nasz kod jest dużo bardziej uporządkowany i pozwala nam na dalszą stosunkowo bezbolesną rozbudowę tego projektu.</p>
<p>W następnym module, oprócz opcji wyboru liczby sztuk, zajmiemy się również implementacją funkcjonalności koszyka oraz komunikacją z serwerem! W ten sposób umożliwimy wysyłanie zamówienia i zapisywanie go na serwerze.</p>
<p>Ten moduł na pewno mocno Cię wymęczył, ale nie przejmuj się na zapas. W dzisiejszych czasach tego typu duże projekty raczej wykonuje się przy użyciu większych frameworków czy bibliotek, np. Reacta czy Angulara. Robienie tego w czystym JS, to czasami spora katorga. Dlaczego więc my pozostajemy przy czystym JS-ie? Dlatego, że w taki sposób znacznie więcej się nauczysz. Możesz więc spodziewać się wzmożonej pracy w najbliższych tygodniach, ale... to nie znaczy, że zawsze tak będzie. Niedługo podobne projekty będziemy wykonywać już z pomocą Reacta i okaże się, że będzie to znacznie prostsze. Dlatego i poziom trudności też znacznie się zmniejszy. Zaufaj nam, warto wytrzymać tę próbę ognia, wyjdziemy z niej mocniejsi! :)</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1971" class="card submodule completed" data-bootcamp-user-submodule-id="604294" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">8.9. <span>Quiz powt&oacute;rkowy</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Na koniec tego modułu przygotowaliśmy dla Ciebie quiz powtórkowy. Pomoże Ci on powtórzyć wiedzę z poprzednich części.</p>
<p>Odpowiedzi tego quizu nie są nigdzie zapisywane, więc są tylko do Twojej wiadomości. Ten quiz ma Ci posłużyć jako pomoc w nauce – dlatego pod każdym pytaniem znajdziesz guzik, który sprawdzi poprawność Twoich odpowiedzi oraz poda Ci wyjaśnienie zagadnienia poruszanego w tym pytaniu.</p>

        <div class='kodilla-quiz'>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>1.</em> O czym należy pamiętać przy podłączaniu pluginów?</p>

        </header>
        <ol type='a' class='answers' data-correct='1,2,7'>
          <li><label><input type='checkbox'> pliki CSS pluginu umieszczamy w katalogu <code>sass</code>, a pliki JS – w <code>js</code></label></li>
<li><label><input type='checkbox'> wszystkie pliki pluginu umieszczamy w katalogu <code>vendor</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki stylów (CSS) w <code>&lt;head&gt;</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki stylów (CSS) na początku <code>&lt;body&gt;</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki stylów (CSS) na końcu <code>&lt;body&gt;</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki skryptów (JS) w <code>&lt;head&gt;</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki skryptów (JS) na początku <code>&lt;body&gt;</code></label></li>
<li><label><input type='checkbox'> w plikach HTML podłączamy pliki skryptów (JS) na końcu <code>&lt;body&gt;</code></label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>Umieszczenie wszystkich plików pluginów w katalogu <code>vendor</code> pozwala nam na oddzielenie tzw. bibliotek, czyli kodu, z którego będziemy korzystać, ale nie będziemy go modyfikować. Dzięki temu łatwiej będzie zaktualizować plugin do nowej wersji. Ponadto, katalog <code>css</code> będzie zawierał wyłącznie pliki skonwertowane z plików SCSS w katalogu <code>sass</code>.</p>
<p>W plikach HTML style podłączamy w <code>&lt;head&gt;</code>, a by jak najszybciej rozpoczęło się ich pobieranie. Dzięki temu strona szybciej się wyświetli. W przypadku plików JS jest odwrotnie – chcemy, aby wczytały się nieco później, i nie opóźniały wyświetlenia strony. Dlatego podłączamy je tuż przed zamknięciem <code>&lt;/body&gt;</code>.</p>

          </div>
        </div>
      
        </article>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>2.</em> Używanie szablonów HTML, np. Mustache czy Handlebars, pozwala nam na:</p>

        </header>
        <ol type='a' class='answers' data-correct='1,2,4'>
          <li><label><input type='checkbox'> przyspieszenie działania strony</label></li>
<li><label><input type='checkbox'> wielokrotne użycie tego samego kodu szablonu</label></li>
<li><label><input type='checkbox'> oddzielenie kodu HTML i treści wyświetlanych na stronie od kodu JS</label></li>
<li><label><input type='checkbox'> automatyczne tworzenie innych wersji językowych strony</label></li>
<li><label><input type='checkbox'> wygenerowanie kodu HTML w postaci tekstu, a następnie wstawienie go na stronie</label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>Szablony HTML są bardzo przydatnym narzędziem. Ich główną rolą jest uniknięcie umieszczania kodu HTML i treści wyświetlanych na stronie wewnątrz plików JS. Pozwala też na wielokrotne wykorzystanie szablonów, dzięki czemu można uniknąć powtarzania kodu.</p>
<p>Zastosowanie szablonów pozwala też na łatwiejsze – ale nie automatyczne – tworzenie różnych wersji językowych strony. Wynika to z tego, że cała treść wyświetlana na stronie znajduje się w pliku HTML, więc do wszystkich wersji językowych możemy używać tego samego kodu JS.</p>
<p>Prędkość działania strony z szablonami HTML zależy od sposobu ich implementacji. Zawartość kodu HTML wyświetli się szybciej, ale za to treści wyświetlane przy pomocy szablonów wyświetlą się później. Z tego względu nie możemy jednoznacznie powiedzieć, że wykorzystanie szablonów przyspiesza działanie strony – ale świadome ich zastosowanie może w tym pomóc.</p>

          </div>
        </div>
      
        </article>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>3.</em> Wybierz prawdziwe zdania dotyczące programowania obiektowego:</p>

        </header>
        <ol type='a' class='answers' data-correct='0,3,5,7'>
          <li><label><input type='checkbox'> klasa to <em>szablon/schemat</em>, wedle którego możemy tworzyć poszczególne obiekty</label></li>
<li><label><input type='checkbox'> instancja to <em>szablon</em>, wedle którego możemy tworzyć poszczególne obiekty</label></li>
<li><label><input type='checkbox'> nową klasę tworzymy za pomocą <code>new NazwaKlasy();</code></label></li>
<li><label><input type='checkbox'> nową instancję tworzymy za pomocą <code>new NazwaKlasy();</code></label></li>
<li><label><input type='checkbox'> konstruktor jest funkcją wykonywaną w momencie stworzenia nowej klasy</label></li>
<li><label><input type='checkbox'> konstruktor jest funkcją wykonywaną w momencie stworzenia nowej instancji</label></li>
<li><label><input type='checkbox'> kiedy bezpośrednio w metodzie instancji używamy <code>this</code>, wskazuje on na klasę</label></li>
<li><label><input type='checkbox'> kiedy bezpośrednio w metodzie instancji używamy <code>this</code>, wskazuje on właśnie na tę instancję</label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>Pojęcia klasy i instancji łatwo jest pomylić, dlatego warto je sobie przypomnieć.</p>
<p>Klasa jest szablonem, wedle którego możemy tworzyć obiekty, czyli instancje tej klasy. Klasa może posiadać metody, które będą wspólne dla wszystkich instancji tej klasy.</p>
<p>Instancję klasy tworzymy za pomocą słowa kluczowego <code>new</code>. W momencie stworzenia nowej instancji zostanie uruchomiony konstruktor tej klasy. Zarówno w konstruktorze, jak i w pozostałych metodach, słowo <code>this</code> wskazuje na daną instancję.</p>

          </div>
        </div>
      
        </article>
      
        </div>
        
<style>
  .kodilla-quiz .question {
    margin-bottom: 1.5em;
  }
  .kodilla-quiz .explanation {
    display: none;
  }
  .kodilla-quiz li>label {
    display: inline-block;
    padding-top: 1px;
    vertical-align: top;
  }
</style>
<script>
  if(typeof initQuizzes == 'undefined'){
    function initQuizzes(){
      var types = {
        'multiple-choice': initMultipleChoice,
      };

      var questions = document.querySelectorAll('.kodilla-quiz .question');

      for(var i=0; i<questions.length; i++){
        var question = questions[i];
        var initFunc = types[question.dataset.type];

        if(typeof(initFunc) != 'undefined' && !question.classList.contains('initiated')){
          question.classList.add('initiated');
          initFunc(question);
        }
      }
    }

    function initMultipleChoice(question){
      var answers = question.querySelector('.answers');
      var inputs = answers.querySelectorAll('input');
      var buttons = question.querySelector('.buttons');
      var buttonOK = buttons.querySelector('.button-ok');
      var explanation = question.querySelector('.explanation');
      var correct = question.querySelector('[data-correct]').dataset.correct.split(',');

      buttonOK.addEventListener('click', function(e){
        e.preventDefault();

        var inputsChecked = answers.querySelectorAll('input:checked');
        if(inputsChecked.length == 0){
          alert('Wybierz co najmniej jedna odpowiedź');
          return;
        }

        correct.forEach(function(index){
          inputs[index].parentNode.parentNode.classList.add('text-success', 'text-bold');
        });

        for (var i = 0; i < inputs.length; i++) {
          var input = inputs[i];
          var li = input.parentNode.parentNode;
          input.setAttribute('disabled', true);
          
          if(input.checked){
            li.classList.add('text-bold');
            
            if(!li.classList.contains('text-success')){
              li.classList.add('text-danger');
            }
          }

        }
        
        if(explanation) explanation.style.display = 'block';
        buttons.setAttribute('hidden', true);
      });
    }
  }
  initQuizzes();
</script>

      
                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                            </main>
        </div>
    </section>
</main>
;
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<script type="text/x-translation" data-translation-name="SentBootcampLinkReviewFormMessage">Wysłano link do zatwierdzenia</script>
    <div id="alerts">
    <div class="alert alert-danger" role="alert">
        <i class="fa fa-exclamation" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                        </ul>
    </div>
    <div class="alert alert-success" role="alert">
        <i class="fa fa-check" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                </ul>
    </div>
    <div class="alert alert-warning" role="alert">
        <i class="fa fa-warning" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                </ul>
    </div>
    <div class="alert alert-info" role="alert">
        <i class="fa fa-info" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                    </ul>
    </div>
    <div class="container">
        <div class="alert alert-notify" role="alert">
            <i class="fa fa-info" aria-hidden="true"></i>
            <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
                <span aria-hidden="true">&times;</span>
                <span class="sr-only">Zamknij</span>
            </button>
            <ul>
                            </ul>
        </div>
    </div>
</div>
    <div class="modal fade informator-modal" id="informator" tabindex="-1" role="dialog" aria-labelledby="informatorModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <img src="https://kodilla.com/static/img/logo-menu.png?00000" alt="Logo Kodilla" class="brand-logo">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <i class="fa fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body content-container">
                <h3>Zam&oacute;w szczeg&oacute;łowy informator</h3>
                <form class="row js-ajax-form" data-view-class="InformatorForm" action="https://kodilla.com/pl/download-informator" method="post">
                    <input type="hidden" name="ga-pobieranie-informatora-z-modala" value="wypelnienie">
                    <input type="hidden" name="tags[0]" value="informator">
                                        <div class="user-data-container">
                        <input type="text" class="form-control" name="firstname" placeholder="Imię">
                        <input type="text" class="form-control" name="surname" placeholder="Nazwisko">
                    </div>
                    <div class="user-data-container">
                        <input type="email" class="form-control" name="email" placeholder="Email" required/>
                        <input type="tel" class="form-control" name="phone" placeholder="Numer telefonu" pattern="^([\+][0-9]{1,3}([ \.\-])?)?([\(]{1}[0-9]{3}[\)])?([0-9 \.\-]{1,15})$" title="Wpisz poprawny numer telefonu, np. 453 674 897" minlength="9" maxlength="15" data-custom-message="Wpisz poprawny numer telefonu, np. 453 674 897">
                    </div>
                    <div class="terms-box">
                        <label>
                            <input name="accept_terms" value="true" data-custom-message="Prosimy o zaakceptowanie regulaminu" type="checkbox" class="form-control input-checkbox" required>
                            <span>Akceptuję <a target="_blank" href="https://kodilla.com/pl/regulamin">regulamin</a>  i nie wnoszę zastrzeżeń</span>
                        </label>
                    </div>
                    <div class="personal-terms-box">
                        <label>
                            <input name="accept_marketing" value="true" data-custom-message="Jeśli chcesz otrzymać dostęp do materiał&oacute;w, konieczna jest akceptacja obydwu zg&oacute;d" type="checkbox" class="form-control input-checkbox" required>
                            <span>Chcę otrzymywać newsletter, informacje o promocjach i produktach dostępnych w Kodilla.
                                <span class="details-button" data-action="show-details" data-identifier="personal-terms-details-informator">Czytaj więcej</span>
                                <span class="display-none" data-identifier="personal-terms-details-informator">Wyrażam zgodę na otrzymywanie informacji handlowych od Kodilla na podany przeze mnie adres e-mail. Zgoda jest dobrowolna, jednakże niezbędna do otrzymywania informacji o produktach, promocjach i o tym, co u nas słychać. Administratorem danych jest Codemy S.A. z siedzibą we Wrocławiu, Plac Powstańc&oacute;w Śląskich 13/4. Mam prawo cofnąć zgodę w każdym czasie, jednak wtedy nie będę otrzymywać informacji. Dane mogą być przetwarzane pomimo cofnięcia zgody wyłącznie w takim zakresie i celu, w jakim ich przetwarzanie jest niezbędne do ustalenia, dochodzenia lub obrony roszczeń Administratora w związku z udzieloną zgodą. Mam prawo dostępu do danych, sprostowania, usunięcia, ograniczenia przetwarzania, prawo wniesienia sprzeciwu, skargi do organu nadzorczego i przeniesienia danych. Szczeg&oacute;łowe informacje znajdują się na stronie kodilla.com, zakładka &quot;Polityka Prywatności&quot;.</span>
                            </span>
                        </label>
                    </div>
                    <div class="display-none">
                        <input type="text" name="myName" value="">
                    </div>
                    <div class="">
                        <button type="submit" class="btn btn-primary">
                            Pobierz Informator
                            <i data-role="loading-icon" class="fa fa-spinner fa-spin fa-1x fa-fw display-none"></i>
                        </button>
                    </div>
                </form>
                <a href="https://kodilla.com/pl/informator" id="informator-link" target="_blank" class="display-none"></a>
            </div>
            <div class="modal-footer">
                <p>Pobranie informatora do niczego nie zobowiązuje</p>
            </div>
        </div>
    </div>
</div>
<footer class="site-footer">
                <section class="footer-lower">
            <nav class="container">
                <a class="navbar-img" href="https://kodilla.com/pl">
                    <svg id="kodilla-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 168 29.553" width="168" height="30">
                        <defs>
                            <style>
                                .footer-logo-fill {
                                    fill: #fff;
                                }
                            </style>
                        </defs>
                        <g id="Group_1" data-name="Group 1" transform="translate(23.59)">
                            <path id="KODILLA_copy_5_1_" class="footer-logo-fill" d="M78.058,0a14.758,14.758,0,1,0,.075,0Zm0,23.739a8.939,8.939,0,0,1-8.944-8.907V14.8c0-4.957,4.584-.708,8.907-.708,4.919,0,9.019-4.211,9.019.708a8.978,8.978,0,0,1-8.981,8.944Z" transform="translate(-63.3)"/>
                            <ellipse id="eye_copy_4_1_" class="footer-logo-fill" cx="3.876" cy="3.876" rx="3.876" ry="3.876" transform="translate(9.462 13.2) rotate(-28.436)"/>
                        </g>
                        <path id="Path_1" data-name="Path 1" class="footer-logo-fill" d="M0,29.819V.9H6.671V13.347L17.255.9h7.491L13.938,13.794,25.491,29.819h-7.6l-8.2-11.665-3.019,3.13v8.5H0Z" transform="translate(0 -0.565)"/>
                        <path id="Path_2" data-name="Path 2" class="footer-logo-fill" d="M151.4,29.819V.9h10.807a15.515,15.515,0,0,1,6.261,1.155,12.966,12.966,0,0,1,4.509,3.093A12.918,12.918,0,0,1,175.7,9.732a17.245,17.245,0,0,1,.932,5.59,16.821,16.821,0,0,1-1.006,5.963,12.227,12.227,0,0,1-2.907,4.547,13.484,13.484,0,0,1-4.547,2.944,15.964,15.964,0,0,1-5.925,1.043Zm18.41-14.5a11.274,11.274,0,0,0-.522-3.466,7.723,7.723,0,0,0-1.491-2.72,6.616,6.616,0,0,0-2.385-1.752,8.055,8.055,0,0,0-3.205-.6h-4.1v17.18h4.1a7.985,7.985,0,0,0,3.242-.634,6.8,6.8,0,0,0,2.385-1.826,8.286,8.286,0,0,0,1.453-2.72A11.634,11.634,0,0,0,169.81,15.322Z" transform="translate(-94.978 -0.565)"/>
                        <path id="Path_3" data-name="Path 3" class="footer-logo-fill" d="M228.3,29.819V.9h6.671V29.819Z" transform="translate(-143.219 -0.565)"/>
                        <path id="Path_4" data-name="Path 4" class="footer-logo-fill" d="M259.9,29.819V.9h6.671V23.968h14.012v5.851Z" transform="translate(-163.043 -0.565)"/>
                        <path id="Path_5" data-name="Path 5" class="footer-logo-fill" d="M327.371,23.931V.9H320.7V29.819h18.522l2.124-5.851H327.371Z" transform="translate(-201.185 -0.565)"/>
                        <path id="Path_6" data-name="Path 6" class="footer-logo-fill" d="M388.547.9h6.037L405.13,29.819h-6.857l-2.236-6.484h-9.019l-2.2,6.484H378Zm6.373,17.851L391.528,8.54l-3.466,10.211Z" transform="translate(-237.13 -0.565)"/>
                    </svg>
                </a>
                <ul class="nav">
                    <li>
                        <a href="https://kodilla.com/pl/regulamin" rel="nofollow">Regulamin</a>
                    </li>
                    <li>
                        <a href="https://kodilla.com/pl/polityka-prywatnosci" rel="nofollow">Polityka prywatności</a>
                    </li>
                    <li class="nav-item">&copy; 2021 Kodilla</li>
                </ul>
            </nav>
        </section>
    </footer>

<!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KN2WWBH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <script src="https://kodilla.com/static/js/libs/jquery-2.1.4.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/js.cookie-2.1.0.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/jquery-dateFormat.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/bootstrap.min.js?00000"></script>
<script>
    (function () {
        $(document).ready(function () {
            if (window.location.hash === '#informator-modal') {
                showInformator();
            }
        });

        $('[data-action="show-modal"]').click(function() {
            showInformator();
        });

        function showInformator() {
            $('#informator').modal('show');
        }
    })();
</script>
<script src="https://kodilla.com/build/minified/js/fb-0370c8f03e.js" async></script>
<script src="https://kodilla.com/build/minified/js/call-us-d1ed4dfa39.js"></script>
<script>
    if (document.querySelector('main.editor')) {
        document.querySelector('body').classList.add('editor');
    }
</script>

<script type="text/javascript">
    (function(e,t,o,n,p,r,i){e.visitorGlobalObjectAlias=n;e[e.visitorGlobalObjectAlias]=e[e.visitorGlobalObjectAlias]||function(){(e[e.visitorGlobalObjectAlias].q=e[e.visitorGlobalObjectAlias].q||[]).push(arguments)};e[e.visitorGlobalObjectAlias].l=(new Date).getTime();r=t.createElement("script");r.src=o;r.async=true;i=t.getElementsByTagName("script")[0];i.parentNode.insertBefore(r,i)})(window,document,"https://diffuser-cdn.app-us1.com/diffuser/diffuser.js","vgo");
    vgo('setAccount', '649095895');
    vgo('setTrackByDefault', true);

    vgo('process');
</script>

        <script src="https://kodilla.com/static/js/libs/underscore-min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-relational.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-super.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/handlebars-v4.0.5.min.js?00000"></script>
<script src="https://kodilla.com/build/minified/js/extends/handlebars-ifCond-139a2339f7.js"></script>
<script src="https://kodilla.com/build/minified/js/application-0dcfdc1306.js"></script>
<script src="https://kodilla.com/build/minified/js/main-cf3b73d734.js"></script>
<script src="https://kodilla.com/build/minified/js/views/settings-5fc44a761b.js"></script>
<script src="https://kodilla.com/build/minified/js/views/delete-account-da2b3de486.js"></script>
<script type="text/x-translation" data-translation-name="checkAccountDeleteCalculationMessage">Wynik jest nieprawidłowy</script>
<script src="https://kodilla.com/build/minified/js/helpers/forms-222ea01b08.js"></script>
<script src="https://kodilla.com/build/minified/js/helpers/alerts-66650c3acb.js"></script>
<script>
    App.Views.InpageAlertManager = Backbone.View.extend({
        events: {
            'click [data-alert-type][data-alert-text]': 'showAlert'
        },
        showAlert: function(e) {
            var $el = $(e.currentTarget);
            App.alertsView['show'+$el.data('alertType')]([App.Translations($el.data('alertText'))]);
        }
    });
</script>
<script src="https://kodilla.com/build/minified/js/collections-c07e1162e2.js"></script>
<script src="https://kodilla.com/build/minified/js/models-4e0e4fcffb.js"></script>
<script src="https://kodilla.com/build/minified/js/views/knowledge-base-61f71273c9.js"></script>
<script>
    App.Views.LearningProgram = Backbone.View.extend({
        events: {
            'click [data-technology-desc-expander]' : 'expandTechnologyDesc'
        },

        initialize: function() {
            this.$allTechnologyDesc = this.$el.find('[data-technology-desc]');
            this.$allTechnologyExpanderIcons = this.$el.find('[data-technology-expander-icon]');
        },

        expandTechnologyDesc: function() {
            this.$allTechnologyDesc.each(function(){
                var $desc = $(this);
                $desc.slideToggle('fast');
            });
            this.$allTechnologyExpanderIcons.each(function(){
                var $icon = $(this);
                $icon.toggleClass("fa-minus");
            });
        },
    });
</script>

    <script src="https://kodilla.com/static/js/libs/tether.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/prism.min.js?00000"></script>

    <script src="https://kodilla.com/build/minified/js/views/bootcamp-1522c7c010.js"></script>
    <script src="https://kodilla.com/static/js/libs/jquery.seourl.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/perfect-scrollbar.jquery.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/fancybox/jquery.fancybox.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/moment.timezone.locales.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/bootstrap-datetimepicker.min.js?00000"></script>
    <script type="text/javascript">
        $(document).ready(function() {
            $("a.img-modal-group").fancybox();
        });
    </script>

<div class="modal fade" tabindex="-1" role="dialog" id="call-us-modal">
    <div class="modal-dialog modal-dialog-callus" role="document">
        <div class="modal-content call-modal">
            <div id="call-us-step1">
                <h2>Um&oacute;w się na rozmowę z doradcą Kodilli</h2>
                <p>Krok <span>1/2:</span> Podaj numer telefonu</p>
                <form action="https://kodilla.com/pl/call-center/dates/phone_calls" method="post" id="call-us-form1">
                    <input type="tel" name="phone" id="call-us-input-phone" class="call-center-input" placeholder="731771787">
                    <p class="error-message display-none" id="validation-message-phone">Pole Numer Telefonu jest wymagane. Nieprawidłowy format.</p>
                    <button class="btn btn-success" id="call-us-submit-phone">Zarezerwuj rozmowę</button>
                </form>
                <p id="call-us-counter-holder" style="display: none;">Dzisiaj już  <span id="call-us-counter" class="call-counter" data-url="https://kodilla.com/pl/call-center/counter/phone_calls">-</span> <span id="call-us-counter-text" data-one=" osoba zam&oacute;wiła rozmowę z nami." data-few=" osoby zam&oacute;wiły rozmowę z nami." data-more=" os&oacute;b zam&oacute;wiło rozmowę z nami."></span></p>
                <div class="data-protection">
                    <p>Twój numer telefonu nie będzie wykorzystywany w celach marketingowych ani przekazany dalej. Tylko oddzwonimy. Dane są przetwarzane zgodnie z <a href="/pl/polityka-prywatnosci">Polityką Prywatności</a>.</p>
                </div>
            </div>

            <div id="call-us-step2" style="display: none;">
                <h2>Wybierz dogodny termin i godzinę na rozmowę z doradcą</h2>
                <p>Krok <span>2/2:</span>
                <form action="https://kodilla.com/pl/call-center/step2/phone_calls" method="post" id="call-us-form2">
                    <div class="select-date">
                        <select name="date" id="call-us-input-date">
                        </select>
                        <select name="time" id="call-us-input-time">
                        </select>
                    </div>
                    <button class="btn btn-success" id="call-us-submit-call">Oddzwońcie do mnie!</button>
                </form>
            </div>

            <div id="call-us-step3" style="display: none;">
                <div  class="thanks">
                    <i class="fa fa-check-circle" aria-hidden="true"></i>
                    <h2>Dziękujemy za zamowienie rozmowy! Do usłyszenia w wybranym terminie!</h2>
                </div>
            </div>
        </div>
    </div>
</div>



                <style type="text/css">
    .embeddedServiceHelpButton .helpButton .uiButton {
        background-color: #1EA71C;
        font-family: "Arial", sans-serif;
    }
    .embeddedServiceHelpButton .helpButton .uiButton:focus {
        outline: 1px solid #1EA71C;
    }
</style>
<script>
    function openChat(){
        $('.helpButtonEnabled').trigger('click');
    }
</script>
<script type="text/javascript" src="https://service.force.com/embeddedservice/5.0/esw.min.js"></script>

<script type="text/javascript">
    var initESW = function(gslbBaseURL) {
        let firstName = 'Marek Baberowski'.split(" ")[0];
        let lastName = 'Marek Baberowski'.split(" ")[1];
        console.log(name);
        embedded_svc.settings.displayHelpButton = true;
        embedded_svc.settings.language = '';

        embedded_svc.settings.defaultMinimizedText =  'Skontaktuj się z nami';
        embedded_svc.settings.disabledMinimizedText = ' ';

        embedded_svc.settings.loadingText = 'Ładowanie';
        embedded_svc.settings.storageDomain = 'kodilla.com';

        embedded_svc.settings.prepopulatedPrechatFields = {
            'FirstName': firstName,
            'LastName': lastName,
            'Email': 'm.z.baberowski@gmail.com'
        };
        embedded_svc.settings.offlineSupportMinimizedText = 'Napisz do nas';

        embedded_svc.settings.enabledFeatures = ['LiveAgent'];
        embedded_svc.settings.entryFeature = 'LiveAgent';

        embedded_svc.init(
            'https://kodilla.my.salesforce.com',
            'https://kodillacommunity.force.com',
            gslbBaseURL,
            '00D1i000000VBFH',
            'Support_Kodilla',
            {
                baseLiveAgentContentURL: 'https://c.la1-c2-fra.salesforceliveagent.com/content',
                deploymentId: '5721i00000009s9',
                buttonId: '5731i0000000AJN',
                baseLiveAgentURL: 'https://d.la1-c2-fra.salesforceliveagent.com/chat',
                eswLiveAgentDevName: 'Support_Kodilla',
                isOfflineSupportEnabled: true
            }
        );
    };

    if (!window.embedded_svc) {
        var s = document.createElement('script');
        s.setAttribute('src', 'https://kodilla.my.salesforce.com/embeddedservice/5.0/esw.min.js');
        s.onload = function() {
            initESW(null);
        };
        document.body.appendChild(s);
    } else {
        initESW('https://service.force.com');
    }
</script>
        <div data-role="notifications-wrapper" class="notifications-wrapper"></div>
</body>
</html>