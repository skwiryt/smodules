<!DOCTYPE html>
<html lang=pl class="no-js">
<head>
    <meta name="ahrefs-site-verification" content="c2d3c04b9f125c5b8c98d89f738d343f69d841f035150344a932150235c5639a">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="csrf-token" content="FGlA4RkObUo18UXAEnOqvfNMqmQValvEVBDjQsbF" />

<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="https://kodilla.com/static/img/icons/apple-touch-icon-60x60.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="https://kodilla.com/static/img/icons/apple-touch-icon-76x76.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="https://kodilla.com/static/img/icons/apple-touch-icon-120x120.png?00000">
<link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://kodilla.com/static/img/icons/apple-touch-icon-152x152.png?00000">
<link rel="icon" type="image/png" sizes="32x32" href="https://kodilla.com/static/img/icons/favicon-32x32.png?00000">
<link rel="icon" type="image/png" sizes="96x96" href="https://kodilla.com/static/img/icons/favicon-96x96.png?00000">
<link rel="icon" type="image/png" sizes="16x16" href="https://kodilla.com/static/img/icons/favicon-16x16.png?00000">

    <link rel="canonical" href="https://kodilla.com/pl/bootcamp-module/407/531/5935" />

    <meta name="robots" content="noindex, follow" />
    <title>    Moduł: 9. AJAX i API
</title>
        <script>document.documentElement.classList.remove("no-js")</script>
<script src="https://kodilla.com/static/js/libs/yall.min.js?00000"></script>
<link href="https://kodilla.com/static/css/libs/bootstrap.min.css?00000" rel="stylesheet">
<link href="https://kodilla.com/static/css/libs/font-awesome.min.css?00000" rel="stylesheet">
<link href="https://kodilla.com/build/minified/css/main-b3cf79332c.css" rel="stylesheet" type="text/css">
            
    <link href="https://kodilla.com/static/css/libs/prism.min.css?00000" rel="stylesheet">

    <link href="https://kodilla.com/build/minified/css/bootcamp-6d0888d826.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://kodilla.com/static/css/libs/perfect-scrollbar.css?00000" />
    <link rel="stylesheet" href="https://kodilla.com/static/css/libs/fancybox/jquery.fancybox.min.css?00000" type="text/css" media="screen" />
    <link href="https://kodilla.com/static/css/libs/bootstrap-datetimepicker.min.css?00000">
    <link rel="stylesheet" href="https://uploads.kodilla.com/bootcamp/styles/content.css">
    <script>
    document.addEventListener("DOMContentLoaded", yall);
    window.environment = 'production';
    window.loggedIn = true;
    window.domain = 'https://kodilla.com';
            window.fbAppId = 1449248938627896;
    window.chatService = 'LiveAgent';
    window.useMessenger = window.chatService === 'Messenger';
    window.locale = 'pl';
    window.lang = 'pl';

    window.serverUTC       = 1625590644000;
    window.serverOffset    = 120;
    window.userDate        = new Date();
    window.userUTC         = userDate.getTime();
    window.userOffset      = userDate.getTimezoneOffset() * (-1);
    window.userClockDiff   = userUTC - serverUTC;
    window.diffRounded     = Math.round( userClockDiff / ( 1000 * 60 * 15 ) );
    window.isDifferentZone = ( userOffset - serverOffset !== 0 ) ? 1 : 0;
    window.hasWrongTime    = ( diffRounded !== 0 ) ? 1 : 0;
    window.dateTooltipText = 'Data i godzina są podane dla Twojej strefy czasowej GMT. <br>W razie wątpliwości napisz: <u>support@kodilla.com</u>.';
    window.wrongHourNotice = 'Godzina na Twoim urządzeniu r&oacute;żni się od godziny obowiązującej w strefie czasowej wybranej w ustawieniach Twojego urządzenia.';

    window.PAYU_HASH_ALGORITHM = 'SHA-256';
    window.PAYU_POS_ID = 1429452;
    window.PAYU_MD5_SECOND_KEY = 'f3627be5fab5a4238c8474936f057908';

    var moment = undefined,
        momentReady = function( method, method2, count ){
            var c = ( count ) ? count : 0;

            if      ( isDifferentZone && moment !== undefined ){
                if      ( method ) { method(); }
                else    { return false; }
            }
            else if ( isDifferentZone && moment === undefined ) {
                if ( c < 20 ) {
                    c++;
                    setTimeout( function() { momentReady( method, method2, c ); }
                        , 300 );
                } else {
                    if      ( method2 === true && method )  { method(); }
                    else if ( method2 !== true && method2 ) { method2(); }
                }
            }
            else {
                if      ( method2 === true && method )  { method(); }
                else if ( method2 !== true && method2 ) { method2(); }
                else    { return false; }
            }
        };

    if ( window.isDifferentZone && moment === undefined ) {
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = '/static/js/libs/moment.timezone.locales.min.js?v=2.22.2';
        document.getElementsByTagName("head")[0].appendChild(script);
    }
</script>
<script src="https://cdn.onesignal.com/sdks/OneSignalSDK.js" async=""></script>
<script>
    var OneSignal = window.OneSignal || [];
    OneSignal.push(function() {
        OneSignal.init({
            appId: "92552bb5-b477-4ea2-8260-dba65be198d9",
        });
    });
</script>
<script data-ad-client="ca-pub-9483216428129091" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:2404285,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
    <!-- Facebook Pixel Code -->
    <script>
        !function(f,b,e,v,n,t,s)
        {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
            n.callMethod.apply(n,arguments):n.queue.push(arguments)};
            if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
            n.queue=[];t=b.createElement(e);t.async=!0;
            t.src=v;s=b.getElementsByTagName(e)[0];
            s.parentNode.insertBefore(t,s)}(window, document,'script',
            'https://connect.facebook.net/en_US/fbevents.js');
        fbq('init', 389137334769464 );
        fbq('track', 'PageView');
    </script>
    <!-- End Facebook Pixel Code -->

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-KN2WWBH');</script>
    <!-- End Google Tag Manager -->
    
    </head>
<body class="no-js student ">
<!-- Facebook Pixel Code -->
<noscript><img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=389137334769464&ev=PageView&noscript=1"/></noscript>
<!-- End Facebook Pixel Code -->
<script>
    document.getElementsByTagName('body')[0].classList.remove('no-js');
    if ( window.isDifferentZone ) {
        document.querySelector('body').classList.add('time-conversion-applied');
    }
    if ( window.hasWrongTime ) {
        document.querySelector('body').classList.add('wrong-hour');
    }
</script>

    <nav class="navbar-main hidden-sm-down dark navbar">
    <div class="nav-container">
        <div class="navbar-header clearfix">
            <button class="navbar-toggler hidden-md-up pull-right" type="button" data-toggle="collapse" data-target="#collapsingNavbarUpper"><i class="fa fa-bars"></i></button>
        </div>
        <div class="collapse navbar-toggleable-sm container" id="collapsingNavbarUpper">
            <ul class="nav navbar-nav navbar-nav-left">
                                    <li class="nav-item nav-contact">
    <span>Skontaktuj się z nami:</span>
    <a href="mailto:support@kodilla.com">
        <i class="fa fa-envelope-o"></i>
        support@kodilla.com
    </a>
    <span>lub</span>
    <a href="javascript:openChat();">
        <i class="fa fa-comments"></i>
        porozmawiaj na czacie
    </a>
</li>
                                </ul>
            <ul class="nav navbar-nav pull-right">
                                <li class="nav-item">
                    <a href="https://kodilla.com/pl/informator" class="nav-link" target="_blank">
        Informator
    </a>
                </li>
                <li class="nav-item hidden-sm-down">
    <a href="https://kodilla.com/pl/account" class="nav-link">Konto</a>
</li>
        <li class="nav-item">
    <a class="analytics-track nav-link nav-link-accent" data-event="account_logout" href="https://kodilla.com/pl/sign-out">Wyloguj</a>
</li>
                            </ul>
        </div>
    </div>
</nav>
<nav class="navbar-main light navbar">
    <div class="container clearfix">
        <a class="navbar-brand"  href="https://kodilla.com/pl">
            <img src="https://kodilla.com/static/img/kodilla-nav-logo.svg?00000" alt="Kodilla - szkoła programowania">
        </a>
        <span class="contact-us-button-container"></span>
        <button class="navbar-toggler pull-right collapsed" type="button" data-toggle="collapse" data-target="#navbar-main">
            <i class="fa fa-bars navbar-ico-open"></i>
            <i class="fa fa-times navbar-ico-close"></i>
        </button>
        <ul id="navbar-main" class="nav navbar-nav pull-right collapse">
            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Szkolenia Bootcamp
    </a>
    <ul class="bootcamp-list">
                    <li class="list-sub list-sub-fe">
                <img src="https://kodilla.com/static/img/svg/menu_fer.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_fer_logo">
                <a href="https://kodilla.com/pl/bootcamp/front-end">
                    <h4 class="bootcamp-name">Front-end: React</h4>
                    <p>Naucz się tworzyć front-end aplikacji w 4 miesiące</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_wd.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_wd_logo">
                <a href="https://kodilla.com/pl/bootcamp/webdeveloper?type=wdp">
                    <h4 class="bootcamp-name">Web Developer</h4>
                    <p>Naucz&nbsp;się tworzyć aplikacje internetowe od&nbsp;podstaw</p>
                    <span class="bootcamp-label">FRONT-END i BACK-END</span>
                </a>
            </li>

            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_java.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_java_logo">
                <a href="https://kodilla.com/pl/bootcamp/java?type=jdp">
                    <h4 class="bootcamp-name">Java Developer</h4>
                    <p>Poznaj najpopularniejszy na&nbsp;świecie język programowania od&nbsp;zera</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_python.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_python_logo">
                <a href="https://kodilla.com/pl/bootcamp/python">
                    <h4 class="bootcamp-name">Python Developer</h4>
                    <p>Zdobądź kompetencje do tworzenia rozwiązań webowych</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_tester.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_tester_logo">
                <a href="https://kodilla.com/pl/bootcamp/tester-automatyzujacy">
                    <h4 class="bootcamp-name">Tester Automatyzujący</h4>
                    <p>Poznaj podstawy testowania automatycznego w Javie</p>
                </a>
            </li>
            <li class="list-sub">
                <img src="https://kodilla.com/static/img/svg/menu_game.svg?00000" class="menu-svg" width="32px" height="32px" title="menu_mage_logo">
                <a href="https://kodilla.com/pl/bootcamp/game-dev">
                    <h4 class="bootcamp-name">Mobile Game Developer</h4>
                    <p>Zdobądź kompetencje do tworzenia gier</p>
                    <span class="bootcamp-label">nowość</span>
                </a>
            </li>
            </ul>
</li>

                        <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Szkolenia Pro
    </a>
    <ul>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/mikroserwisy" class="nav-link">Mikroserwisy w Javie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/spring-hibernate" class="nav-link">Spring i Hibernate</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/wielowatkowosc" class="nav-link">Wielowątkowość w Javie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/django" class="nav-link">Aplikacje webowe z Django</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/wizualizacja-danych" class="nav-link">Analiza danych w Pythonie</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/machine-learning" class="nav-link">Podstawy Machine Learning</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/bigdata-pyspark" class="nav-link">Big Data z PySpark</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/automatyzacja-testow" class="nav-link">Automatyzacja test&oacute;w</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/vanilla-js" class="nav-link">Advanced Vanilla JS</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/typescript" class="nav-link">TypeScript - kurs praktyczny</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/vue3" class="nav-link">Vue3 - kompletny przewodnik</a></li>
        <li><a href="https://kodilla.com/pl/szkolenia-pro/zaawansowany-backend" class="nav-link">Backend zaawansowany</a></li>
    </ul>
</li>
            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        Strefa kursanta
    </a>
    <ul>
                    <li><a href="https://kodilla.com/pl/bootcamp-dashboard/407" class="nav-link">Bootcamp WD PLUS 2020-12</a></li>
                    <li><a class="nav-link" href="https://kodilla.com/pl/kursy">Samodzielne kursy</a></li>
                    <li><a class="nav-link" href="https://chat.kodilla.com" target="_blank">Komunikator</a></li>
                    <li><a class="nav-link" href="https://kodilla.com/pl/projects">Moje projekty</a></li>
    </ul>
</li>
                            <li class="nav-item hidden-sm-down">
    <a class="dropdown-toggle nav-link">
        O nas
    </a>
    <ul class="about-us">
        <li><a href="https://kodilla.com/pl/mentorzy" class="nav-link">Mentorzy</a></li>
        <li><a href="https://kodilla.com/pl/zespol" class="nav-link">Zesp&oacute;ł Kodilli</a></li>
        <li><a href="https://kodilla.com/pl/o-nas" class="nav-link">O firmie</a></li>
    </ul>
</li>
                                                                    <li class="nav-item hidden-md-up nav-group">
    <span class="mobile-menu-separator">Szkolenia Bootcamp</span>
    <ul>
                    <li class="nav-item list-sub-fe">
                <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/front-end">Bootcamp Front-end: React
                </a>
            </li>
                <li class="nav-item">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/webdeveloper">Bootcamp Web Developer
                <span class="bootcamp-label">FRONT-END i BACK-END</span>
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="https://kodilla.com/pl/bootcamp/java">Bootcamp Java</a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/tester-automatyzuj%C4%85cy">Bootcamp Tester Automatyzujący
            </a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/python">Python Developer
            </a>
        </li>
        <li class="nav-item list-sub-fe">
            <a class="nav-link nav-link-with-label" href="https://kodilla.com/pl/bootcamp/game-dev">Mobile Game Developer
                <span class="bootcamp-label">nowość</span>
            </a>
        </li>
    </ul>
</li>
<li class="nav-item hidden-md-up nav-group">
    <a class="nav-link-bold" href="https://kodilla.com/pl/szkolenia-pro">Szkolenia Pro</a>
</li>
            <li class="nav-item hidden-md-up nav-group">
            <span class="mobile-menu-separator">Strefa kursanta</span>
            <ul>
                <li class="nav-item ">
                                            <a class="nav-link" href="https://kodilla.com/pl/bootcamp-dashboard/407">
                            Bootcamp   WD PLUS 2020-12
                        </a>
                                    </li>
                <li class="nav-item ">
                    <a class="nav-link" href="https://kodilla.com/pl/kursy">Samodzielne kursy</a>
                </li>
                                    <li class="nav-item ">
                        <a class="nav-link" href="https://chat.kodilla.com" target="_blank">Komunikator</a>
                    </li>
                                <li class="nav-item">
                    <a class="nav-link" href="https://kodilla.com/pl/projects">Moje projekty</a>
                </li>
            </ul>
        </li>
    
        
            <li class="nav-item hidden-md-up nav-group">
            <span class="mobile-menu-separator">O nas</span>
            <ul>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/mentorzy" class="nav-link">Mentorzy</a>
                </li>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/zespol" class="nav-link">Zesp&oacute;ł Kodilli</a>
                </li>
                <li class="nav-item">
                    <a href="https://kodilla.com/pl/o-nas" class="nav-link">O firmie</a>
                </li>
            </ul>
        </li>
    
<li class="nav-item hidden-md-up nav-group">
    <span class="mobile-menu-separator">Pozostałe</span>
    <ul>
                                        
        <li class="nav-item">
            <a href="https://kodilla.com/pl/informator" class="nav-link" target="_blank">
        Informator
    </a>
        </li>
    </ul>

</li>

    <li class="nav-item hidden-md-up">
        <a class="nav-link" href="https://kodilla.com/pl/account">Konto</a>
    </li>
    <li class="nav-item hidden-md-up">
        <a class="nav-link analytics-track" data-event="account_logout" href="https://kodilla.com/pl/sign-out">Wyloguj</a>
    </li>

        
    <li class="nav-item hidden-md-up nav-group">
        <span class="mobile-menu-separator">Skontaktuj się z nami</span>
        <ul>
            <li class="nav-item">
                <a href="mailto:support@kodilla.com" class="nav-link">
                    <i class="fa fa-envelope-o"></i>
                    support@kodilla.com
                </a>
            </li>
            <li class="nav-item">
                <a href="javascript:openChat();" class="nav-link">
                    <i class="fa fa-comments"></i>
                    <span>Porozmawiaj na czacie</span>
                </a>
            </li>
        </ul>
    </li>
        </ul>
    </div>
</nav>
<main class="bootcamp module page-height-fix" id="bootcamp-module">
    <div class="aside-toggle hidden-md-up">
        <button class="navbar-toggler pull-left collapsed" type="button" data-toggle="collapse" data-target="#aside-sticky" aria-expanded="false">
            <i class="fa fa-bars navbar-ico-open"></i>
            <i class="fa fa-times navbar-ico-close"></i>
        </button>
    </div>
    <div class="table-of-contents aside-sticky collapsed collapse" id="aside-sticky">
        <section class="container">
            <div class="row">
                <aside class="module-nav col-md-4 col-md-offset-8">
                    <section class="card">
                        <div class="card-header">
                            <h4 class="card-title">Spis treści modułu</h4>
                        </div>
                        <ul class="list-group list-group-flush">
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1972" class="clearfix">
                                    <p>9.1. Nowa klasa &ndash; widget ilości</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1973" class="clearfix">
                                    <p>9.2. Nowe funkcjonalności projektu</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1974" class="clearfix">
                                    <p>9.3. Cart &ndash; klasa koszyka</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1975" class="clearfix">
                                    <p>9.4. Dodawanie produkt&oacute;w do koszyka</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1976" class="clearfix">
                                    <p>9.5. CartProduct &ndash; klasa pozycji w koszyku</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1977" class="clearfix">
                                    <p>9.6. Usuwanie produktu z koszyka</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1978" class="clearfix">
                                    <p>9.7. AJAX i API &ndash; wprowadzenie</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1979" class="clearfix">
                                    <p>9.8. Pobieranie listy produkt&oacute;w</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1980" class="clearfix">
                                    <p>9.9. Wysyłanie zam&oacute;wienia do API</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1981" class="clearfix">
                                    <p>9.10. Podsumowanie</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                        <li class="list-group-item completed">
                                <a href="#submodule-1982" class="clearfix">
                                    <p>9.11. Quiz powt&oacute;rkowy</p>
                                    <i class="fa fa-check-circle-o"></i>
                                    <i class="fa fa-play-circle-o"></i>
                                    <i class="fa fa-send-o"></i>
                                    <i class="fa fa-exclamation-circle"></i>
                                </a>
                            </li>
                                                    </ul>
                        <div class="card-block text-center">
                                                                                                <a href="https://kodilla.com/pl/bootcamp-dashboard/407">Powr&oacute;t do dashboardu</a>
                                                                                    </div>
                    </section>
                </aside>
            </div>
        </section>
    </div>
    <section class="container module-content">
        <div class="row">
            <main class="col-md-8">
                <section class="card">
                    <div class="card-block module-header clearfix  completed ">
                        <h1 class="card-title">9. AJAX i API</h1>
                                                <i class="fa fa-bookmark fa-3x" aria-hidden="true"></i>
                    </div>
                                        <div class="card-block challenge">
                        <h3>Wyzwania:</h3>
                        <ul>
<li>dodasz możliwość zmiany liczby sztuk produktu,</li>
<li>dodasz obsługę koszyka na stronie pizzerii,</li>
<li>poznasz zagadnienia AJAX i API,</li>
<li>umożliwisz zapisanie zamówienia w API.</li>
</ul>
<h3>Wstęp</h3>
<p>W tym module nadal będziemy zajmować się naszą stroną pizzerii. Zaczniemy od dodania wspomnianej już wcześniej funkcjonalności zmiany liczby sztuk w produkcie. Kiedy to zrobimy, przejdziemy do funkcjonalności koszyka. Zapowiada się pracowicie.</p>

                    </div>
                                    </section>
                                    
                <section id="submodule-1972" class="card submodule completed" data-bootcamp-user-submodule-id="607286" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.1. <span>Nowa klasa &ndash; widget ilości</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Zajmiemy się teraz widgetem wyboru ilości produktu, jednak tym razem nie będzie to kolejna metoda klasy <code>Product</code>, a nowa klasa! Dlaczego?</p>
<p>Cała idea OOP opiera się na tym, aby oddzielać od siebie grupy funkcjonalności. O ile metoda <code>processOrder</code> czy <code>renderInMenu</code> możemy jak najbardziej uznać za takie, które tyczą się konkretnie produktu, to widget ilości już nie. Owszem, będziemy z niego korzystać w klasie <code>Product</code>, ale czy tylko tam? Widget ilości to dość uniwersalna funkcjonalność. Na pewno przyda się również w innych miejscach, chociażby w koszyku. Przecież często widzimy w e-sklepach mechanizm, w którym po dodaniu produktu do koszyka, nadal można zmienić ilość sztuk. A kto wie, może pojawią się jeszcze kolejne miejsca, w których taki widget się przyda?</p>
<p>Gdybyśmy zamknęli go w klasie <code>Product</code>, to przy próbie użycia go jeszcze raz, gdzie indziej, zwyczajnie musielibyśmy powielić jego logikę. Jeśli wydzielimy go jednak do osobnej klasy, to bez problemu skorzystamy z jej instancji w produktach, ale i np. koszyku.</p>
<h3>Specyfikacja klasy</h3>
<p>Nowa klasa będzie trochę inna niż <code>Product</code>. Nasza pierwsza klasa otrzymywała w konstruktorze informacje o nazwie i strukturze produktu, ale resztę robiła już sama, np. renderowanie reprezentacji produktu w HTML było już jej rolą. Podobnie jak zdynamizowanie formularza, aby zmiany opcji faktycznie przeliczały cenę. W naszej nowej klasie (nazwiemy ją <code>AmountWidget</code>) będzie trochę inaczej.</p>
<p>Rolą <code>AmountWidget</code> ma być po prostu nadanie życia inputom liczbowym. Tak, aby można było łatwo i przyjemnie, za pomocą buttonów "+" i "-", zwiększać lub zmniejszać wartość pola. Oczywiście znajdzie się tam również walidacja, tak, aby nie można było wybrać liczby za małej albo za dużej lub wpisać tekstu. Czy jednak będzie zajmować się również tworzeniem samego elementu? Nie. Zwróć uwagę, że przecież input ilości sztuk już na stronie jest. Został wygenerowany przez instancje klasy <code>Product</code>. Nie trzeba go tworzyć od zera.</p>
<p>To duża zmiana, oznacza to bowiem, że <code>AmountWidget</code> nie będzie niczego sam generował. Zamiast tego otrzyma tylko referencję do odpowiedniego elementu jako argument konstruktora, a potem odpowiednio się nim zajmie.</p>
<p>Całość ma działać następująco:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Przy okazji zauważ jeszcze jedną funkcjonalność naszego widgetu. Ewidentnie widzimy, że cena produktu przelicza się każdorazowo przy zmianie ilości sztuk. Oznacza to, że na pewno nasz widget powinien być w stanie informować inne elementy np. instancje <code>Product</code> o zmianie takiej wartości. Tak, aby te miały możliwość zareagowania na to np. ponownym uruchomieniem metody <code>processOrder</code>.</p>
<p>No dobrze, trochę już wiemy, ale trzeba przejść do działania. Od czego zaczniemy?</p>
<p>Wiemy już, że instancje tej klasy nie będą musiały tworzyć własnych elementów DOM, ponieważ zostały one już stworzone przez instancje produktów. W takim razie konstruktor musi tylko otrzymywać odniesienie (referencję) do elementu, w którym widget ma zostać zainicjowany, żeby wiedzieć "na czym" pracować.</p>
<p>Co ważne tym elementem nie będzie sam input, lecz div, w którym takowy input się znajduje. Dlaczego? Bo wraz z inputem potrzebujemy mieć jeszcze dostęp do buttonów "+" i "-". W końcu będą ona dla nas istotne. Zamiast inputu będziemy więc przekazywać cały div:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-02.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-02.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Właśnie na tego typu element konstruktor klasy <code>AmountWidget</code> będzie oczekiwać. Dlatego też na pewno zaczniemy od przygotowania odpowiedniego konstruktora oraz funkcji, która stworzy właściwości z referencjami do trzech elementów otrzymanych w tym divie.</p>
<ol>
<li>inputu z wartością,</li>
<li>linku zmniejszający wartość,</li>
<li>linku zwiększający wartość.</li>
</ol>
<p>Po co nam te referencje? Znasz już ten koncept. Żeby raz, w jednym miejscu, przygotować sobie "skrócony" dostęp do elementów, a potem w innych metodach łatwiej z nich korzystać. Podobnie postąpiliśmy w klasie <code>Product</code>, dodając metodę <code>getElements</code>. Przygotowaliśmy tam referencję, którą następnie wykorzystywaliśmy w innych metodach.</p>
<p>Do naszej klasy na pewno dodamy również metodę informowania instancji produktu o tym, że wartość została zmieniona. Dzięki temu w momencie zmiany zamawianej ilości sztuk, cena produktu będzie mogła się natychmiast przeliczyć na nowo. Nie wchodźmy na razie w szczegóły, jak to zrobić.</p>
<p>Na końcu zajmiemy się dodaniem limitów, dzięki którym wybór ilości sztuk będzie ograniczony do zakresu od <code>1</code> do <code>9</code>.</p>
<h3>Przygotowanie klasy</h3>
<p>Zacznijmy od stworzenia nowej klasy o nazwie <code>AmountWidget</code>, która na początku będzie zawierać wyłącznie konstruktor. Dodaj deklarację tej klasy przed obiektem <code>app</code>.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-19.png" style="width: auto;">
<p>Tak jak mówiliśmy, będzie on oczekiwać na jeden element, referencję do diva z inputem i buttonami.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Zwijanie kodu i komentowanie</h4>
<p>Na tym etapie może Ci już być ciężko z zapamiętaniem, co i gdzie znajduje się w pliku <code>script.js</code>. Niedługo nauczymy się wydzielać klasy do osobnych plików, ale na razie musimy się jeszcze pomęczyć... Dlatego też warto w tym momencie skorzystać z prostszego rozwiązania, zwijania kodu, dostępnego w większości współczesnych edytorów kodu. Zwykle przy najechaniu kursorem na numer linii zobaczysz ikony pozwalające na zwinięcie np. całej funkcji czy metody.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/07.oop/code-folding.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/code-folding.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>W ten sposób możesz zwinąć te metody, którymi w danej chwili się nie zajmujesz, aby uzyskać dużo większą przejrzystość kodu.</p>
<p>Drugą kwestią, która może na tym etapie sprawiać więcej problemów niż dawać korzyści, są użyte przez nas <code>console.log</code>. Jeśli jest ich zbyt wiele, w konsoli będzie sporo komunikatów, pośród których trudno będzie się odnaleźć. Najlepiej będzie w tym momencie znaleźć wszystkie wystąpienia <code>console.log</code> i "zakomentować je", czyli dodać <code>//</code> na początku linii, w której występują. Albo... jeśli zachęciliśmy Cię wcześniej do używania debuggera, w ogóle z nich zrezygnować.</p>
</div>
<p>W porządku. Nasza klasa już istnieje (choć w bardzo ubogiej formie). Aby jednak sprawdzić, czy jakkolwiek działa, trzeba ją wykorzystać. Jak? Tworząc instancję. Wiemy że, koniec końców, i tak instancje klasy <code>Product</code> będą chciały korzystać z <code>AmountWidget</code>, licząc na to, że klasa ta "ożywi" ich inputy. Możemy wiec równie dobrze zabrać się za stworzenie takiej współpracy już teraz. Przynajmniej upewnimy się od razu, czy konstruktor naszej nowej klasy poprawnie się włącza.</p>
<p>Wróć więc do klasy <code>Product</code> i odnajdź metodę <code>getElements</code>. Mamy tu już kilka referencji, m.in. do formularza czy diva z ceną. Teraz dodamy kolejną do diva z inputem i buttonami "+" i "-". Po co? Bo jak już wspomnieliśmy, <code>AmountWidget</code> będzie potrzebować dostępu do tego elementu.</p>
<p>Dodaj więc nową właściwość <code>thisProduct.amountWidgetElem</code>. Zadbaj o to, aby jej wartością była referencja do elementu o selektorze <code>select.menuProduct.amountWidget</code>. Pamiętaj przy tym, żeby szukać go w divie pojedynczego produktu, a nie całym dokumencie. Inaczej bowiem moglibyśmy "przypadkiem" znaleźć div z inputem z innego produktu (w końcu każdy div produktu ma identyczną strukturę HTML), a tego nie chcemy.</p>
<p>Następnie, wciąż w klasie <code>Product</code>, dodaj nową metodę <code>initAmountWidget</code>. Będzie ona odpowiedzialna za utworzenie nowej instancji klasy <code>AmountWidget</code> i zapisywanie jej we właściwości produktu. Po to, aby w razie potrzeby mieć do niej łatwy dostęp.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-20.png" style="width: auto;">
<p>Zauważ, że od razu przekazujemy do konstruktora referencję do naszego diva z inputem i buttonami tak, jak oczekiwała na to klasa <code>AmountWidget</code>. Przy czym powtórzmy jeszcze raz – przekazujemy tylko referencję, tylko adres. Duże obiekty zawsze są przekazywane tylko jako referencja, pamiętasz?</p>
<p>Na koniec, w konstruktorze klasy <code>Product</code> wywołaj tę metodę, tuż przed wywołaniem metody <code>processOrder</code>.</p>
<p>W rezultacie, w konsoli powinny pojawić się komunikaty z <code>console.log</code> użytych w konstruktorze klasy <code>AmountWidget</code>. Pojawią się osobno dla każdego produktu.</p>
<p>Widzimy w tych komunikatach, że żadna z instancji <code>AmountWidget</code> nie ma jeszcze właściwości i każda wyświetla taki sam element. Nie jest to jednak ten sam jeden element, tylko podobny z każdego produktu. Możesz to łatwo sprawdzić, klikając prawym przyciskiem myszy na jednym z elementów wyświetlonych w konsoli i wybierając opcję "Reveal in Elements panel".</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/07.oop/reveal-in-elements.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/reveal-in-elements.png" alt="image" style="width: auto; max-width: 50%;"></a>
<h3>Znalezienie elementów widgetu</h3>
<p>Czas na powrót do klasy <code>AmountWidget</code>. Już wcześniej wspominaliśmy, że będziemy w niej korzystać z trzech elementów – inputu i dwóch buttonów. Warto więc przygotować do nich referencje. Dla czytelności, podobnie jak w klasie <code>Product</code>, zrobimy w nowej dedykowanej metodzie – <code>getElements</code>.</p>
<p>Stworzymy ją teraz. Różnica jest jedna, tym razem będziemy przekazywać tej metodzie argument <code>element</code> otrzymany przez konstruktor. Dlaczego?</p>
<p>W przypadku klasy <code>Product</code>, zanim uruchomimy funkcję <code>getElements</code>, jest wywoływana metoda <code>renderInMenu</code>, która m.in. szykuje nam właściwość <code>thisProduct.element</code>. Dlatego też w <code>getElements</code> możemy od razu z niej korzystać. W końcu, jeśli zapiszemy coś do właściwości instancji, to możemy z tego korzystać w każdej jej metodzie.</p>
<p>W <code>AmountWidget</code> sytuacja jest inna. Nie mamy funkcji <code>renderInMenu</code>, nie szykowaliśmy też wcześniej właściwości <code>thisWidget.element</code>. Tak naprawdę jedynym miejscem, gdzie mamy dostęp do diva otrzymanego w instancji jest argument konstruktora. A czy argument funkcji <code>constructor</code> będzie dostępny ot tak w metodzie <code>getElements</code>? Nie. W końcu argument funkcji jest dostępny tylko w jej zakresie. Tym samym najprościej możemy po prostu przekazać zawartość tego argumentu konstruktora dalej... jako argument kolejnej metody <code>getElements</code>.</p>
<p>Dodaj więc do konstruktora następujące wywołanie:</p>
<pre><code class="language-js">thisWidget.getElements(element);
</code></pre>
<p>A następnie nową metodę:</p>
<pre><code class="language-js">    getElements(element){
      const thisWidget = this;

      thisWidget.element = element;
      thisWidget.input = thisWidget.element.querySelector(select.widgets.amount.input);
      thisWidget.linkDecrease = thisWidget.element.querySelector(select.widgets.amount.linkDecrease);
      thisWidget.linkIncrease = thisWidget.element.querySelector(select.widgets.amount.linkIncrease);
    }
</code></pre>
<p>Swoją drogą, zauważ jak ważna jest wiedza o referencjach. Argument <code>element</code>, który otrzymaliśmy w konstruktorze jest tylko referencją do tego samego elementu DOM, co <code>thisProduct.amountWidgetElem</code>. Kiedy przekazujemy argument <code>element</code> niżej, do <code>getElements</code>, to dalej przekazujemy tę samą referencję. Czyli tak naprawdę argument <code>element</code> w <code>getElements</code> to wciąż referencja do jednego i tego samego obiektu. Tego samego elementu DOM, na który wskazywał również <code>thisProduct.amountWidgetElem</code>. Idea referencji jest niesamowita, prawda? Gdyby nie ona, mielibyśmy już w tym momencie trzy kopie tego samego obiektu, a tak wciąż działamy na jednym i tym samym. To znacznie wydajniejsze.</p>
<p>Po tym kroku powinny zmienić się komunikaty w konsoli – teraz instancje klasy <code>AmountWidget</code> nie są już puste, tylko mają właściwości, w których zapisaliśmy elementy widgetu.</p>
<h3>Przygotowujemy funkcję pośrednik</h3>
<p>Użytkownik strony domyślnie może wpisać w inpucie co chce. Przydałoby się, żeby nasz widget na to nie pozwalał. Potrzebujemy jakiejś funkcji pośrednika, która uruchamiałaby się w momencie zmiany wartości, kontrolowała co jest wpisane i dopiero potem decydowała, czy zostawić taką nową wartość, czy może jednak nie. Musi więc również pamiętać jaka wartość była wpisana wcześniej. Wtedy w razie wpisania czegoś błędnego, będzie w stanie przywrócić wcześniejszą poprawną wartość.</p>
<p>Zanim jednak zabierzemy się za taką funkcję na poważnie, dla przypomnienia spójrz na gif, który pokazuje, jakie są nasze oczekiwania:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Próba wpisania zbyt dużej wartości (12) lub tekstu (<code>abc</code>) kończy się przywróceniem starej. Zatem na pewno, tak jak mówiliśmy, będziemy musieli stworzyć funkcję, która będzie uruchamiana przy próbie zmiany wartości i decydować, czy ma na to pozwolić, czy może przywrócić starą (ostatnią dobrą) wartość.</p>
<p>Naszą funkcją pośrednikiem będzie nowa metoda – <code>setValue</code>. Dodaj ją teraz do naszej klasy.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-21.png" style="width: auto;">
<p>To oczywiście dopiero początek. Na razie ta metoda tylko zapisuje we właściwości <code>thisWidget.value</code> wartość przekazanego argumentu, po przekonwertowaniu go na liczbę, a następnie aktualizuje wartość samego inputu. Na razie bez żadnej walidacji nawet nie sprawdzając, czy nie wpisaliśmy czasem czegoś złego... Jednak spokojnie, zaraz się tym zajmiemy. A po co ta konwersja (<code>parseInt</code>)? Pamiętaj, że każdy input, nawet o typie <code>number</code>, zawsze zwraca wartość w formacie tekstowym. Nawet wpisanie więc <code>10</code> da nam nie liczbę 10, a tekst <code>'10'</code>. <code>parseInt</code> zadba o konwersję takiej przykładowej <code>'10'</code> do liczby <code>10</code>.</p>
<p>Tak jak wspomnieliśmy, na razie wpisujemy do <code>thisWidget.value</code> wprost to, co ta metoda otrzyma, ale zaraz to zmienimy. Chcemy jeszcze dodatkowo sprawdzać, czy wartość tej stałej jest poprawna i mieści się w dopuszczalnym zakresie – tylko w takim przypadku zostanie ona zapisana jako właściwość <code>thisWidget.value</code>.</p>
<p>Zaczniemy od najprostszego ifa. Sprawdzimy, czy wartość, która przychodzi do funkcji, jest inna niż ta, która jest już aktualnie w <code>thisWidget.value</code>. Powinien on warunkować, czy linijka <code>thisWidget.value = newValue</code> ma się w ogóle wykonać.</p>
<p>Spróbuj napisać takiego ifa bez naszej pomocy.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-eRxM3Hv16-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-eRxM3Hv16-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-eRxM3Hv16-toggle" class="collapse">
<pre><code class="language-js">/* TODO: Add validation */
if(thisWidget.value !== newValue) {
  thisWidget.value = newValue;
}
</code></pre>
</div>
<p>To już jakaś zmiana. Teraz <code>thisWidget.value</code> zmieni się już faktycznie tylko wtedy, jeśli nowa wpisana w input wartość będzie inna niż obecna.</p>
<p>W takim razie czas na kolejne ćwiczenie. Chcielibyśmy również, żeby nasza funkcja ustalała, czy to wpisano w input jest faktycznie liczbą. Jak możemy to sprawdzić?</p>
<p>Zwróć uwagę, że na początku naszej funkcji staramy się konwertować podane <code>value</code> do liczby. Jeśli <code>parseInt</code> natrafi na tekst, którego nie da się skonwertować na liczbę (np. <code>abc</code>), to najprościej w świecie zwróci <code>null</code>. Wystarczy więc sprawdzić w naszym warunku, czy oprócz tego, że <code>thisWidget.value !== newValue</code>, <code>newValue</code> nie jest też <code>null</code>-em. No bo tylko jeśli nie jest, możemy mieć pewność, że to liczba i faktycznie zaktualizować wartość <code>thisWidget.value</code>.</p>
<p>Spróbuj dopisać taki warunek bez naszej pomocy. Przyda Ci się znajomość funkcji <code>isNaN</code>. Zajrzyj więc do <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/isNaN" target="_blank">dokumentacji</a>.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-SdgKHnoWUW-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż odpowiedź</a>
    <a href="#collapse-SdgKHnoWUW-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj odpowiedź</a>
  </span>
</p>
<div id="collapse-SdgKHnoWUW-toggle" class="collapse">
<pre><code class="language-js">/* TODO: Add validation */
if(thisWidget.value !== newValue &amp;&amp; !isNaN(newValue)) {
  thisWidget.value = newValue;
}
</code></pre>
</div>
<p>To już coś. Wyobraź sobie, jak w tej chwili mogłaby działać nasza funkcja. Powiedzmy, że za pierwszym razem ktoś wpisał w input <code>'3'</code>. Nasza funkcja <code>setValue</code> otrzymałaby taką wartość tekstową, przekonwertowała ją do liczby (<code>'3'</code> -> <code>3</code>), a następnie sprawdziła warunek. Na samym początku właściwość <code>thisWidget.value</code> nawet nie istnieje, więc na pewno jest inne niż <code>newValue</code> (<code>3</code>). <code>undefined</code> w końcu nie jest równe <code>3</code>. Czy <code>3</code> do tego nie jest <code>NaN</code>-em? No nie jest, więc warunek jest w pełni spełniony! Skoro tak, to od tej chwili <code>thisWidget.value</code> równa się <code>3</code> i taką wartość za chwilę dopisujemy też do samego inputu. Co prawda nie było to konieczne, bo użytkownik przecież sam wpisał taką wartość w input, więc i tak już ona tam jest, ale... czy to coś zepsuje? Nie.</p>
<p>Powiedzmy, że za chwilę wpisano kolejną wartość, tym razem celowo niepoprawną, np. <code>abc</code>. Oczywiście znowu uruchomi się nasza funkcja i spróbuje skonwertować wartość do liczby, tym razem jednak zakończy się to porażką. Otrzymamy jako <code>newValue</code> wartość <code>null</code>. W takim razie nasz warunek da nam <code>false</code> i nie wykona instrukcji z ifa. Nie zmieni więc wartości <code>thisWidget.value</code>. Ta wciąż będzie równa <code>3</code>. Tym samym, kiedy wykona się ostatnia linijka funkcji, a więc przypisanie wartości <code>thisWidget.value</code> do inputu, to tekst <code>abc</code>, który wpisał użytkownik, zostanie nadpisany wartością <code>3</code>! Dokładnie tak, jak na gifie!</p>
<p>Przyznaj, ciekawe rozwiązanie.</p>
<p>No dobrze, tylko że brakuje nam jeszcze jednego puzzla w układance. Napisaliśmy przed chwilą, że zmiana w inpucie ma włączyć funkcję <code>setValue</code>, ale czy właściwie to robi? Nie. Przecież JS sam z siebie nie domyśli się, o co nam chodzi. Musimy skorzystać z odpowiednich nasłuchiwaczy. Zaraz je dodamy.</p>
<p>Zanim jednak się tym zajmiemy, zrób jeszcze jedną rzecz. Wywołaj tę metodę w konstruktorze, pod wywołaniem metody <code>getElements</code>. Chodzi o to, żeby nawet na samym starcie, kiedy nikt jeszcze nie zmienił wartości w inpucie, nasza instancja miała już informację co w tym inpucie jest. Bo tak naprawdę tam zawsze coś jest. Gdy produkt generuje swój HTML, to w inpucie od razu wstawia nam domyślną wartość. Dobrze, żeby nasz widget o tym wiedział.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-22.png" style="width: auto;">
<p>Zmiana w tym kroku będzie stosunkowo mała – w komunikatach w konsoli możesz zobaczyć, że teraz każdy widget dodatkowo ma właściwość <code>value</code> równą <code>1</code>.</p>
<h3>Dodanie reakcji na eventy</h3>
<p>Czas na nasze nasłuchiwacze. Dodaj kolejną metodę, tym razem nazwij ją <code>initActions</code>. W tej klasie dodamy trzy listenery eventów:</p>
<ol>
<li>dla <code>thisWidget.input</code> dodaj listener eventu <code>change</code>, dla którego handler użyje metody <code>setValue</code> z takim samym argumentem, jak w konstruktorze (czyli z wartością inputa),</li>
<li>dla <code>thisWidget.linkDecrease</code> dodaj listener eventu <code>click</code>, dla którego handler powstrzyma domyślną akcję dla tego eventu, oraz użyje metody <code>setValue</code> – tym razem argumentem będzie <code>thisWidget.value</code> pomniejszone o <code>1</code>,</li>
<li><code>thisWidget.linkIncrease</code> potraktuj tak samo, jak <code>thisWidget.linkDecrease</code>, z tym że argumentem będzie <code>thisWidget.value</code> <em>powiększone</em> o <code>1</code>.</li>
</ol>
<p>Następnie zadbaj o to, aby ta metoda uruchamiała się automatycznie, od razu po utworzeniu instancji.</p>
<p>Po wykonaniu ćwiczenia sprawdź jak input ilości sztuk w produkcie reaguje na wpisanie tekstu.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-03.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-03.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Powinien przywracać poprzednią wartość, tak jak na gifie wyżej.</p>
<h3>Zakres akceptowanych wartości</h3>
<p>W tej chwili możemy zmniejszać ilość sztuk nawet poniżej zera albo wpisywać bardzo duże wartości, nawet w tysiącach. Chcielibyśmy, aby wartości były sprawdzane według jakiegoś zakresu. Nie większe niż maksymalna wspierana wartość i mniejsza niż minimalna. Wymaga to dodania kolejnych dwóch warunków do ifa w metodzie <code>setValue</code>.</p>
<p>Potraktuj to jako kolejne ćwiczenie. Na pewno dasz sobie radę! Minimalna wartość jest dostępna w <code>settings.amountWidget.defaultMin</code>, a maksymalna w <code>settings.amountWidget.defaultMax</code>.</p>
<p>Po zmianach input powinien działać znacznie lepiej:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-04.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-04.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Zauważ, że teraz możemy poruszać się już tylko w zakresie 0-10. Właśnie o to nam chodziło!</p>
<h3>Informowanie produktu o zmianie</h3>
<p>Jak wspomnieliśmy na początku tego submodułu, nasz widget musi jeszcze w jakiś sposób informować produkt, że zmieniła się liczba sztuk. Tak, aby ten mógł ponownie przeliczyć całkowitą cenę. Moglibyśmy skorzystać z wbudowanego eventu <code>change</code> uruchamianego na inpucie po zmianie jego wartości przez użytkownika strony, ale:</p>
<ul>
<li>jeśli zmieniamy wartość za pomocą JS po kliknięciu w guzik ("+" albo "-"), ten event nie będzie się uruchamiał automatycznie, musielibyśmy go uruchomić ręcznie,</li>
<li>jeśli użytkownik wpisze niepoprawną wartość, zostanie uruchomiony event <code>change</code> jeszcze zanim nasz skrypt sprawdzi, czy ta wartość jest poprawna, więc produkt od razu próbowałby przeliczyć cenę... nawet dla wartości niepoprawnej, takiej jak test, a to nie ma prawa się udać.</li>
</ul>
<p>Dlatego zrobimy coś innego – wywołamy własny, customowy event!</p>
<p>Do tej pory tylko nasłuchiwaliśmy, czy jakiś event się wydarzył – np. czy link został kliknięty. W tym wypadku to akcja użytkownika strony (kliknięcie w link) wywoływała event.</p>
<p>Tym razem sami wywołamy event! Tak, możemy to zrobić. Sami wybierzemy nawet jego nazwę. Dzięki temu produkt będzie mógł nasłuchiwać nie na event <code>change</code>, ale np. <code>update</code> i kiedy go wychwyci, będzie wiedział, że należy zaktualizować cenę produktu, a wartość w inpucie jest na pewno poprawna. Bo na pewno została już sprawdzona.</p>
<h4>Wywołanie eventu</h4>
<p>Zacznijmy od stworzenia metody <code>announce</code>. Będzie ona tworzyła instancje klasy <code>Event</code>, wbudowanej w silnik JS (czyli w przeglądarkę). Jest to klasa odpowiedzialna właśnie za stworzenie obiektu "eventu". Następnie, ten event zostanie wyemitowany na kontenerze naszego widgetu.</p>
<p>Możesz sobie wyobrazić, że jeśli użytkownik klika gdzieś na stronie, to przeglądarka robi dokładnie to samo co my teraz. Również tworzy event click w podobny sposób przy użyciu klasy <code>Event</code>, a następnie emituje go na tym klikniętym elemencie za pomocą metody <code>dispatchEvent</code>. Ma to sens?</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-23.png" style="width: auto;">
<p>Nasz event nazwaliśmy <code>'updated'</code>, ale to zupełnie zmyślona nazwa – równie dobrze moglibyśmy użyć każdego innego określenia, które nie jest jednym z wbudowanych eventów.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Wywoływanie wbudowanych eventów</h4>
<p>Wbudowane eventy również można wywoływać – np. możemy wywołać event <code>click</code> na linku. Nie wywoła to domyślnej akcji (przejścia na adres podany w atrybucie <code>href</code> tego linka), ale zostanie wychwycone przez każdy event listener dodany w JS dla tego linka.</p>
<p>Na przykład, jeśli wywołamy event <code>click</code> na guziku zwiększania ilości, to zadziała on tak samo, jak gdybyśmy go kliknęli. Krótko mówiąc, jesteśmy w stanie sami wchodzić w body "przeglądarki" i symulować nawet wbudowane już w nią eventy.</p>
</div>
<p>Teraz musimy jeszcze wywoływać tę metodę <code>announce</code>. Gdzie? Koniecznie musimy zadbać o to, aby uruchamiała się dopiero wtedy, kiedy nowa wartość, którą chcemy ustawić, faktycznie jest poprawna. Tylko wtedy jest sens informować o zmianie produkt. Właśnie tym nasz event <code>updated</code> będzie się różnił od eventu <code>change</code>, że nasz uruchomi się przy zmianie wartości, ale tylko na taką, która wciąż będzie poprawna.</p>
<p>Zastanów się więc, w którym miejscu w metodzie <code>setValue</code> musimy ją wstawić.</p>
<h4>Nasłuchiwanie eventu</h4>
<p>Drugą częścią informowania produktu, jak już wspomnieliśmy, jest nasłuchiwanie tego eventu w klasie <code>Product</code>. Co bowiem z tego, że event <code>updated</code> będzie emitowany na inpucie, skoro produkt nic sobie z tym nie robi?</p>
<p>Przejdź więc do klasy <code>Product</code> i znajdź w niej metodę <code>initAmountWidget</code>. Następnie dodaj do niej listener eventu, który będzie nasłuchiwał na element <code>thisProduct.amountWidgetElem</code>, na zdarzenie <code>updated</code>. Dlaczego nasłuchujemy właśnie na ten element? Bo to na nim emitowaliśmy nasz event. Pamiętaj, w końcu <code>thisWidget.element</code> to referencja do tego samego identycznego elementu co <code>thisProduct.amountWidgetElem</code>.</p>
<p>Jako funkcja, która ma uruchomić się w momencie wykrycia tego eventu, dodaj prostą funkcję anonimową, która zajmie się uruchamianiem metody <code>thisProduct.processOrder();</code>.</p>
<p>Ten kod już powinien działać, ale nie będzie widać żadnych jego efektów. Nic dziwnego, w końcu metoda <code>processOrder</code> w żaden sposób nie sprawdza wybranej liczby sztuk, ani tym bardziej nie mnoży przez nią ceny końcowej.</p>
<p>Dlatego musimy zrobić jeszcze jedną zmianę. Znajdź metodę <code>processOrder</code>. Na jej końcu powinna być linia kodu, która ustawia zawartość <code>thisProduct.priceElem</code> na wartość zmiennej <code>price</code>. Tuż przed tą linią dodaj ten fragment kodu:</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/07.oop/fer-07-24.png" style="width: auto;">
<p>W ten sposób, tuż przed wyświetleniem ceny obliczonej z uwzględnieniem opcji, pomnożymy ją przez ilość sztuk wybraną w widgecie!</p>
<p>Teraz już cena produktu powinna się zmieniać w momencie zmiany ilości. Jeśli klikniesz w guzik zwiększenia lub zmniejszenia ilości, cena zmieni się natychmiast. Jeśli wpiszesz liczbę w inpucie, cena zmieni się, kiedy wyjdziesz z inputa (np. klikniesz gdzieś na stronie lub wciśniesz klawisz Tab na klawiaturze).</p>
<p>Uff... To już koniec. Dobra robota!</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-01.gif" alt="image" style="width: auto; max-width: 50%;"></a>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">walidacja wartości</span></h3>
                        <div class="task-content">
                            <p>Przed Tobą jeszcze jedno bardzo małe zadanie. Na razie jako wartość startową <code>thisWidget.value</code> wpisujemy domyślną wartość inputu, na którym działamy. Teraz to zmienimy. Zamiast jej, ustawiaj jako wartość domyślną <code>settings.amountWidget.defaultValue</code>.</p>
<p>Oznacza to, że domyślna wartość w inpucie nie będzie już potrzebna. Przejdź więc do pliku <code>index.html</code> i usuń w szablonie produktu <code>value=&quot;1&quot;</code> z kodu inputa o atrybucie <code>name=&quot;amount&quot;</code>. Widget ilości sztuk powinien działać bez zmian, domyślnie pokazując <code>1</code>. Spróbuj zmienić wartość <code>settings.amountWidget.defaultValue</code>, aby upewnić się, że to właśnie stamtąd jest pobierana domyślna wartość.</p>
<h4>Oczekiwany efekt</h4>
<p>Jeśli wszystko poszło dobrze, nasz widget wyboru ilości sztuk działa już poprawnie. Pozwala na zmianę wartości za pomocą guzików oraz edycji wartości w inpucie. Jednocześnie pozwala tylko na wybranie wartości od <code>0</code> do <code>10</code>.</p>
<p>Jeśli w inpucie wpiszemy coś innego – np. liczbę spoza tego zakresu albo tekst – to natychmiast po wyjściu z inputa wartość zmieni się na tę, która była ustawiona przed edycją, czyli dotychczasową wartość <code>thisWidget.value</code>.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/607286" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/72cbef04840055ce091db4f7c630df373ea2cb51">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1973" class="card submodule completed" data-bootcamp-user-submodule-id="607287" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.2. <span>Nowe funkcjonalności projektu</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Czas na nasz koszyk. Za jego działania będą odpowiadać <strong>dwie nowe klasy</strong>: <code>Cart</code> oraz <code>CartProduct</code>. Omówmy je sobie po kolei, byśmy wiedzieli, co nas czeka.</p>
<p>Pierwsza z klas, które stworzymy, czyli <code>Cart</code>, będzie wykonywała następujące działania:</p>
<ul>
<li>pokazywanie i ukrywanie koszyka,</li>
<li>dodawanie i usuwanie produktów,</li>
<li>podliczanie ceny zamówienia.</li>
</ul>
<p>Ta klasa będzie zatem odpowiedzialna za "globalne" działanie koszyka.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/order-sm.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/order-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/order.png 2x"  class="img-inline img-right">
<p>Będzie ona ściśle współpracować z naszą drugą klasą, <code>CartProduct</code>, której instancje będą <strong>pojedynczymi produktami w koszyku</strong>. Dzięki takiemu podziałowi wszystko, co dotyczy danej pozycji z koszyka, będzie wyodrębnionym kodem. Nie jest to oczywiście "obowiązkowy" podział, ale przekonasz się, że naprawdę będzie to bardzo pomocne.</p>
<p>Kiedy koszyk będzie już w pełni sprawny, zajmiemy się <strong>AJAX-em</strong> i <strong>API</strong> – te technologie pozwolą nam na komunikację z serwerem. Na początek posłużą nam do pobierania listy produktów, a następnie do zapisywania złożonych zamówień.</p>
<p>Na końcu tego modułu będziemy mieli już w pełni sprawną stronę pizzerii, w której można nawet składać zamówienia!</p>
<div class="bc-note alert-warning">
<h4 class="alert-heading text-center">Czy to będzie gotowa strona?</h4>
<p>Możesz zastanawiać się, czy strona, którą tworzymy, mogłaby być używana przez prawdziwą restaurację. Krótka odpowiedź to: nie.</p>
<p>Po pierwsze, API, którego użyjemy, nie jest w żaden sposób zabezpieczone. Każdy może zobaczyć szczegóły wszystkich zamówień. Używamy go tylko do celów tzw. prototypowania – pozwoli nam napisać i przetestować skrypty JS, służące do komunikacji z serwerem.</p>
<p>Po drugie, nasza strona jest bardzo skąpa – prawdziwa restauracja chciałaby zapewne umożliwić klientom założenie konta, sprawdzenie listy swoich zamówień, czy wyświetlenie informacji o zaakceptowaniu zamówienia. Należałoby też ograniczyć zamówienia do godzin otwarcia pizzerii i być może dodać możliwość płatności online. Kolejnym często spotykanym dodatkiem jest tzw. captcha, czyli zabezpieczenie przed spamem – czyli np. przepisanie kodu z obrazka.</p>
<p>Wreszcie po trzecie, załoga restauracji musiałaby mieć możliwość obsługi tej strony – zmiany produktów w menu, odczytywania listy zamówień, etc. Ten pakiet funkcjonalności zwykle nazywany jest panelem administracyjnym.</p>
<p>Niemniej jednak nasz kod spokojnie mógłby zostać użyty jako baza pod dalszy rozwój i zastosowanie w praktyce. Innymi słowy, właśnie tworzysz projekt, który mógłby być Twoim zadaniem w pracy na stanowisku Junior Frontend Developera!</p>
</div>
<h3>Przygotowanie do rozwoju projektu</h3>
<p>Zanim rozpoczniemy prace, musisz uzupełnić pliki projektu o zmiany, które dla Ciebie przygotowaliśmy. Nie martw się – w większości przypadków wystarczy podmienić parę plików.</p>
<ul class="nav nav-tabs">
	<li class="nav-item"><a href="#fer0801-styles" class="nav-link active show" data-toggle="tab">Style</a></li>
	<li class="nav-item"><a href="#fer0801-html" class="nav-link" data-toggle="tab">Kod HTML</a></li>
	<li class="nav-item"><a href="#fer0801-functions" class="nav-link" data-toggle="tab">Funkcje JS</a></li>
	<li class="nav-item"><a href="#fer0801-js" class="nav-link" data-toggle="tab">Kod JS</a></li>
</ul>
<div class="tab-content">
<div id="fer0801-styles" class="tab-pane card fade active show"><div class="card-block">
<h4>Style</h4>
<p>Wprowadziliśmy kilka zmian w stylach projektu. Jeśli nie były one przez Ciebie modyfikowane, wystarczy, że rozpakujesz paczkę plików w katalogu <code>src/sass/partials</code>.</p>
<p class="text-center">
  <a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/partials.zip" class="btn btn-primary">Pobierz paczkę stylów</a>
</p>
<p>Zmian nie ma wiele, a wszystkie oznaczyliśmy komentarzami okalającymi blok nowego kodu:</p>
<pre><code class="language-scss">// CODE ADDED START

// CODE ADDED END
</code></pre>
<p>W przypadku zmian pojedynczej linii, na końcu linii dodaliśmy komentarz:</p>
<pre><code class="language-scss">// CODE CHANGED
</code></pre>
<p>Zmian jest tylko kilka, więc bez problemu sobie z nimi poradzisz.</p>
</div></div> <!-- /.tab-pane -->
<div id="fer0801-html" class="tab-pane card fade"><div class="card-block">
<h4>Kod HTML</h4>
<p>W pliku <code>src/index.html</code> również musimy wprowadzić kilka zmian. Możesz podmienić ten plik na nowy, lub ręcznie wprowadzić zmiany, które wymieniliśmy poniżej.</p>
<p class="text-center">
  <a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/index.zip" class="btn btn-primary">Pobierz plik index.html</a>
</p>
<br>
<ol>
<li>Usuń cały <code>&lt;header&gt;</code>, zamiast niego wstaw <code>&lt;header&gt;</code> z nowego pliku.</li>
<li>Nad szablonem <code>template-menu-product</code> dodaj nowy szablon <code>template-cart-product</code>.</li>
<li>W szablonie <code>template-menu-product</code> znajdź fragment <code>name=&quot;amount&quot;</code> i zmienić go na <code>class=&quot;amount&quot;</code></li>
</ol>
</div></div> <!-- /.tab-pane -->
<div id="fer0801-functions" class="tab-pane card fade"><div class="card-block">
<h4>Funkcje JS</h4>
<p>W pliku <code>src/js/functions.js</code> wszystkie zmiany to:</p>
<ul>
<li>funkcja pomocnicza: <code>utils.convertDataSourceToDbJson</code>,</li>
<li>nowy moduł pomocniczy do szablonów: <code>Handlebars.registerHelper('joinValues', ...</code>,</li>
<li>komentarz dla ESLinta w 1. linii pliku.</li>
</ul>
<p>Wszystkie te zmiany znajdziesz w nowym pliku <code>functions.js</code></p>
<p class="text-center">
  <a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/functions.zip" class="btn btn-primary">Pobierz plik functions.js</a>
</p>
</div></div> <!-- /.tab-pane -->
<div id="fer0801-js" class="tab-pane card fade"><div class="card-block">
<h4>Kod JS</h4>
<p>W pliku <code>src/js/script.js</code> musimy dodać kilka zmian w obiektach <code>select</code>, <code>classNames</code>, <code>settings</code> i <code>templates</code>. Poniżej zamieszczamy w całości te obiekty. Możesz podmienić cały fragment kodu, lub przenieść tylko zmiany oznaczone komentarzami.</p>
<pre><code class="language-js">  const select = {
    templateOf: {
      menuProduct: '#template-menu-product',
      cartProduct: '#template-cart-product', // CODE ADDED
    },
    containerOf: {
      menu: '#product-list',
      cart: '#cart',
    },
    all: {
      menuProducts: '#product-list &gt; .product',
      menuProductsActive: '#product-list &gt; .product.active',
      formInputs: 'input, select',
    },
    menuProduct: {
      clickable: '.product__header',
      form: '.product__order',
      priceElem: '.product__total-price .price',
      imageWrapper: '.product__images',
      amountWidget: '.widget-amount',
      cartButton: '[href=&quot;#add-to-cart&quot;]',
    },
    widgets: {
      amount: {
        input: 'input.amount', // CODE CHANGED
        linkDecrease: 'a[href=&quot;#less&quot;]',
        linkIncrease: 'a[href=&quot;#more&quot;]',
      },
    },
    // CODE ADDED START
    cart: {
      productList: '.cart__order-summary',
      toggleTrigger: '.cart__summary',
      totalNumber: `.cart__total-number`,
      totalPrice: '.cart__total-price strong, .cart__order-total .cart__order-price-sum strong',
      subtotalPrice: '.cart__order-subtotal .cart__order-price-sum strong',
      deliveryFee: '.cart__order-delivery .cart__order-price-sum strong',
      form: '.cart__order',
      formSubmit: '.cart__order [type=&quot;submit&quot;]',
      phone: '[name=&quot;phone&quot;]',
      address: '[name=&quot;address&quot;]',
    },
    cartProduct: {
      amountWidget: '.widget-amount',
      price: '.cart__product-price',
      edit: '[href=&quot;#edit&quot;]',
      remove: '[href=&quot;#remove&quot;]',
    },
    // CODE ADDED END
  };

  const classNames = {
    menuProduct: {
      wrapperActive: 'active',
      imageVisible: 'active',
    },
    // CODE ADDED START
    cart: {
      wrapperActive: 'active',
    },
    // CODE ADDED END
  };

  const settings = {
    amountWidget: {
      defaultValue: 1,
      defaultMin: 1,
      defaultMax: 9,
    }, // CODE CHANGED
    // CODE ADDED START
    cart: {
      defaultDeliveryFee: 20,
    },
    // CODE ADDED END
  };

  const templates = {
    menuProduct: Handlebars.compile(document.querySelector(select.templateOf.menuProduct).innerHTML),
    // CODE ADDED START
    cartProduct: Handlebars.compile(document.querySelector(select.templateOf.cartProduct).innerHTML),
    // CODE ADDED END
  };
</code></pre>
</div></div> <!-- /.tab-pane -->
</div> <!-- /.tab-content -->
<hr>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Łączenie zmian w plikach</h4>
<p>Cała ta operacja mogła wydawać się żmudna, ale jest to również sytuacja, z którą możesz spotkać się w swojej przyszłej pracy. Tego rodzaju zmiany możesz otrzymać z opisem podobnym do powyższego, lub jako spory commit wykonany przez innego developera. Przy sporych zmianach, Git może nie poradzić sobie automatycznie ze scaleniem zmian i może wymagać od Ciebie ręcznego pogodzenia konfliktów.</p>
<p>Jeśli zmiany, które należy wprowadzić, nie są jasno oznaczone, najlepiej skorzystać z narzędzia <em>diff</em> (skrót od <em>difference</em>, czyli <em>różnica</em>). Spotkaliśmy się już z tego typu narzędziem – GitHub wyświetla zmiany wprowadzone przez dany commit właśnie jako <em>diff</em>, czyli oznaczając, co dokładnie zmieniło się względem poprzedniego commita. Również edytory kodu często mają wbudowane funkcjonalności porównywania plików.</p>
<p>Jeśli potrzebujesz osobnego narzędzia <em>diff</em>, możesz sprawdzić np. <a href="http://meldmerge.org/" target="_blank">Meld</a> czy <a href="https://www.perforce.com/downloads/visual-merge-tool" target="_blank">P4Merge</a> – pozwalają one nawet na porównywanie całych katalogów.</p>
</div>
<h3>Możemy zaczynać pracę</h3>
<p>Wszystkie zmiany pomogą nam przy implementacji naszego koszyka. Teraz możemy rozpoczynać pracę nad rozbudową projektu!</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1974" class="card submodule completed" data-bootcamp-user-submodule-id="607288" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.3. <span>Cart &ndash; klasa koszyka</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Zacznijmy od tego, do czego dążymy. Po zakończeniu pracy w tym module nasz koszyk będzie działać następująco:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-05.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-05.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Jak widzisz, składa się on z wielu elementów: każdy produkt ma nazwę, cenę, widget zmiany ilości, ikony edycji i usunięcia. Dodatkowo, w przypadku produktów z konfigurowalnymi opcjami, wyświetlamy wybrane przez klienta składniki.</p>
<p>Ponadto, górna belka koszyka wyświetla łączną kwotę zamówienia oraz liczbę produktów w koszyku. Dodawanie produktu do koszyka będzie równało się z aktualizacją informacji o koszcie. Będzie również istniała możliwość usuwania produktu z koszyka.</p>
<p>Całość może wyglądać nieco przytłaczająco, ale nie przejmuj się – będziemy przechodzić przez poszczególne elementy po kolei, tak, że zobaczysz, jak łączą się one ze sobą i jak przekazują między sobą dane.</p>
<p>Zaczniemy od zakodowania klasy <code>Cart</code>, która będzie obsługiwała nasz koszyk i wszystkie jego funkcjonalności.</p>
<h3>Tworzenie klasy</h3>
<p>Na samym początku musimy zadeklarować naszą klasę. Znajdź w kodzie deklarację obiektu <code>app</code> i wstaw przed nią nową klasę – <code>Cart</code>, od razu z konstruktorem i metodą <code>getElements</code>.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-04.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-04.png" alt="image" style="width: auto;"></a>
<p>Jak zwykle stosujemy stałą, w której zapisujemy obiekt <code>this</code> – tym razem nazwiemy ją <code>thisCart</code>. Dodatkowo od razu stworzyliśmy również tablicę <code>thisCart.products</code>, w której będziemy przechowywać produkty dodane do koszyka.</p>
<p>Wprowadzamy tutaj dodatkowo jedną nowość – <strong>obiekt <code>thisCart.dom</code></strong>. Nie jest to nic wymaganego, ale znacznie ułatwi nam nawigację po klasie. W poprzednich klasach przypisywaliśmy referencję do elementów DOM od razu jako właściwości instancji (np. <code>thisProduct.amountWidgetElem</code>). Jest to o tyle słaby pomysł, że tak samo przechowywaliśmy również referencję do instancji <code>AmountWidget</code> (<code>thisProduct.amountWidget</code>), czy nawet zwykłe wartości (np. <code>thisWidget.value</code>). Mogło to wprowadzać zamieszanie, np. inny programista, widząc właściwość o nazwie <code>thisCart.totalPrice</code>, mógłby się zastanawiać, czy jest to referencja do elementu HTML, który pokazuje cenę, czy może po prostu liczba? Dzięki temu, że schowamy referencje elementów DOM do osobnego obiektu (<code>thisCart.dom</code>), to łatwiej będziemy w stanie określić rolę poszczególnych właściwości. Widzisz w kodzie <code>thisCart.dom.totalPrice</code> i od razu wiesz, że to <strong>musi</strong> być element DOM. Widzisz <code>thisCart.totalPrice</code> i masz pewność, że to coś innego.</p>
<p>Nie jest to oczywiście jakaś wymagana praktyka, lecz zwykły pomysł, który powinien uczytelnić nam trochę naszą klasę.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Spróbuj wprowadzić ten sam pomysł w klasie <code>Product</code>. Tak, żeby wszystkie referencje do elementów DOM były "schowane" w obiekcie dodatkowym obiekcie <code>thisProduct.dom</code>.</p>
</div>
<h3>Tworzenie instancji</h3>
<p>Mamy już naszą klasę, musimy jeszcze stworzyć jej instancję. Oczywiście w naszej aplikacji będzie tylko jeden koszyk, a więc wykorzystamy tę klasę tylko raz. Odnajdź obiekt <code>app</code> i stwórz w nim metodę <code>initCart</code>. Zadbaj o to, aby  <strong>inicjowała instancję koszyka</strong>. Pamiętaj, że konstruktor tej klasy oczekuje na przekazanie referencji do diva, w którym ten koszyk ma być obecny. Przekażemy jej więc wrapper (czyli kontener, element okalający) koszyka.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-05.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-05.png" alt="image" style="width: auto;"></a>
<p>Pozostaje jeszcze wywołać tę metodę na końcu <code>app.init</code>, aby w konsoli zobaczyć komunikat generowany przez <code>console.log</code> na końcu konstruktora klasy <code>Cart</code>.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/console-cart.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/console-cart.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Jak widzisz, instancję klasy <code>Cart</code> zapisaliśmy w <code>thisApp.cart</code>. Oznacza to, że poza obiektem <code>app</code> możemy wywołać ją za pomocą <code>app.cart</code>. Już za chwilę będziemy z tego korzystać, aby zacząć dodawać produkty do koszyka!</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Po co nam klasa dla jednego koszyka?</h4>
<p>Możesz zastanawiać się, czy podejście obiektowe ma sens, kiedy będziemy tworzyć tylko jedną instancję danej klasy. Oczywiście, moglibyśmy zastosować inną architekturę w tym wypadku, ale zastosowanie OOP nie ma żadnych wad. Nie napiszemy przez to więcej kodu, bo te same funkcjonalności i tak musielibyśmy oskryptować.</p>
<p>Zaletą tego podejścia jest natomiast uporządkowanie kodu – zarówno myśląc o jakości kodu, jak i naszej wygodzie (czy szerzej – wygodzie pracy developera). Pamiętaj, że edytor kodu pozwala na zwijanie kodu, dzięki któremu znacznie łatwiej będzie Ci odnaleźć odpowiedni fragment pliku.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/vsc-folded.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/vsc-folded.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Niektóre edytory, jak np. darmowy <a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a>, wyświetlają nawet outline, czyli "spis treści" pliku!</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/vsc-outline.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/vsc-outline.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Dodatkowo, otwieramy sobie drogę do przyszłych rozwiązań. Może w przyszłości restauracja będzie chciała umożliwić zapisanie koszyka i późniejsze wczytanie jednego z zapisanych koszyków? Albo zechce umożliwić zamówienia grupowe, w których zamówienie będzie się składać z kilku koszyków poszczególnych osób, aby mogły rozliczyć się osobno? Łatwiej nam będzie wprowadzić takie funkcjonalności, jeśli koszyk będzie stworzony jako instancja klasy.</p>
</div>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">pokazywanie i chowanie koszyka</span></h3>
                        <div class="task-content">
                            <p>Pierwszą funkcjonalnością koszyka będzie jego pokazywanie i ukrywanie. Przypomina Ci to coś? Dokładnie to samo robiliśmy już w klasie <code>Product</code>, z tą różnicą, że tam potrzebowaliśmy jednocześnie ukrywać inne "otwarte" produkty. Tutaj mamy tylko jeden element, jeden koszyk, będzie więc jeszcze prościej!</p>
<p><strong>1.</strong> W metodzie <code>getElements</code> dodajemy definicję właściwości <code>thisCart.dom.toggleTrigger</code>, która znajduje w <code>thisCart.dom.wrapper</code> pojedynczy element o selektorze zapisanym w <code>select.cart.toggleTrigger</code>.</p>
<p><strong>2.</strong> Dodajemy metodę <code>initActions</code> i wywołujemy ją w konstruktorze tuż pod wywołaniem metody <code>getElements</code>.</p>
<p><strong>3.</strong> W metodzie <code>initActions</code> deklarujemy <code>thisCart</code> i dodajemy listener eventu <code>'click'</code> na elemencie <code>thisCart.dom.toggleTrigger</code>.</p>
<p><strong>4.</strong> Handler tego listenera ma <em>toggle'ować</em> klasę zapisaną w <code>classNames.cart.wrapperActive</code> na elemencie <code>thisCart.dom.wrapper</code>.</p>
<h4>Oczekiwany efekt</h4>
<p>W rezultacie koszyk powinien się rozwijać i zwijać przy kliknięciu, pokazując/ukrywając szczegóły koszyka, zawierające m.in. guzik "ORDER".</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-06.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-06.gif" alt="image" style="width: auto; max-width: 50%;"></a>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/607288" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/07330ccaf71eaedda9e632c90150010f8f4cbd90">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1975" class="card submodule completed" data-bootcamp-user-submodule-id="607289" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.4. <span>Dodawanie produkt&oacute;w do koszyka</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Jeżeli udało Ci się wykonać poprawnie poprzednie zadanie, koszyk na stronie Twojej pizzerii już się otwiera. Ciągle jednak świeci on pustkami – czas to zmienić!</p>
<h3>Założenia funkcjonalności</h3>
<p>Kiedy użytkownik wybierze w menu jakiś produkt, ustawi jego opcje i kliknie w guzik "ADD TO CART", to nic się na razie nie stanie. Musimy wprowadzić zmiany w klasie <code>Product</code>, dzięki którym po kliknięciu tego guzika, koszyk (czyli <code>app.cart</code>) zostanie poinformowany o tym, że ma dodać do swojej listy nowy produkt.</p>
<h3>Wysłanie produktu do koszyka</h3>
<p><strong>1.</strong> Zaczynamy od dodania w klasie <code>Cart</code> nowej metody:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-06.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-06.png" alt="image" style="width: auto;"></a>
<p>Zakomentowaliśmy pierwszą linię, aby ESLint nie zgłaszał błędu, że ta stała nie została jeszcze nigdzie wykorzystana. Poza tym w funkcji znajduje się tylko <code>console.log</code> wyświetlający argument przekazany tej metodzie.</p>
<p><strong>2.</strong> W klasie <code>Product</code> również dodaj nową metodę:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-07.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-07.png" alt="image" style="width: auto;"></a>
<p>Jak widzisz, przekazuje ona całą instancję jako argument metody <code>app.cart.add</code>. Pamiętasz, że w <code>app.cart</code> zapisaliśmy instancję klasy <code>Cart</code>, prawda? Dlatego w ten sposób odwołujemy się do jej metody <code>add</code>. Właśnie tej, którą przygotowaliśmy chwilę wcześniej, w pierwszym punkcie.</p>
<p>Może Cię dziwić, że "przekazujemy instancję", ale to nie znaczy, że ona gdzieś wędruje – metoda <code>add</code> otrzyma tylko <strong>odwołanie</strong> (referencję) do tej instancji, dzięki czemu będzie mogła odczytywać jej właściwości i wykonywać jej metody. W poprzednim kroku widzimy, że w metodzie <code>add</code> ta instancja produktu będzie dostępna jako <code>menuProduct</code>.</p>
<p><strong>3.</strong> W klasie <code>Product</code> znajdź metodę <code>initOrderForm</code>, a w niej handler eventu <code>'click'</code> na elemencie <code>thisProduct.cartButton</code>. Na końcu handlera, pod wywołaniem metody <code>processOrder</code>, dodaj wywołanie metody <code>addToCart</code>. Pamiętasz? Obiecaliśmy, że tu jeszcze wrócimy :)</p>
<h3>Analiza dostępnych danych</h3>
<p>Po wykonaniu tych operacji, kliknięcie w <code>ADD TO CART</code> któregokolwiek produktu powinno wyświetlić w konsoli instancję tego produktu.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/cart-sm.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/cart-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/cart.png 2x"  class="img-inline img-left">
<p>Przyjrzyjmy się tej instancji i zastanówmy się, czy aby na pewno to dobrze, że przekazaliśmy ją w całości, no i czy czasem czegoś nie brakuje. Przeprowadźmy tę analizę na podstawie tego, czego możemy potrzebować. Spójrz jeszcze raz na oczekiwany efekt:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-07.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-07.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Czego więc potrzebujemy? Na pewno nazwy produktu, ceny całkowitej, ilości sztuk, informacji jakie opcje wybrano oraz ceny jednostkowej. Po co nam cena jednostkowa? Chcemy, aby w koszyku, była możliwość zmiany liczby sztuk. Dobrze byłoby więc, aby koszyk wiedział, ile kosztuje pojedyncza sztuka, tak, aby łatwo mógł przeliczyć cenę całkowitą od nowa. Dodatkowo dobrze byłoby też posiadać id produktu. To bardziej dodatek na przyszłość. Nasz serwer będzie bowiem oczekiwał takiej informacji. Nie wchodźmy na razie w szczegóły, ale zwyczajnie musimy taką właściwość przygotować.</p>
<p>Spróbuj więc testowo dodać do koszyka jakiś produkt. Kliknij na button "Add to cart" np. w pizzy i spójrz na to, co otrzymaliśmy:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-08.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-08.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Co na pewno tutaj mamy?</p>
<ul>
<li>jest <code>id</code> produktu, które będziemy wysyłać do serwera przy zapisaniu zamówienia,</li>
<li>jest <code>data.name</code>, które da nam nazwę produktu,</li>
<li>jest <code>amountWidget</code>, która zawiera właściwość <code>value</code> (da nam ona informacje o liczbie sztuk).</li>
</ul>
<p>Jakich informacji nam brakuje?</p>
<ul>
<li>ceny pojedynczego produktu z wybranymi opcjami, która będzie nam potrzebna, aby obliczać nową cenę, jeśli liczba sztuk zostanie zmieniona już w koszyku,</li>
<li>zestawienia wybranych opcji, ponieważ je też chcemy wyświetlać w koszyku oraz wysyłać przy zapisaniu zamówienia.</li>
</ul>
<p>Drugi punkt może Cię dziwić, bo zapewne widzisz w naszej instancji obiekt <code>params</code>. Dlaczego nie możemy skorzystać właśnie z niego? Dobrze mu się przyjrzyj. On tylko mówi nam, jakie kategorie i opcje dany produkt posiada. Nie mówi jednak, czy w danej sytuacji były one wybrane, czy nie. A bez tej informacji jest on dla nas bezużyteczny.</p>
<p>Na pewno będziemy musieli więc zadbać o dodanie tych dwóch informacji.</p>
<p>Dodatkowo warto zauważyć przy okazji jeszcze jedną rzecz. Tak naprawdę przekazujemy do koszyka również mnóstwo zbędnych informacji. Spójrz tylko na takie właściwości jak <code>imageWrapper</code>, <code>form</code>, <code>formInputs</code>, <code>cartButton</code> itd. Zresztą, taka instancja posiada nawet metody, jak <code>processOrder</code> czy <code>getElements</code>. Nie widzisz ich "na wierzchu", ale są schowane pod właściwością <code>__proto__</code>. Po co nam takie rzeczy w koszyku?</p>
<p>Musimy wziąć to pod uwagę. W takiej sytuacji zamiast przekazywać całą instancję produktu, może warto byłoby po prostu... przygotować nowy mniejszy obiekt. Taki, które będzie miał tylko te właściwości z instancji, które są nam faktycznie potrzebne plus te dwie, których nam brakuje. Przy okazji będziemy mogli też ułatwić dostęp do <code>data.name</code> czy <code>amountWidget.value</code>. Nasz nowy obiekt może np. zapisać je od razu pod właściwością <code>name</code> czy <code>amount</code>!</p>
<h3>Zapisanie danych zamawianego produktu</h3>
<p>Wiemy, co chcemy zrobić, czas więc zabrać się do pracy. Zacznij od utworzenia nowej metody w klasie <code>Product</code>. Nazwij ją <code>prepareCartProduct</code> i standardowo zacznij od przygotowania "skrótu" do <code>this</code>. Stwórz również nowy, na razie pusty obiekt o nazwie <code>productSummary</code>. Słowo <em>summary</em> (podsumowanie) dobrze oddaje, czym ten obiekt będzie. Minimalnym podsumowaniem całego produktu. Takim, które posiada tylko niezbędne dla koszyka informacje.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-09.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-09.png" alt="image" style="width: auto; max-width: 50%;"></a>
<h4>Podstawowe informacje</h4>
<p>Zacznijmy od dodania do tego obiektu najprostszych informacji. Dodaj więc właściwości <code>id</code>, <code>name</code>, <code>amount</code>. Wszystkie powinny posiadać informacje wzięte wprost z instancji <code>thisProduct</code>. <code>id</code> powinno być równie zapisanej <code>thisProduct</code> właściwości <code>id</code> (<code>thisProduct.id</code>), <code>name</code> powinno być równe zapisanej tam nazwie itd.</p>
<h4>Cena jednostkowa i cena całkowita</h4>
<p>Musimy teraz ustalić ceny. Potrzebujemy informacji o cenie jednostkowej i cenie całkowitej. Ta druga będzie zwyczajnie wynikiem pomnożenia ceny jednostkowej przez liczbę sztuk.</p>
<p>Wynika więc z tego, że musimy dowiedzieć się jakoś o wartości ceny jednostkowej, wtedy przygotowanie drugiej będzie już tylko formalnością.</p>
<p>Może wydawać Ci się, że w <code>thisProduct</code> mamy już zapisaną cenę jednostkową, ale to nie prawda. <code>thisProduct.data.price</code> to bowiem cena startowa, niebiorąca pod uwagę, że klient mógł dokonać jakichś zmian w opcjach produktu, a przecież zanim klient doda produkt do koszyka, to faktycznie może coś w tych opcjach zmieni. Co z tego wynika? Że musimy taką cenę ustalić...</p>
<p>Zapewne czytając powyższy akapit, w głowie zaświtał Ci już pewien pomysł. Przecież przeliczamy już cenę biorącą pod uwagę wybrane opcje. Robimy to w metodzie <code>proccesOrder</code>! Przeliczamy tam cenę i zapisujemy wartość do HTML-a. Na razie w żaden sposób nie aktualizujemy z jej wartością <code>thisProduct</code>, ale możemy zacząć to robić!</p>
<p>Wystarczy więc właśnie w tej metodzie dodać linijkę, która będzie po obliczeniach dodawała do <code>thisProduct</code> nową właściwość np. (<code>priceSingle</code>), do której od razu zapiszemy aktualnie przeliczoną wartość.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Odnajdź w metodzie <code>processOrder</code> miejsce, w którym aktualizujesz cenę w HTML-u. Przed tą linijką dodaj instrukcję, która wyposaży <code>thisProduct</code> w nową właściwość <code>priceSingle</code>. Przypisz do niej wartość tej samej ceny, którą zapisywaliśmy też w HTML-u.</p>
</div>
<p>Od tej chwili, każdorazowe uruchomienie <code>processOrder</code> będzie równało się z aktualizacją <code>thisProduct.priceSingle</code>. A skoro wiemy, że ta metoda uruchamia się przy każdorazowej zmianie jakiejś opcji, to możemy być pewni, że <code>thisProduct.priceSingle</code> będzie zawsze zwracała aktualną cenę jednostkową! Sprytnie, prawda?</p>
<p>Wróć więc teraz do metody <code>prepareCartProduct</code> i dodaj do naszego obiektu dwie nowe właściwości <code>priceSingle</code> i <code>price</code>.</p>
<p><code>priceSingle</code> powinno wskazywać na wartość ceny jednostkowej dostępnej w <code>thisProduct</code> (<code>thisProduct.priceSingle</code>). Tej, o którą przed chwilą zadbaliśmy. Druga właściwość, <code>price</code>, powinna być za to ceną całkowitą, a więc ceną jednostkową pomnożoną przez liczbę sztuk.</p>
<h4>Opcje produktu</h4>
<p>Nieźle, została nam już tylko jedna rzecz – przygotowanie dostępu do wybranych opcji. Tym zajmiesz się za moment w ramach zadania. Na razie w obiekcie <code>productSummary</code> przygotuj tylko nową właściwość <code>params</code>. Póki co, niech będzie pustym obiektem.</p>
<p>Na końcu dodaj do naszej metody słowo kluczowe <code>return</code>, w taki sposób, aby funkcja zwracała właśnie nasz cały obiekt podsumowania. Teraz wystarczy wykorzystać ją w metodzie <code>addToCart</code>. Zamiast przekazywać do <code>thisApp.cart.add</code> cały obiekt <code>thisProduct</code>, przekazuj to, co zwróci właśnie metoda <code>thisProduct.prepareCartProduct</code>.</p>
<p>Teraz próba dodania produktu do koszyka powinna zakończyć się pokazaniem w konsoli znacznie mniejszego obiektu. Taki właśnie jest nasz plan. Koszyk ma otrzymać obiekt tylko z tyloma informacjami, ile naprawdę potrzebuje.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-10.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-10.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Musisz przyznać, że wygląda to znacznie lepiej. No i przede wszystkim koszyk nie otrzymuje zbędnych informacji.</p>
<p>Przekazanie obiektu z opcjami będzie już Twoim zadaniem. Nie bój się jednak, nie będzie ono wcale takie trudne, jak mogłoby się wydawać.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Stwórz nową metodę w klasie <code>Product</code> i nazwij ją <code>prepareCartProductParams</code>. Jej zadaniem powinno być przejście po wszystkich kategoriach produktu, następnie po ich opcjach, sprawdzenie czy są one wybrane i wygenerowania podsumowania w formie małego obiektu.</p>
<p>Jego końcowa struktura będzie mniej więcej taka:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-11.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-11.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Co możemy wyczytać z tego screenu? Chcemy, aby nasza funkcja na pewno zwróciła nowy obiekt. Każda kategoria (<code>param</code>) powinna być w nim nową właściwością. Na przykładzie jest nią <code>ingredients</code>. Właściwość taka powinna być nowym obiektem, który posiada dwie własne właściwości: <code>label</code> z nazwą kategorii (<code>param</code>) oraz obiekt <code>options</code> z opcjami, które są w danej kategorii zaznaczone.</p>
<p>Każda z opcji w tym obiekcie powinna być właściwością, której klucz (nazwa) to id opcji (np. <code>feta</code>), a wartość to jej pełna nazwa (np. <code>Feta cheese</code>).</p>
<p>Zauważ, że funkcja ta będzie bardzo podobna do metody <code>processOrder</code>. Również będziemy musieli mieć dostęp do formularza, aby mieć informacje, jakie opcje są wybrane. Również będziemy musieli przejść po wszystkich kategoriach i po każdej z opcji w nich dostępnych. Dla każdej opcji będziemy musieli tak samo sprawdzić, czy jest wybrana, czy nie. Tylko że teraz zamiast ceny, będziemy po prostu tworzyć obiekt, który ma być "podsumowaniem" wybranych opcji.</p>
<p>Spróbuj na spokojnie zastanowić się jak można to "ugryźć". Najlepiej zacznij od skopiowania zawartości metody <code>processOrder</code> do <code>prepareCartProductParams</code> i zastanowienia się, jak musimy ją zmodyfikować. Przypomnijmy, że wynikiem jej działania ma być zwrócenie nowego obiektu z podsumowaniem wybranych opcji. Czyli jeśli w pizzy wybrano by np. jako <code>toppings</code> opcje <code>salami</code> i <code>olives</code>, a jako <code>sauce</code> opcję <code>tomato</code>, to funkcja powinna zwrócić taki obiekt:</p>
<pre><code class="language-js">{
  toppings: {
    label: 'Toppings',
    options: {
      salami: 'Salami',
      olives: 'Olives',
    }
  },
  sauce: {
    label: 'Sauce',
    options: {
      tomato: 'Tomato'
    }
  }
  ...
}
</code></pre>
<p>Poniżej zapisaliśmy kilka wskazówek. Każda kolejna odkrywa coraz więcej kodu. Postaraj się jednak nie zaglądać do nich dopóki naprawdę nie będziesz mieć już żadnego pomysłu. W swojej pracy wspomagaj się również debuggerem i <code>console.log</code>.</p>
</div>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-tmdR93YFU-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż wskazówka #1</a>
    <a href="#collapse-tmdR93YFU-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj wskazówka #1</a>
  </span>
</p>
<div id="collapse-tmdR93YFU-toggle" class="collapse">
<h4>Pierwsze kroki</h4>
<p>Zaczniemy od małej podpowiedzi, od czego warto zacząć.</p>
<p>Po skopiowaniu zawartości metody <code>processOrder</code>:</p>
<ol>
<li>Zacznij od pozbycia się zbędnego kodu, a więc wszystkiego, co związane z <code>price</code>. Zarówno utworzenia stałej, jak i zwiększania/zmniejszania ceny, czy też końcowego kodu, który zajmował się ustalaniem <code>priceSingle</code> oraz pokazywaniem wartości w HTML-u. Nasza nowa metoda w żaden sposób nie ma się bowiem zajmować ceną.</li>
<li>Usuń cały kod odpowiedzialny za pokazywanie/chowanie obrazka reprezentującego daną opcję.</li>
<li>Uprość ify, które sprawdzają, czy opcja jest wybrana. Tak naprawdę teraz nie interesuje nas to, czy opcja była domyślna, czy nie. Wystarczy sprawdzenie, czy była wybrana, czy nie. Jeśli tak, to musimy zawrzeć ją w obiekcie podsumowania. Jeśli nie, to nie.</li>
<li>Dodaj przed oboma pętlami nowy pusty obiekt. Nazwij go np. <code>params</code>. Zadbaj też o to, aby funkcja zwracała go na końcu. To właśnie do tego obiektu powinny być dodawane kolejne właściwości opisujące kategorie.</li>
</ol>
<p>Teraz pozostaje Ci już tylko zadbanie o to, aby <code>params</code> otrzymywało po drodze odpowiednie właściwości kategorii, oraz żeby każda z nich otrzymywała informacje o opcjach, które są w nich zawarte.</p>
</div>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-onyGN0u2e3-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż wskazówka #2</a>
    <a href="#collapse-onyGN0u2e3-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj wskazówka #2</a>
  </span>
</p>
<div id="collapse-onyGN0u2e3-toggle" class="collapse">
<h4>To za mało?</h4>
<p>Jeśli pierwsza podpowiedź do dla Ciebie za mało, to poniżej możesz znaleźć naszą metodę już po krokach z poprzedniej wskazówki, wraz z małym dodatkiem – kodem, który dodaje do <code>params</code> nową właściwość dla każdej kategorii!</p>
<pre><code class="language-js">prepareCartProductParams() {
  const thisProduct = this;

  const formData = utils.serializeFormToObject(thisProduct.form);
  const params = {};

  // for very category (param)
  for(let paramId in thisProduct.data.params) {
    const param = thisProduct.data.params[paramId];

    // create category param in params const eg. params = { ingredients: { name: 'Ingredients', options: {}}}
    params[paramId] = {
      label: param.label,
      options: {}
    }

    // for every option in this category
    for(let optionId in param.options) {
      const option = param.options[optionId];
      const optionSelected = formData[paramId] &amp;&amp; formData[paramId].includes(optionId);

      if(optionSelected) {
        // option is selected!
      }
    }
  }

  return params;
}
</code></pre>
<p>Teraz pozostaje Ci już tylko dodanie do pętli warunkowej sprawdzającej, czy opcja jest wybrana, kodu, który doda do <code>params[paramId].options</code> konkretną opcję.</p>
</div>
<p>Teraz mamy już funkcję, która potrafi zaoferować nam zgrabnie podsumowanie opcji aktualnie wybranych w produkcie.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Bez stresu</h4>
<p>Możliwe, że wymyślenie, jak powyższa funkcja ma działać, nie było dla Ciebie zbyt łatwe i konieczne było wspomożenie się wskazówką/wskazówkami. Nie musisz się z jednak tego powodu stresować. Pisanie funkcji od zera, znajdowanie podobieństw i radzenie sobie z tak dużymi projektami, jak nasza pizzeria, przychodzi z czasem. Z większą ilością praktyki. Jeśli więc, koniec końców, jesteś w stanie wytłumaczyć, jak ta funkcja teraz działa, to spokojnie możesz iść dalej. Więcej na tym etapie od Ciebie nie oczekujemy.</p>
</div>
<p>Pozostaje nam teraz wykorzystać tę funkcję.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Nasza metoda jest już gotowa, ale funkcja <code>prepareCartProduct</code> wciąż jej nie wykorzystuje. Musimy to zmienić. Zmodyfikuj funkcję <code>prepareCartProduct</code> tak, aby jako wartość <code>params</code> ustawiała to, co zwraca metoda <code>prepareCartProductParams</code>.</p>
</div>
<p>Na końcu sprawdź, czy wszystko działa poprawnie. Spróbuj ponownie dodać do koszyka pizzę i sprawdź, co otrzyma nasz koszyk.</p>
<p>Powinien otrzymywać mniej więcej coś w tym stylu:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-12.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-12.png" alt="image" style="width: auto; max-width: 50%;"></a>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Inna droga</h4>
<p>Może Cię zastanawiać jeszcze jedna rzecz. Czy nie dałoby się jakoś połączyć metod <code>processOrder</code> i <code>prepareCartProductParams</code> w jedną? W końcu są bardzo podobne. Odpowiedź jest prosta – dałoby się. Dzięki temu nie powtarzalibyśmy się drugi raz z podobnym kodem. Dlaczego więc tego nie zrobiliśmy?</p>
<p>Na etapie nauki, wydajność kodu czy też maksymalne jego skracanie nie jest najważniejsze. Znacznie istotniejsza jest po prostu praktyka. Dzięki temu, że wymagaliśmy od Ciebie stworzenia zupełnie nowej metody, ale podobnej do <code>processOrder</code> byliśmy w stanie przetrenować naszą wiedzę po raz drugi. Dzięki czemu zapewne i sama oryginalna metoda stała się dla Ciebie znacznie czytelniejsza.</p>
</div>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">generowanie elementów DOM</span></h3>
                        <div class="task-content">
                            <p>Mamy już wszystkie niezbędne informacje, teraz pozostaje jeszcze wykorzystać je do wygenerowania i dodania kodu HTML do koszyka. W rezultacie, kliknięcie buttona "ADD TO CART" powinno wyświetlać produkt w koszyku!</p>
<p>Zacznij od dodania do metody <code>getElements</code> koszyka nowej referencji. Pamiętamy o zdefiniowaniu <code>thisCart.dom.productList</code> powinien być równy odpowiedniemu elementowi z HTML-a. Dokładnie liście produktów. Odpowiedni selektor znajdziesz w stałej <code>select</code>.</p>
<p>Następnie przejdź do znalezienia metody <code>Product.renderInMenu</code>. Tak naprawdę robi ona praktycznie to samo, czego będziemy oczekiwać po metodzie <code>Cart.add</code>. Generuje element DOM. Wtedy był to cały duży div produktu. Teraz będzie to mały div podsumowania produktu, który będzie znajdować się w koszyku. Idea jest jednak taka sama. Chcemy wygenerować jakiś element na podstawie szablonu. Mocno będziemy się więc na niej opierać.</p>
<p>Wejdź więc do metody <code>Cart.add</code> i opierając się na metodzie <code>Product.renderInMenu</code>:</p>
<ol>
<li>Za pomocą odpowiedniego szablonu stwórz kod HTML i zapisz go w stałej <code>generatedHTML</code>. Jako obiekt z danymi dla szablonu, wykorzystaj oczywiście nasz z podstawowymi informacjami o produkcie obiekt otrzymany w argumencie.</li>
<li>Następnie ten kod zamień na element DOM i zapisz w następnej stałej – <code>generatedDOM</code>.</li>
<li>Dodaj ten element DOM do <code>thisCart.dom.productList</code> (użyj metody <code>appendChild</code>)</li>
</ol>
<h4>Oczekiwany efekt</h4>
<p>W koszyku powinien pojawić się produkt, który zawiera poprawne informacje – liczbę, nazwę, opcje, cenę (za wszystkie sztuki) oraz guziki edycji i usuwania.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-07.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-07.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Pamiętaj, że widget liczby sztuk i guziki jeszcze nie działają – właśnie tym zajmiemy się za chwilę!</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/607289" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/1dab9466923da6f659da44be373b131a0626f6b3">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1976" class="card submodule completed" data-bootcamp-user-submodule-id="607290" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.5. <span>CartProduct &ndash; klasa pozycji w koszyku</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Musimy teraz pomyśleć trochę o przyszłości. O tym, jak będzie wyglądało wysyłanie zamówienia. Serwer na pewno będzie musiał być w stanie zapisać dokładne informacje o zamówieniu. Jakie produkty były wybrane, z jakimi opcjami i za ile. Dlatego też nasz koszyk na pewno powinien być mu je w stanie dostarczyć.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/pizza-menu-sm.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/pizza-menu-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/pizza-menu.png 2x"  class="img-inline img-right">
<p>Nasz koszyk na razie dostaje informacje o produkcie, który chcemy dodać, a te są przekazywane dalej, do metody <code>add</code>. Jest to cały obiekt podsumowania z nazwą, id itd. Tak naprawdę wykorzystujemy go jednak tylko jednorazowo do wygenerowania element HTML-u, który ma nasz produkt reprezentować (konkretnie do naszej listy w HTML-u) i to... tyle.</p>
<p>Tak naprawdę JS nigdzie nie zapisuje tych danych "na później", a przecież będziemy ich potrzebować! W końcu ktoś kliknie na przycisk "order" i w takiej sytuacji będzie musieli utworzyć jakieś podsumowanie wybranych produktów, aby wysłać je do serwera. Jak to zrobimy nie mając nigdzie w JS-ie informacji, co było kiedyś wybrane? Tak naprawdę jedynym wyjściem byłoby przejście po elementach HTML-u i próbowanie wyczytać z nich odpowiednie informacje... Trochę mało profesjonalny pomysł, nie sądzisz?</p>
<p>Możemy to jednak łatwo naprawić. Zauważ, że w naszej klasie koszyka istnieje już tablica <code>products</code>. Czeka na nas właśnie po to, aby rozwiązać nasz problem. Wystarczy ją wykorzystać!</p>
<p>Jeśli każdorazowo przy dodawaniu produktu do koszyka, będziemy zapisywać obiekt jego podsumowania do tablicy <code>thisCart.products</code>, to będzie ona dla nas swego rodzaju podsumowaniem. Kiedy tylko będziemy mieli taką ochotę, będziemy mogli wejść do tej tablicy i sprawdzić, jakie aktualnie elementy są w naszym koszyku, włącznie z dokładnymi informacjami na ich temat, takich jak cena czy liczba sztuk.</p>
<p>Możesz przetestować ten pomysł samodzielnie. Na końcu metody <code>Cart.add</code> dodaj te dwie linie kodu:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-09.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-09.png" alt="image" style="width: auto;"></a>
<p>Następnie na stronie dodaj do koszyka 1 sztukę sałatki, a potem 5 sztuk tej samej potrawy.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-13.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-13.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Jak widzisz, nie było to takie trudne!</p>
<p>Na tym etapie warto może jednak się zatrzymać. Za chwilę będziemy zajmować się kolejnymi funkcjonalnościami, które będą się tyczyć konkretnie samych koszykowych produktów. Mamy tu na myśli dodanie obsługi widgetu ilości sztuk czy dodanie obsługi buttonu "usuń". Czy tego typu rzeczy naprawdę powinny znajdować się w klasie <code>Cart</code>? Czy tyczą się całego koszyka? Nie. Tak naprawdę tyczą się konkretnych produktów w nim zawartych. Znacznie czytelniej byłoby więc wyciągnąć funkcjonalności produktu w koszyku do osobnej klasy. A że pomoże to nam w utrwaleniu wiadomości na temat klas i instancji, to właśnie tym tropem teraz podążymy! Każdy produkt w koszyku będzie u nas nową instancją specjalnej klasy <code>CartProduct</code>! To ona będzie odpowiedzialna za funkcjonowanie pojedynczej pozycji w koszyku.</p>
<p>Podsumowując, chcemy, aby klasa <code>Cart</code> zajmowała się całym koszykiem, jego głównymi funkcjonalnościami, a klasa <code>CartProduct</code> pojedynczymi produktami, które się w nim znajdują.</p>
<h3>Tworzenie klasy</h3>
<p>Spróbuj samodzielnie poradzić sobie ze stworzeniem klasy <code>CartProduct</code>. Dodaj ją pod klasą <code>Cart</code>, czyli tuż przed deklaracją obiektu <code>app</code>.</p>
<p>Zacznij od konstruktora.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie 1</h4>
<p>Jakie informacje będą potrzebne do funkcjonowania klasy <code>CartProduct</code>? Na pewno musi wiedzieć, jaki produkt ma w danej chwili obsługiwać oraz mieć dostęp do jego reprezentacji w HTML-u, którą stworzyła klasa <code>Cart</code>.</p>
<p><strong>Konstruktor</strong> powinien więc przyjąć dwa argumenty: <code>menuProduct</code> oraz <code>element</code>. Pierwszy będzie przyjmował referencję do obiektu podsumowania, a drugi referencję do utworzonego dla tego produktu elementu HTML-u (<code>generatedDOM</code>).</p>
<p>Wewnątrz konstruktora zdefiniuj stałą <code>thisCartProduct</code> i zapisz w niej obiekt <code>this</code>. Następnie postaraj się zapisać w nim wszystkie właściwości z argumentu <code>menuProduct</code>. Przypisz je do pojedynczych właściwości, np. <code>thisCartProduct.id = menuProduct.id</code> itd. Oczywiście robimy to tylko dla naszej wygody.</p>
<p>Następnie zadbaj o to, aby konstruktor wykonał metodę <code>getElements</code>, przekazując jej argument <code>element</code>. Dodaj również <code>console.log</code> wyświetlający <code>thisCartProduct</code>.</p>
</div>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie 2</h4>
<p>Czas utworzyć wspomnianą wcześniej metodę <code>getElements</code> przyjmującą argument <code>element</code>.</p>
<p>W samej metodzie:</p>
<ul>
<li>zdefiniuj stałą <code>thisCartProduct</code> i zapisz w niej obiekt <code>this</code>,</li>
<li>stwórz pusty obiekt <code>thisCartProduct.dom</code>,</li>
<li>stwórz właściwość <code>thisCartProduct.dom.wrapper</code> i przypisz jej wartość argumentu <code>element</code> (wiemy, że to referencja do oryginalnego elementu DOM),</li>
<li>stwórz kolejnych kilka właściwości obiektu <code>thisCartProduct.dom</code> i przypisz im elementy znalezione we wrapperze; te właściwości to: <code>amountWidget</code>, <code>price</code>, <code>edit</code>, <code>remove</code> (ich selektory znajdziesz w <code>select.cartProduct</code>).</li>
</ul>
</div>
<p>Efektem Twojej pracy powinna być wyświetlana w konsoli (w momencie dodania do koszyka) instancja klasy <code>CartProduct</code>.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/new-cart-product.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/new-cart-product.png" alt="image" style="width: auto; max-width: 50%;"></a>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Dużo podobieństw...</h4>
<p>Możesz zauważyć, że nasze klasy są do siebie często podobne. Każda korzysta np. z idei zapisywania <code>this</code> pod "wygodniejszą" nazwą. Każda używa również metody o nazwie <code>getElements</code>, aby przygotować referencje do elementów w HTML. Czy to jakieś ogółem przyjęte praktyki?</p>
<p>W żadnym wypadku. Tak naprawdę równie dobrze moglibyśmy korzystać z samego "gołego" <code>this</code> albo nazwać metodę do przygotowania referencji do HTML <code>prepareDOMRefs</code>. To kwestia naszego wyboru. Jeśli już jednak zdecydujemy się na jakieś nazwy czy praktyki, to najlepiej trzymać się ich w całym projekcie. Dzięki temu znacznie łatwiej będzie Ci nawigować po klasach w przypadku błędów, czy też rozwoju aplikacji. Dlatego też staramy się tego trzymać podczas pracy nad naszym projektem.</p>
</div>
<h3>Tworzenie instancji</h3>
<p>Wróć teraz do metody <code>Cart.add</code> i znajdź linię:</p>
<pre><code class="language-js">      thisCart.products.push(menuProduct);
</code></pre>
<p>Zamień w niej <code>menuProduct</code> na <code>new CartProduct(menuProduct, generatedDOM)</code>. W ten sposób jednocześnie stworzymy nową instancję klasy <code>new CartProduct</code> oraz dodamy ją do tablicy <code>thisCart.products</code>. Dobrze wiesz, że dzięki temu będziemy mieli stały dostęp do instancji wszystkich produktów. Właśnie poprzez tę tablicę. Bardzo wygodne, prawda?</p>
<p>Wykonaj teraz ponownie test, który robiliśmy wcześniej – dodaj do koszyka 1 sałatkę, a następnie 5 sałatek. Sprawdź ostatni komunikat w konsoli. Ponownie mamy tablicę z dwoma elementami, ale nie są to już zwykłe obiekty, a instancje klasy <code>CartProduct</code>. Owszem, wciąż posiadają te same startowe właściwości (<code>id</code>, <code>name</code> itd.), ale również kilka nowych. Mają również własne metody!</p>
<p>Właśnie o to nam chodziło! W dłuższym rozrachunku naprawdę docenisz ten podział.</p>
<h3>Obsługa widgetu ilości sztuk</h3>
<p>Jak widzisz, produkty w koszyku mają swoje własne widgety liczby sztuk. Co więcej, kiedy najedziesz na nie kursorem, zobaczysz że mają też guziki z plusem i minusem. Do ich działania wykorzystamy klasę <code>AmountWidget</code>, którą stworzyliśmy w poprzednim module!</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-02.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-02.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Wzorując się na metodzie <code>Product.initAmountWidget</code>, spróbuj stworzyć analogiczną w klasie <code>CartProduct</code>. Całość będzie bardzo podobna. Zadbaj o to, aby stworzyć nową instancję tej klasy (<code>AmountWidget</code>), przekazując jej odpowiedni element, na którym ma pracować. Nie zapomnij również o dodaniu nasłuchiwacza. Sama funkcja do niego przekazywana może być jednak na razie pusta.</p>
<p>Zadbaj też o to, aby ta metoda była uruchomiana w konstruktorze klasy <code>CartProduct</code>. Chcemy bowiem, aby wywoływała się od razu po utworzeniu instancji.</p>
</div>
<p>Czas zająć się zawartością handlera eventu. Co powinno się stać, kiedy użytkownik zmieni liczbę sztuk danej pozycji w koszyku? Zakładając, że na razie nie interesuje nas koszyk jako całość, tylko ta jedna pozycja w koszyku?</p>
<p>Na pewno musimy na nowo ustawić wartości dla dwóch właściwości, początkowo ustawianych w konstruktorze – <code>thisCartProduct.amount</code> i <code>thisCartProduct.price</code>. Następnie musimy wyświetlić na stronie nową przeliczoną cenę tego produktu (z uwzględnieniem liczby sztuk).</p>
<p>Widzisz? Właśnie o tym mówiliśmy wcześniej. Po to przekazywaliśmy właściwość <code>priceSingle</code>, żeby takie obliczenie było możliwe i stosunkowo łatwe do przeprowadzenia. Nie potrzebujemy informacji o formularzu, czy cenach opcji, które zostały wybrane. Mamy od razu gotową cenę pojedynczej sztuki z konkretnymi opcjami i wystarczy zadbać o to, aby była ona pomnożona przez zmienioną liczbę sztuk. Właśnie to da nam nową wartość <code>thisCartProduct.price</code>.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Zadbaj o to, aby funkcja w nasłuchiwaczu (nasz handler) poprawnie aktualizowała wartość <code>thisCartProduct.amount</code> oraz <code>thisCartProduct.price</code>.</p>
<p>Powinna również aktualizować kwotę widoczną w samej reprezentacji HTML-a tego produktu. To będzie jednak dość proste zadanie. Na tym etapie cena w <code>thisCartProduct.price</code> będzie już zaktualizowana. Wystarczy więc znaleźć referencję do odpowiedniego elementu w HTML i zaktualizować jego wartość. Przeszukaj w tym celu metodę <code>getElements</code>. Na pewno jest już tam przygotowana odpowiednia referencja.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-VLYHR5l-Q-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż podpowiedź 1</a>
    <a href="#collapse-VLYHR5l-Q-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj podpowiedź 1</a>
  </span>
</p>
<div id="collapse-VLYHR5l-Q-toggle" class="collapse">
<p>Pamiętaj, że aktualna wartość widgetu (czyli liczby sztuk) jest dostępna pod odpowiednią właściwością <code>thisCartProduct.amountWidget</code></p>
</div>
</div>
<p>Teraz widget liczby sztuk powinien już działać dla każdej pozycji dodanej do koszyka. Co więcej, cena tej pozycji powinna zmieniać się w zależności od wybranej liczby produktów!</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-14.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-14.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<h3>Sumowanie koszyka</h3>
<p>Zanim zajmiemy się wyświetlaniem sum cen i liczby pozycji w koszyku – to dobry moment, aby ponownie usunąć wszystkie wystąpienia <code>console.log</code>. Dzięki temu będziemy mogli dalej pracować z czystą konsolą.</p>
<p>Oczywiście teraz będzie pracować na całym koszyku. Wracamy więc do klasy <code>Cart</code>.</p>
<p>Nasz koszyk zawiera cztery informacje:</p>
<ol>
<li>suma liczby sztuk zamawianych produktów,</li>
<li>cena "Subtotal", czyli suma cen pozycji w koszyku,</li>
<li>koszt dostawy,</li>
<li>cena "Total", czyli suma "Subtotal" oraz ceny dostawy. Jest ona wyświetlana dwa razy: w nagłówku koszyka oraz w jego podsumowaniu.</li>
</ol>
<p>Musimy zadbać o odpowiednią aktualizację tych informacji. Naszym zadaniem musi być więc stworzenie nowej metody. Takiej, która przechodząc po kolei po wszystkich produktach, wyliczy nam wszystkie kwoty.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Stworzenie tej metody będzie Twoim zadaniem.</p>
<p>Dodaj do klasy <code>Cart</code> metodę <code>update</code> i – jak zwykle – zadeklaruj w niej stałą <code>thisCart</code>.</p>
<p>Zacznij od przygotowania stałej z informacją o cenie dostawy. Nazwij ją <code>deliveryFee</code> i nadaj jej wartość zapisaną w odpowiedniej właściwości obiektu <code>settings</code>.</p>
<p>Następnie dodaj dwie kolejne stałe <code>totalNumber</code> i <code>subTotalPrice</code>. Pierwsza będzie odpowiadała całościowej liczbie sztuk, a druga zsumowanej cenie za wszystko (chociaż bez kosztu dostawy). Każdej z nich przypisz startowo wartość <code>0</code>.</p>
<p>W kolejnym kroku dodaj pętle <code>for...of</code>, która przejdzie po <code>thisCart.products</code>. Zadbaj o to, aby zwiększała <code>totalNumber</code> o liczbę sztuk danego produktu. Podobnie zwiększ również <code>subTotalPrice</code> o jego cenę całkowitą (właściwość <code>price</code>).</p>
<p>Po zamknięciu pętli zapisz dodatkową właściwość koszyka – <code>thisCart.totalPrice</code>. Jej wartością ma być nasza cena całkowita, czyli kwota potrzebna do kupna wszystkich produktów z koszyka i koszt dostawy.</p>
<p>Uwaga! Pamiętaj, że jeśli w koszyku nie ma ani jednego produktu, to nie ma sensu w cenie końcowej wliczać <code>deliveryFee</code>. Nie ma produktów, więc nie ma dostawy, czyli nie ma kosztów dostawy. Wtedy cena końcowa powinna być a po prostu równa zero. Dlatego na pewno przy ustalaniu <code>thisCart.totalPrice</code> nie obędzie się bez jakiegoś ifa, który sprawdzi, czy w ogóle jest sens doliczać <code>deliveryFee</code>.</p>
<p>Dlaczego tym razem, zamiast tworzyć nową stałą, przypisujemy ją jako właściwość? Z prostego powodu. Stałe są dostępne tylko w danym zakresie. W tym przypadku w zakresie funkcji <code>update</code>. Właściwości są za to dostępne w całej instancji. Tym samym możemy je używać również w innych metodach. <code>deliveryFee</code> czy <code>totalNumber</code> nie będzie nam potrzebne "na zewnątrz", dlatego są one stałymi. <code>totalPrice</code> jednak będziemy już używać w innej metodzie. Tej, która będzie odpowiedzialna za wysyłkę danych do serwera. Musimy więc mieć do niej dostęp na zewnątrz.</p>
<p>Oczywiście możesz się teraz zastanawiać, skąd masz to wiedzieć na tym etapie. Odpowiedź jest prosta – nie musisz. Tak naprawdę, gdybyśmy na razie skorzystali ze zwykłej stałej, nic by się nie stało. Później, podczas pisania funkcji służącej do wysyłania danych do serwera, i tak zauważylibyśmy potrzebę dostępu do tej informacji. Nic nie stałoby na przeszkodzie, żeby dopiero wtedy zrobić z naszej stałej właściwość. My wyprzedzamy teraz trochę przyszłe potrzeby, ale tylko dlatego, że wiemy, jak całość na końcu będzie wyglądać. Nie oczekujemy jednak podobnego przewidywania od Ciebie. To nie jest jeszcze ten etap nauki, w którym mielibyśmy prawo tego oczekiwać.</p>
<p>Na końcu zadbaj o to, aby konsola pokazała Ci wszystkie stałe oraz właściwość <code>totalPrice</code>. Pozwoli Ci to na przetestowanie, czy całość działa poprawnie.</p>
</div>
<p>Zanim jednak zabierzesz się za testy, dodaj jeszcze wywołanie metody <code>update</code> na końcu metody <code>add</code>! Tak, aby każdorazowe dodanie produktu, faktycznie odpalało tę metodę. Dopiero wtedy sprawdź, czy po każdym dodaniu produktu do koszyka zmieniają się wartości tych właściwości.</p>
<p>Pamiętaj – na razie obsługujemy tylko dodawanie nowych pozycji. Zmiana liczby sztuk produktu w koszyku jeszcze nie będzie powodować zmiany sum!</p>
<h3>Wyświetlenie aktualnych sum</h3>
<p>Pozostaje nam jeszcze wyświetlenie aktualnych sum. Żeby było to możliwe, musimy jednak zadbać o to, aby nasza klasa miała dostęp do odpowiednich elementów w HTML. Tych, które pokazują cenę, liczbę sztuk itd.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>W metodzie <code>getElements</code> dodaj do obiektu <code>dom</code> cztery nowe właściwości:</p>
<ol>
<li><code>deliveryFee</code> – powinna być referencją do elementu pokazującego koszt przesyłki.</li>
<li><code>subTotalPrice</code> – powinna być referencją do elementu pokazującego cenę końcową, ale bez kosztów przesyłki.</li>
<li><code>totalPrice</code> – powinna być referencją do <strong>elementów</strong> pokazujących cenę końcową.</li>
<li><code>totalNumber</code> – powinna być referencją do elementu pokazującego liczbę sztuk.</li>
</ol>
</div>
<p>Teraz możemy wrócić do naszej metody <code>update</code>. Póki co, pokazuje ona wszystkie informacje, ale w konsoli. Musimy zadbać to, aby pokazywała je w HTML-u.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Wróć do metody <code>update</code> i zadbaj o to, aby odpowiednio aktualizowała ona HTML naszego koszyka. W taki sposób, aby użytkownik widział poprawną liczbę sztuk, cenę <code>subTotal</code> oraz całkowitą, a także koszt dostawy. Przy czym, jeśli w koszyku jest zero produktów, to koszt dostawy powinien być równy zero.</p>
<p>Efekt powinien być następujący:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-15.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-15.gif" alt="image" style="width: auto; max-width: 50%;"></a>
</div>
<p>Teraz wszystkie kwoty zamówienia widoczne w koszyku powinny się aktualizować każdorazowo po dodaniu nowego produktu.</p>
<p>Pozostaje jeszcze jedna kwestia – sumy nie zmieniają się po zmianie liczby sztuk, a powinny.</p>
<h3>Aktualizacja sum po zmianie ilości</h3>
<p>Chcielibyśmy, aby zmiana ilości sztuk w instancji <code>CartProduct</code> również uruchamiała metodę <code>update</code>, ale mamy pewien problem. Zmiana liczby sztuk zachodzi w klasie <code>CartProduct</code>, a metoda <code>update</code> znajduje się w klasie <code>Cart</code>.</p>
<p>Wiesz już, że <code>Cart</code> ma w miarę łatwy dostęp do instancji <code>CartProduct</code>. Np. w metodzie <code>update</code> bez problemu dochodziliśmy do <code>price</code> pojedynczych produktów. W końcu instancje klasy <code>CartProduct</code> to, koniec końców, po prostu obiekty. Gorzej jednak z komunikacją w drugą stronę...</p>
<p>Wbrew pozorom jednak, rozwiązanie w naszej sytuacji będzie akurat bardzo proste. Wykorzystamy do tego event, który jest już generowany przez <code>AmountWidget</code> w instancjach <code>CartProduct</code>. Musimy go jednak nieco zmodyfikować. Znajdź klasę <code>AmountWidget.announce</code> i zmień tę linię:</p>
<pre><code class="language-js">      const event = new Event('updated');
</code></pre>
<p>na ten kod:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-11.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-11.png" alt="image" style="width: auto;"></a>
<p>Co tu się właściwie stało? Używamy teraz innego rodzaju eventu, którego właściwości możemy kontrolować. W tym wypadku włączamy jego właściwość <code>bubbles</code>, która ma bardzo ciekawe działanie. Bez <code>bubbles</code> event jest emitowany tylko na jednym elemencie, na tym, na którym odpalamy <code>dispatchEvent</code>. Z opcją <code>bubbles</code>, ten event będzie nadal emitowany na tym elemencie, ale również na jego rodzicu, oraz dziadku, i tak dalej – aż do samego <code>&lt;body&gt;</code>, <code>document</code> i <code>window</code>. Czy pamiętasz termin <em>bąbelkowanie</em> (propagacja)? Event <code>click</code> bąbelkuje domyślnie, dzięki czemu jest przekazywany od klikniętego elementu do rodzica. W przypadku customowego eventu bąbelkowanie musimy włączyć sami, do czego właśnie przyda nam się <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/bubbles" target="_blank">wbudowana w JavaScript właściwość <code>bubbles</code></a>.</p>
<p>To o tyle ważne, że bardzo ułatwi nam sprawę.</p>
<p>Pomyśl tylko. Sam fakt, że na widgecie w <code>CartProduct</code> ta akcja jest emitowana to już dużo. Moglibyśmy bowiem dojść w <code>Cart</code> do każdego produktu z osobna i przypiąć własny nasłuchiwacz do jego właściwości <code>amountWidget</code>. Wtedy po zmianie liczby sztuk w obojętnie którym produkcie, <code>Cart</code> by o tym wiedział. Taki scenariusz wymagałby jednak dodania po jednym nasłuchiwaczu dla każdego produktu. 20 produktów w koszyku równałoby się np. potrzebie przygotowania aż 20 nasłuchiwaczy... Możesz domyślić się, że nie jest to zbyt wydajny pomysł.</p>
<p>Kiedy jednak wiemy, że <code>event</code> emitowany w pojedynczym produkcie, będzie emitowany również wyżej, do całej listy produktów, całego diva koszyka itd., to możemy to rozegrać inaczej. Ustawiając <strong>jeden</strong> event na sama listę produktów.</p>
<p>Pomyśl tylko. Nieważne, czy zmienimy liczbę sztuk w inpucie produktu pierwszego czy drugiego, najpierw emitowany będzie event w divie widgetu w danym produkcie, ale potem i tak zostanie wyemitowany na elemencie wyżej, całej liście. Nie musimy więc nasłuchiwać w koszyku pojedynczo na input każdego produktu. Wystarczy, że będziemy nasłuchiwać na całą listę (<code>ul</code> z produktami).</p>
<p>Dzięki temu możemy teraz w metodzie <code>Cart.initActions</code> dodać taki kod:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-12.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-12.png" alt="image" style="width: auto;"></a>
<p>Nasłuchujemy tutaj na listę produktów, w której umieszczamy produkty, w których znajduje się widget liczby sztuk, który generuje ten event. Dzięki właściwości <code>bubbles</code> "usłyszymy" go na tej liście. Jest dla nas informacja, że w "którymś" z produktów doszło do zmiany ilości sztuk. Nieważne nawet w którym. Ważne jest to, że w takiej sytuacji należy uruchomić <code>update</code>, aby ponownie przeliczyć kwoty.</p>
<p>Jeśli wszystko poszło dobrze, liczby poszczególnych produktów i wszystkich cen w koszyku już się aktualizują, nie tylko przy dodawaniu nowych produktów, ale także przy zmianie ich liczby.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-16.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-16.gif" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Ten submoduł kończymy bez zadania. I jak? Daliśmy radę!</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1977" class="card submodule completed" data-bootcamp-user-submodule-id="607291" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.6. <span>Usuwanie produktu z koszyka</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Koszyk na stronie naszej pizzerii działa już coraz lepiej – sumy przeliczają się po dodaniu produktu oraz przy zmianie liczby sztuk. Teraz zajmiemy się usuwaniem produktu z koszyka. Wykorzystamy do tego <code>CustomEvent</code>, tak samo, jak zrobiliśmy to przed chwilą, nasłuchując eventu <code>updated</code> generowanego przez <code>AmountWidget</code>.</p>
<h3>Wywołanie eventu</h3>
<p>Zacznijmy od dodania w klasie <code>CartProduct</code> nowej metody:</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-13.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-13.png" alt="image" style="width: auto;"></a>
<p>Podobnie jak w <code>AmountWidget</code>, wykorzystujemy tutaj <code>CustomEvent</code> z właściwością <code>bubbles</code>. Dodatkowo jednak wykorzystujemy właściwość <code>detail</code>. Możemy w niej przekazać dowolne informacje do handlera eventu. To ważna informacja. Kiedy bowiem emitowaliśmy event informujący o zmianie liczby sztuk, to np. <code>Cart</code> nie interesowało, co dokładnie się zmieniło. Sam fakt, że event się wyemitował, był wystarczający. Teraz jednak <code>Cart</code> będzie musiało wiedzieć, co dokładnie trzeba usunąć. W tym przypadku przekazujemy więc wraz z eventem dodatkowo odwołanie do tej instancji, dla której kliknięto guzik usuwania.</p>
<p><code>detail</code> możesz więc rozumieć jako "szczegóły", które mają być przekazywane wraz z eventem.</p>
<p>Ta metoda jeszcze nie jest nigdzie wykorzystywana – zajmiemy się tym teraz. Stwórz więc w klasie <code>CartProduct</code> kolejną metodę (<code>initActions</code>) i wywołaj ją w konstruktorze. W tej metodzie stwórz dwa listenery eventów <code>'click'</code>: jeden dla guzika <code>thisCartProduct.dom.edit</code>, a drugi dla <code>thisCartProduct.dom.remove</code>. Oba mają blokować domyślną akcję dla tego eventu. Guzik edycji na razie nie będzie niczego robił, ale w handlerze guzika usuwania możemy dodać wywołanie metody <code>remove</code>.</p>
<p>To już wszystkie zmiany, jakie musimy wykonać w klasie <code>CartProduct</code>. Możesz dodać <code>console.log</code> do metody <code>remove</code>, aby sprawdzić, czy jest wywoływana po kliknięciu guzika.</p>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">wychwycenie eventu</span></h3>
                        <div class="task-content">
                            <p>Nasz <code>CartProduct</code> powinien już wysyłać event <code>remove</code> – teraz musimy sprawić, aby <code>Cart</code> wychwycił ten event i odpowiednio zareagował.</p>
<p>W metodzie <code>Cart.initActions</code> dodaj listener eventu <code>remove</code>. Ma on działać analogicznie do listenera eventu <code>updated</code>, czyli obserwować element <code>productList</code>.</p>
<p>W handlerze eventu będzie tylko jedna linia kodu – wywołująca metodę <code>thisCart.remove</code> (którą za chwilę napiszemy). Zadbaj o to, aby jako argument przekazywać jej wartość <code>event.detail.cartProduct</code>. Pamiętasz, jak wywołując event, zawarliśmy w nim odwołanie do instancji <code>thisCartProduct</code>? Właśnie w ten sposób (<code>event.detail.cartProduct</code>) teraz ją odbieramy i przekazujemy do metody <code>thisCart.remove</code>.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Stworzenie tej metody będzie już Twoim zadaniem.</p>
<p>Metoda <code>Cart.remove</code> powinna przyjmować jeden argument (właśnie naszą instancję produktu).</p>
<p>Jej zadaniem jest:</p>
<ol>
<li>Usunięcie reprezentacji produktu z HTML-a,</li>
<li>Usunięcie informacji o danym produkcie z tablicy <code>thisCart.products</code>.</li>
<li>Wywołać metodę <code>update</code> w celu przeliczenia sum po usunięciu produktu.</li>
</ol>
<p>Do wykonania zadania konieczne jest wykorzystanie wbudowanych w JS funkcji. Wszystkie informacje o nich znajdziesz poniżej:</p>
<ul>
<li><a href="https://poradnik-js.kodilla.com/arrays" target="_blank">znalezienie indeksu elementu i usuwanie z tablicy</a>,</li>
<li><a href="https://poradnik-js.kodilla.com/modify-dom-elements" target="_blank">usuwanie elementu z DOM</a></li>
</ul>
</div>
<p>W rezultacie, kliknięcie guzika usuwania przy którejkolwiek pozycji w koszyku, powinno:</p>
<ul>
<li>usunąć tę pozycję z koszyka,</li>
<li>wyświetlić sumy (liczby i cen) obliczone bez usuniętego produktu.</li>
</ul>
<p>Końcowy efekt powinien być następujący:</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-17.gif" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-17.gif" alt="image" style="width: auto; max-width: 50%;"></a>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/607291" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/6e65181361cc28af6e56d3933ee5e2b383cf6944">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1978" class="card submodule completed" data-bootcamp-user-submodule-id="607292" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.7. <span>AJAX i API &ndash; wprowadzenie</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Za nami sporo pracy! Kiedy zerkniesz na stronę swojej pizzerii, przekonasz się, że udało Ci się zaimplementować kilkanaście złożonych funkcjonalności. Strona potrafi wyświetlać produkty oraz ich opcje, użytkownik może konfigurować zamówienie, a koszyk na stronie dynamicznie przelicza ceny produktów. Jak na ten etap to bardzo dużo!</p>
<p>Jednakże dotychczas wszystkie informacje na temat produktów są zapisane "na sztywno" w statycznym pliku (<code>data.js</code>). Jak może już się domyślasz, to rozwiązanie nie jest najlepsze. Dużo bardziej profesjonalny i efektywny sposób to przechowywanie danych na serwerze i pobieranie ich dynamicznie do klienta, kiedy zajdzie taka potrzeba. Już za moment nauczymy się, jak się do tego zabrać – pomocne nam będą dwa bardzo obecnie popularne narzędzia, czyli <strong>AJAX</strong> i <strong>API</strong>. Żaden dobry frontend developer nie może się bez nich obyć!</p>
<h3>Frontend vs Backend</h3>
<p>Zanim przejdziemy jednak do szczegółów, wyjaśnijmy, czym w ogóle jest serwer.</p>
<p>Tak naprawdę serwer to, najprościej mówiąc, jakiś komputer udostępniający użytkownikowi lub użytkownikom (klientom) swoje zasoby. Zasobami mogą być po prostu pliki, bazy danych, albo np. strony internetowe.</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-18.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-18.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Serwer może mieć bardzo różne zastosowania. Istnieją serwery FTP (serwery plików), poczty, telnet (zdalna obsługa komputera), czy WWW. Nas interesuje właśnie ten ostatni, który pozwala na serwowanie stron internetowych oraz prostą komunikację za pomocą protokołu HTTP.</p>
<p>Może Ci się wydawać, że to zupełna nowość, ale to nieprawda. Zauważ, że kiedy uruchamiamy naszą stronę za pomocą task runnera (a dokładnie paczki <code>browser-sync</code>), to uruchamiamy już jeden serwer! Serwer dostępny pod adresem <code>localhost:3000</code> i udostępniający naszą stronę (plik <code>index.html</code>). Owszem, nie tworzyliśmy go sami, całą robotę brała na siebie paczka <code>browser-sync</code>, ale już z takiego korzystaliśmy. Jedyną nowością, która się więc za chwilę pojawi, jest to, że na razie tworzyliśmy serwer, który tylko uruchamia zwykłą stronę internetową, a teraz stworzymy drugi, znacznie ciekawszy, który będzie zajmował się udostępnianiem danych!</p>
<h4>Cienka granica</h4>
<p>Podział pomiędzy frontedenem i backendem jest już od dłuższego czasu bardzo rozmyty. Wcześniej ta granica była dość mocno zarysowana. Backend zajmował się całą logiką aplikacji oraz kontaktem z bazą danych, a frontend obsługiwał tylko komunikację z użytkownikiem. Wraz z rozwojem JS-a, sytuacja uległa zmianie. Na tym etapie kursu wiesz, że nawet bez wykorzystania serwera jesteśmy w stanie zbudować całkiem skomplikowane aplikacje. Faktycznie JS jest teraz o wiele bardziej funkcjonalny, co wpływa na zmianę balansu – coraz częściej frontend zajmuję się większością logiki aplikacji, a backend pełni drugorzędną funkcję. Bardzo często sprowadza się ona jedynie do roli pośrednika do bazy danych. W takiej sytuacji mówimy o serwerach API.</p>
<p>Taką rolę będzie pełnił również nasz nowy serwer. Nie możemy komunikować się z bazą danych wprost z poziomu klienta (naszej strony internetowej). Serwer jednak ma już taką możliwość. Dlatego też będziemy wykorzystywać nasz nowy serwer właśnie jako pośrednika do bazy danych. Chcemy pobrać dane? Wysyłamy prośbę (request) do serwera, ten łączy się z bazą, pobiera takie dane i zwraca je nam w odpowiedzi (response). Chcemy zmienić coś w bazie? Może np. dodać jakieś dane? Musimy połączyć się z serwerem (request) i powiedzieć mu o co chodzi. Serwer połączy się z bazą, doda dane, a następnie zwróci nam informacje o sukcesie czy porażce (response).</p>
<a href="https://uploads.kodilla.com/bootcamp/wdp/09/09-19.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/wdp/09/09-19.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Spójrz na powyższy schemat. Powinien Ci trochę bardziej rozjaśnić ten pomysł.</p>
<p>Pamiętaj jednak, że nie zawsze musi tak być. Wciąż istnieje mnóstwo aplikacji i stron, w których główną rolę odgrywa serwer. Tak działają np. wszystkie blogi oparte na popularnym systemie Wordpress.</p>
<h3>Co to jest AJAX?</h3>
<p>No dobrze. Wiemy już, że klient nie ma wprost dostępu do bazy danych. Dlatego też łączy się z serwerem API i dopiero ten, jako pośrednik, się z nią komunikuje. Następnie zwraca odpowiedź, którą otrzyma, klientowi. Jednak właściwie jak klient (strona internetowa) może wykonać taki request? Odpowiedź brzmi <strong>AJAX</strong>.</p>
<p>Wśród młodych developerów AJAX często traktowany jest jak czarna magia, której opanowanie wymaga nie lada zdolności. Nic bardziej mylnego! AJAX nie jest trudny ani skomplikowany – za chwilę zobaczysz, jak za pomocą kilku linijek kodu możemy komunikować się z serwerem.</p>
<p>AJAX (<em>Asynchronous JavaScript and XML</em>) jest <strong>asynchronicznym zapytaniem do serwera</strong>. Słowo <em>asynchroniczny</em> oznacza, że nasz kod JS może dalej pracować podczas oczekiwania na odpowiedź serwera.</p>
<p>O co chodzi? W tradycyjnym podejściu (bez AJAX-a), kiedy użytkownik np. klika link na stronie lub wysyła formularz, przeglądarka przekazuje zapytanie do serwera. Serwer w odpowiedzi odsyła nowy HTML, który przeglądarka wyświetla w miejsce poprzedniego. Skutkuje to dobrze Ci znanym przeładowaniem strony, by nowe dane mogły być wyświetlone.</p>
<p>AJAX umożliwia wysyłanie zapytań do serwera, a jednocześnie dalsze, nieprzerwane działanie aplikacji. Dzięki temu możemy np. dynamicznie podmieniać treści na stronie, bez konieczności przeładowywania jej w całości.</p>
<p>Czyli np. uruchamiamy request do serwera, który ma pobrać produkty. Nie czekamy jednak aż ten się zakończy, tylko pozwalamy JS-owi pójść dalej i np. renderujemy koszyk. Kiedy request po jakimś czasie zakończy się sukcesem i serwer zwróci nam jakąś odpowiedź, to JS wróci do tematu i zajmie się naszymi produktami. Zobacz jednak, że nie czekał bezczynnie na zakończenie requestu, połączenia z serwerem, tylko w tym czasie robił "coś innego".</p>
<p>Jest to o tyle ważne, że serwery nie zawsze będą w stanie odpowiedzieć nam szybko. Weź pod uwagę, że często obsługują miliony zapytań od różnych klientów, a to może wpływać negatywnie na ich wydajność. Np. łatwo możemy wyobrazić sobie, że serwery Facebooka obsługują miliony zapytań na minutę. Im więcej ich jest, im więcej użytkowników na raz korzysta ze strony, tym gorzej serwer będzie sobie radził i wolniej zwracał odpowiedź. Na pewno zdarzyła Ci się taka sytuacja, że w momencie promocji w jakimś sklepie internetowym i dużego obłożenia przez klientów, strona potrafiła działać wolniej. Właśnie dlatego, że serwer to zwykły komputer. Im słabszy jego procesor, im mniejsze ma "moce przerobowe", tym gorzej będzie sobie radził z natłokiem zapytań. Tym samym zmuszanie JS-a do "czekania", w momencie, który mógłby wykorzystać do robienia czegoś innego, mija się z celem.</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Metafora – AJAX</h4>
<p>Jeśli jeszcze nie do końca to rozumiesz, to wspomóż się poniższą metaforą.</p>
<p>Wyobraź sobie kiosk na przystanku autobusowym.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/storefront.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/storefront-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/storefront.png 2x"  class="img-inline img-left">
<p>Podróżni często kupują w tym kiosku bilety, bo na przystanku nie ma automatu do biletów.</p>
<p>Dawniej sprzedawca w kiosku codziennie wychodził na godzinę zjeść obiad w pobliskiej restauracji. W tym czasie podróżni często jeździli na gapę, bo w pobliżu nie było innego kiosku.</p>
<p>Teraz jednak jest inaczej – sprzedawca z kiosku zamawia jedzenie z dostawą, dzięki czemu nie musi przerywać pracy. Robi sobie tylko 5 minut przerwy, kiedy dostawca przywiezie mu jedzenie.</p>
<p>Podobną zmianę wprowadza nam AJAX – kod JS może nadal działać, użytkownik może dalej korzystać ze strony, podczas gdy strona wysyła jakieś "zamówienie" do serwera, którym zajmie się dopiero w momencie otrzymania odpowiedzi.</p>
</div>
<p>Warto podkreślić, że AJAX nie jest osobną technologią lub frameworkiem. Jest to pewna filozofia myślenia o aplikacjach internetowych, koncentrująca się na dynamicznej interakcji z użytkownikiem. Żądania (requesty) AJAX-owe mogą być pisane m.in. w znanym Ci już języku JavaScript.</p>
<h3>Po co kontaktować się z serwerem?</h3>
<p>Rozumiesz już zapewne, o co chodzi w komunikacji asynchronicznej, ale wciąż możesz zastanawiać się, czy jest konieczna? Nie jest, ale przeważnie będzie naprawdę dobrym wyborem. Zalet jest kilka i powinny Cię przekonać. Jedną z nich jest estetyka – np. przy doładowywaniu większej ilości treści na stronie, strona może pokazać animowane przejście do nowej zawartości, a kiedy wysyłamy formularz, strona może wyświetlić komunikat o błędzie bez usuwania treści wpisanych do formularza.</p>
<p>Co więcej, użytkownik może korzystać ze strony, nie czekając na odpowiedź z serwera. Dzięki temu np. na stronach Facebooka czy Gmaila nie musisz odświeżać strony, aby zobaczyć powiadomienie o nowej wiadomości. A kiedy wysyłasz wiadomość, możesz natychmiast wysłać kolejną, nie czekając na potwierdzenie wysłania poprzedniej. Redukuje to konieczność żmudnego klikania i oczekiwania, aż strona przetworzy żądanie i wyświetli nowe treści.</p>
<p>Trzeba też zwrócić uwagę na kwestię optymalizacji działania strony – Gmail wczytywałby się bardzo długo, gdyby miał od razu w treści strony mieć zawarte wszystkie Twoje maile. Dużo sprawniej działa, kiedy może wczytać dany mail dopiero w momencie, kiedy chcesz go przeczytać. Dzięki temu sama strona aplikacji może być lekka i szybko się wczytywać, a treści mogą być ładowane i pokazywane dopiero, kiedy są potrzebne.</p>
<p>Czyli, podsumowując: asynchroniczna komunikacja z serwerem, poprzez ograniczenie liczby przeładowań i skrócenie czasu oczekiwania na wczytanie nowych treści, znakomicie wpływa na użyteczność (<em>usability</em>) naszych stron oraz odciąża serwer.</p>
<h3>Co możemy wysyłać i odbierać?</h3>
<p>Technicznie rzecz biorąc – wszystko. Możesz np. za pomocą AJAX-a pobrać kod HTML innej podstrony, aby jego fragment wstawić na obecnie wyświetlanej stronie.</p>
<p>W większości wypadków jednak, chodzi o pobranie z serwera jakich danych. Dlatego też komunikacja odbywa się w jednym z dwóch formatów: XML lub JSON. Pierwszy z nich jest podobny do kodu HTML, ale jest on coraz rzadziej stosowany, a drugi mocno przypomina obiekty JS-owe. Dlatego też w naszym wypadku powinien być to znacznie wygodniejszy wybór. Skupimy się więc na tym formacie.</p>
<h3>JSON</h3>
<p>Ten format bardzo przypomina zwykłe obiekty i tablice w kodzie JS. Jedyną poważną różnicą jest to, że nazwy właściwości muszą być opakowane cudzysłowem, a same dane powinny być proste. Mówiąc proste, mamy na myśli, że mogą być to liczby, teksty, obiekty, tablice, ale np. funkcje już nie.</p>
<p>JSON to tak naprawdę nic innego, jak po prostu ciąg znaków (string, tekst), który jest sformatowany bardzo podobnie do tablic i obiektów w JS. Przykładowy obiekt w JSON wygląda tak:</p>
<pre><code class="language-js">
{
  &quot;books&quot; : [
    {
      &quot;author&quot;: &quot;Moore, Kate&quot;,
      &quot;title&quot;: &quot;The Radium Girls&quot;,
      &quot;genre&quot;: &quot;History&quot;
    },
    {
      &quot;author&quot;: &quot;Madeline, Miller&quot;,
      &quot;title&quot;: &quot;Circe&quot;,
      &quot;genre&quot;: &quot;Fantasy&quot;
    },
    {
      &quot;author&quot;: &quot;King, Stephen&quot;,
      &quot;title&quot;: &quot;Elevation&quot;,
      &quot;genre&quot;: &quot;Horror&quot;
    }
  ]
}

</code></pre>
<p>Skoro wiemy, że będziemy komunikować się z serwerem za pomocą tego formatu, to musimy od razu powiedzieć, jak takie dane ew. konwertować. W końcu np. jeśli otrzymamy od serwera listę produktów w formacie JSON, to chcielibyśmy skonwertować je do zwykłej tablicy.</p>
<p>Do konwertowania JSON-a na tablice/obiekty i odwrotnie używamy biblioteki <code>JSON</code>. Zobacz to na przykładzie <a href="https://poradnik-js.kodilla.com/ajax-json" target="_blank">w naszym poradniku</a>.</p>
<h3>Czym jest API?</h3>
<p>Często mówiąc o serwerze, który pełni rolę pośrednika do bazy danych, mówimy serwer API. Dlaczego API? Skąd ta nazwa?</p>
<p>API wcale nie tyczy się tylko serwera. Mówiąc API mamy na myśli po prostu zbiór metod danego programu/aplikacji, które można wywoływać spoza niego. Brzmi to tajemniczo, ale łatwo możemy to wytłumaczyć.</p>
<p>Wyobraź sobie np. system obsługi kamery w przeglądarce. Jak wiesz, takowy istnieje i jest wykorzystywany przez wiele serwisów. Czy tak naprawdę, gdybyśmy chcieli w JS korzystać z kamery, to czy interesuje nas, jak cały system jest zbudowany? Nie. To, czego oczekujemy, to po prostu zestaw jakichś prostych metod, za pomocą których bylibyśmy w stanie uruchamiać kamerę, czy renderować jej obraz do jakiegoś diva. Przeglądarka faktycznie zbiór takich metod udostępnia. W takiej sytuacji moglibyśmy nazwać je np. Camera API. Podobnie zestaw metod do obsługi mikrofonu również moglibyśmy nazwać API.</p>
<p>Wynika z tego, że mówiąc API mamy na myśli po prostu jakiegoś pośrednika, który za pomocą prostych komend/metod jest w stanie uruchamiać znacznie większe i bardziej interesujące operacje.</p>
<p>W takim wypadku serwer, który jest pośrednikiem do bazy danych, a więc udostępnia endpointy (adresy), które pozwalają na połączenie z nią, jak najbardziej pasuje do tej definicji. Stąd też tak często używana nazwa serwer API.</p>
<p>Idąc dalej tym tropem, warto powiedzieć, że bardzo często nie interesuje nas to, jak serwer jest zbudowany pod maską. Obchodzi nas tylko to jakie endpointy (adresy) udostępnia i co pod nimi wykonuje. Jeśli to wiemy, to możemy bardzo łatwo ustalić, jaki request należy wykonać, aby spodziewać się pożądanych efektów. Najczęściej więc autorzy serwera udostępniają dokumentację, która opisuje wszystkie dostępne endpointy.</p>
<p>Możesz zastanawiać się, czy jeden endpoint może służyć tylko do jednego celu. To świetne pytanie, na które zaraz odpowiemy!</p>
<h3>Metody zapytań</h3>
<p>Przy komunikacji AJAX-owej mamy do wyboru tzw. metody zapytań. Dzięki nim ten sam endpoint może wykonywać różne akcje.</p>
<p>Podstawową metodą jest <code>GET</code> – tę metodę stosujesz bardzo często, nawet o tym nie wiedząc! Kiedy wpiszesz adres strony w przeglądarce i wciśniesz <em>enter</em>, do serwera zostanie wysłane właśnie zapytanie <code>GET</code>. Drugą, bardzo popularną metodą zapytania jest <code>POST</code>, służąca do wysyłania danych do serwera.</p>
<p>W praktyce stosuje się je w taki sposób, że np. zapytanie <code>GET</code> do endpointa <code>/orders</code> powinno zwrócić listę wszystkich zamówień. Jeśli zaś zmienimy metodę na <code>POST</code>, serwer będzie oczekiwał, że prześlemy mu dane nowego zamówienia.</p>
<p>Oczywiście na tym etapie kursu nie interesuje nas to, jak serwer jest zbudowany pod maską. Ważne jest tylko to, że łącząc się z nim pod wybranym adresem i przy użyciu konkretnej metody, wykona dla nas jakieś operacje, np. zwróci dane o produktach albo zapisze do swojej tablicy z danymi nowy.</p>
<h3>Podsumowanie</h3>
<p>Za chwilę wprowadzimy AJAX w naszym projekcie. Na pewno w praktyce znacznie łatwiej będzie Ci zauważyć, jak bardzo pozytywnie wpłynie na działanie naszej strony. Będziemy kontaktować się z naszym własnym, testowym API. Stworzymy w nim dwa endpointy – <code>/products</code> z którego za pomocą <code>GET</code> odczytamy listę produktów, a następnie <code>/orders</code>, do którego za pomocą <code>POST</code> będziemy wysyłać składane zamówienia.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1979" class="card submodule completed" data-bootcamp-user-submodule-id="607293" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.8. <span>Pobieranie listy produkt&oacute;w</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Aby wypróbować AJAX-a w praktyce, potrzebujemy <strong>serwera</strong>, z którym będzie komunikować się nasza strona. W przypadku komercyjnego projektu serwer byłby specjalną dedykowaną aplikacja stworzoną przez zespół Backend Developerów, ale do naszych potrzeb wystarczy znacznie prostsze rozwiązanie. Potrzebujemy serwera, który udostępni nam zbiór endpointów, umożliwiających komunikację z bazą danych.</p>
<p>Wspomożemy się specjalną paczką – <code>json-server</code>. Jej działanie jest stosunkowo proste. Musimy poinformować ją z jakiego pliku <code>.json</code> z danymi ma skorzystać, a ona sama przygotuje nam serwer z odpowiednimi endpointami, które pozwolą nam na skuteczną komunikację z tymi danymi.</p>
<p>Przykładowo, jeśli przekażemy jej jako dane taki plik:</p>
<pre><code class="language-js">{ 
  names: ['John', 'Amanda', 'Thomas']
}
</code></pre>
<p>...to paczka ta stworzy nam serwer z m.in. następującymi endpointami:</p>
<ul>
<li><strong>GET</strong> <code>/names</code> – zwracałoby tablicę <code>['John', 'Amanda', 'Thomas']</code></li>
<li><strong>POST</strong> <code>/names</code> – pozwalałoby na dodawanie do tablicy nowego elementu</li>
</ul>
<p>Próba połączenia z naszej strony z endpointem <code>/names</code> przy użyciu metody <strong>GET</strong> zakończyłaby się otrzymaniem w odpowiedzi tablicy <code>['John', 'Amanda', 'Thomas']</code>, którą moglibyśmy wykorzystać do wyrenderowania listy imion na stronie. Łącząc się z tym samym adresem, ale przy użyciu metody <strong>POST</strong>, bylibyśmy za to w stanie wprowadzić do bazy danych (do tablicy z imionami) nowe imię!</p>
<p>Oczywiście tych endpointów byłoby nawet więcej. Pojawiłby się również endpoint do edycji czy do usuwania imion. Rozumiesz, już jednak pewnie jaki jest pomysł na działanie tej paczki. Przekazujemy jej plik z danymi, a ona tworzy dla nas serwer, który pozwala na komunikację z tymi danymi przy użyciu endpointów.</p>
<p>My oczywiście przekażemy znacznie ciekawszy plik z danymi. Będą tam produkty, zamówienia, rezerwacje itd. <code>json-server</code> stworzy więc dla nas znacznie więcej endpointów, ale będą one działały analogicznie.</p>
<p>Zauważ, że to działanie, o którym pisaliśmy już wcześniej. Nasz serwer ma pełnić rolę pośrednika. Połączenie z odpowiednim endpointem (adresem), przy użyciu konkretnej metody, ma powodować określone działanie, np. zwracanie danych czy ich zmianę. Nie interesuje nas, jak dokładnie serwer wykonuje te operacje. My będziemy tylko wykonywać request (żądanie) i oczekiwać na response (odpowiedź).</p>
<p>Nie bój się, jeśli całe zagadnienie wciąż nie jest dla Ciebie do końca jasne. Zaraz zobaczysz, jak to działa w praktyce.</p>
<h3>Co przed nami</h3>
<p>Zanim zabierzemy się do pracy, zastanówmy się, co mamy do zrobienia:</p>
<ol>
<li>Pobranie paczki <code>json-server</code>.</li>
<li>Przygotowanie nowego tasku <code>server</code> w task-runnerze, który przy użyciu <code>json-server</code> i podanych danych będzie dbał o uruchomienie serwera z odpowiednimi endpointami.</li>
<li>Pozbycie się w naszym kliencie (stronie internetowej) bezpośredniego dostępu do danych <code>(dataSource)</code>.</li>
<li>Zadbanie o to, aby klient, zaraz po uruchomieniu strony, łączył się z serwerem i za jego pomocą pobierał dane o produktach.</li>
</ol>
<p>Zauważ, że końcowy efekt działania naszej strony będzie taki sam, tylko że teraz to serwer będzie dbał o dostarczanie odpowiednich danych.</p>
<p>Przechowywanie danych poza aplikacją ma wiele zalet. Przede wszystkim możemy skonfigurować serwer w taki sposób, aby np. nie zawsze zwracał wszystkie dane. Może np. powinien pozwalać na pobieranie listy użytkowników, tylko jeśli jesteśmy zalogowani? Albo zwracał tylko część potrzebnych danych, takich które nie są "wrażliwe" (czyli nie hasła, nie PESEL itd.). Teraz z poziomu klienta mamy dostęp do całego pliku. Każdy użytkownik mógł zobaczyć wszystkie dane. Wystarczy wejść do zakładki Sources w DevToolsach... Dedykowany serwer to więc znacznie <strong>większe bezpieczeństwo</strong>, jak i możliwość <strong>personalizacji</strong> zwracanych danych.</p>
<p>Druga sprawa to na pewno <strong>centralizacja danych</strong>. Zauważ, że jeśli na ten moment otworzylibyśmy Twoją stronę np. na trzech komputerach, to każdy klient działałby tak naprawdę w izolacji, nie wiedząc, co robią pozostałe. Zauważ bowiem, że każdy z nich działałby na własnej kopii danych. To powoduje masę ograniczeń.</p>
<p>Skąd np. mielibyśmy wiedzieć, czy wciąż można zarezerwować stolik nr 1 o godzinie 8? Może i na starcie był wolny, ale przecież w międzyczasie inna osoba mogła go zarezerwować... A nawet gdybyśmy to zignorowali, to jak moglibyśmy poinformować pracowników pizzerii o tej rezerwacji? Zmieniając zawartość pliku <code>data.js</code>, a dokładnie jego tablicę z zamówieniami (<code>orders</code>)? Raczej nie. Przecież pizzeria nie wie, co dzieje się w pliku <code>data.js</code> na komputerze naszym czy też innych klientów. Rozumiesz już pewnie problem. Musimy mieć jakąś jedną centralę, z której korzystają wszyscy użytkownicy. Centralę z danymi.</p>
<p>I taką rolę będzie właśnie pełnił nasz serwer API. Będzie serwerem z danymi, który udostępnia możliwość ich modyfikacji przy użyciu endpointów. Dzięki temu każdy klient na starcie aplikacji będzie w stanie pobrać aktualne dane startowe, ale też później wedle woli je odświeżać, czy nawet informować o dodaniu czegoś nowego, np. nowego zamówienia. Dzięki temu inni klienci przy próbie rezerwacji tego samego terminu mogliby już być informowani przez serwer, że ten jest akurat zajęty.</p>
<p>Podsumowując, <strong>mamy wielu klientów, ale jedną centralę, która przechowuje wspólne dane, wszystko kontroluje i pozwala dojść do nich przy użyciu endpointów.</strong></p>
<p>Tym samym dochodzimy też to trzeciej zalety – <strong>uniwersalność</strong>. Bardzo często jest tak, że jedna baza danych jest wykorzystywana przez kilka stron/aplikacji. Np. możemy wyobrazić sobie, że nasz serwer jest wykorzystywany nie tylko przez stronę z produktami, ale też zupełnie inną aplikację – panel administracyjny, z którego korzystają pracownicy pizzerii.</p>
<p>Zapewne znasz koncept "kiosków" w sieciach KFC czy McDonalds. W nich też jest uruchomiona jakaś aplikacja, która musi mieć dostęp do tych samych danych, co np. strona internetowa sieci. Zapewne więc aplikacja w "kiosku", aplikacja w panelach pracowników czy sama strona internetowa dla klientów, korzystają z jednego i tego samego serwera API.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Żyjemy w symulacji ;)</h4>
<p>Musimy jeszcze wyjaśnić jedną rzecz. Mówimy o centralnym serwerze, o tym, że wiele komputerów będzie mogło się z nim łączyć. Czy nasz serwer też taki będzie? No cóż... Nie do końca.</p>
<p>My będziemy uruchamiać na razie nasz serwer lokalnie, tylko na naszym komputerze. Oznacza to, że będzie się mogło z nim łączyć wielu klientów, ale tylko z poziomu naszego komputera, czyli np. będziemy mogli otworzyć pięć razy stronę pizzerii i każda zakładka będzie nowym klientem korzystającym z jednego i tego samego serwera. Nie będzie jednak możliwości połączenia z zewnątrz, z  całkiem innych komputerów, a w "normalnych" produkcyjnych serwerach jest to możliwe. Czy to jednak coś nam zmieni?</p>
<p>Tak naprawdę nie. Połączenie z serwerem lokalnym czy zdalnym (obecnym na innym komputerze) jest takie samo. Tak samo będziemy wysyłać do niego request i oczekiwać na odpowiedź. Na dobrą sprawę nasz serwer lokalny będziemy mogli bardzo łatwo zamienić na serwer zdalny i korzystać z niego tak samo, jak wcześniej. To naprawdę nie jest żaden problem. To, czego będziemy się więc teraz uczyć, możesz więc spokojnie traktować jako ogólną wiedzę na temat połączenia z serwerem, nie tylko lokalnym.</p>
</div>
<h3>Instalacja <code>json-server</code></h3>
<p>Zaczniemy od zainstalowania paczki <code>json-server</code> za pomocą komendy:</p>
<pre><code class="language-plaintext">npm install --save json-server
</code></pre>
<h3>Plik z danymi</h3>
<p>Następnie musimy przygotować dane, z których będzie korzystać nasz serwer. Niestety nie możemy wykorzystać wprost pliku <code>data.js</code>, gdyż <code>json-server</code> oczekuje na format danych JSON, a tam mamy obiekty JS-owe.</p>
<p>W katalogu <code>src</code> stwórz więc katalog <code>db</code>, a w nim nowy plik <code>app.json</code>. To właśnie on będzie zawierał dane, które nasz serwer będzie wykorzystywać jako startową zawartość bazy danych. Oczywiście ten folder mógłby nazywać się również inaczej, ale <code>db</code> dobrze oddaje jego zawartość.</p>
<p>Chcielibyśmy, aby <code>app.json</code> jako dane startowe, przyjął po prostu zawartość pliku <code>data.js</code>, ale... wiesz już, że format JSON różni się trochę od zwykłej struktury obiektu, a w pliku <code>data.js</code> jest właśnie zwykły obiekt JS-owy...</p>
<p>Musimy więc skonwertować nasze dane z pliku <code>data.js</code> do formatu JSON, dopiero wtedy będziemy mogli wkleić je do <code>app.json</code>. Można to zrobić chociażby przy użyciu jednego z dostępnych w internecie <a href="https://www.convertonline.io/convert/js-to-json" target="_blank">konwerterów</a>.</p>
<p>My przygotowaliśmy już jednak taki plik za Ciebie (<a href="https://uploads.kodilla.com/bootcamp/wdp/09/app.json" target="_blank">LINK</a>).</p>
<p>Jego zawartość wklej do swojego pliku <code>app.json</code>. Możesz również pozbyć się pliku <code>data.js</code>. Nie będzie nam już potrzebny.</p>
<h3>Task runner</h3>
<p>Czas przygotować task, który będzie uruchamiał przy pomocy paczki <code>json-server</code> nasz serwer.</p>
<p>Wejdź do pliku <code>package.json</code>, w sekcji <code>scripts</code>, znajdź te linie:</p>
<pre><code class="language-plaintext">        &quot;watch&quot;: &quot;npm-run-all build build-dev -p watch:*&quot;,
        &quot;watch:browsersync&quot;: &quot;browser-sync start --server dist --files \&quot;dist/**/*\&quot;&quot;,
</code></pre>
<p>Zamień je na następujące:</p>
<pre><code class="language-plaintext">        &quot;server&quot;: &quot;json-server --port 3131 --no-cors --delay 250 --watch dist/db/app.json&quot;,
        &quot;watch&quot;: &quot;npm-run-all build build-dev -p watch:* server&quot;,
        &quot;watch:browsersync&quot;: &quot;browser-sync start --server dist --files \&quot;dist/**/*\&quot; --ignore \&quot;dist/db/**/*\&quot;&quot;,
</code></pre>
<p>Dodaliśmy w ten sposób task <code>server</code>, który będzie uruchamiał nasz <code>json-server</code> na porcie <code>3131</code>. Połączenie z lokalnym serwerem jest znacznie szybsze, niż z serwerem funkcjonującym w internecie (zdalnym), więc dodaliśmy opóźnienie <code>250ms</code> (1/4 sekundy), tak aby efekt był bardziej realistyczny.</p>
<p>Dodatkowo w tasku <code>watch</code> dodaliśmy wywołanie taska <code>server</code>, a w tasku <code>watch:browsersync</code> poprosiliśmy nasz serwer z podglądem strony, aby nie odświeżał podglądu, kiedy zmienia się plik z danymi.</p>
<p>Teraz gdy tylko uruchomimy task <code>watch</code>, zawsze będzie uruchamiał się również nasz serwer API.</p>
<p>Zauważ, że tym samym będziemy posiadać już dwa serwery. Jeden (<code>localhost:3000</code>) serwuje naszą stronę, drugi (<code>localhost:3131</code>) udostępnia endpointy do komunikacji z bazą danych. Oczywiście można by połączyć je w jeden... ale to "zabawa" na później.</p>
<h3>Test API</h3>
<p>Teraz zrestartuj swój task <code>watch</code>, czyli wyłącz go i znów uruchom <code>npm run watch</code>. Ponownie otworzy się strona pizzerii, którą tworzymy. Dba o to serwer <code>localhost:3000</code>.</p>
<p>Wiemy też, że <code>watch</code> na pewno uruchomiło również drugi serwer. Otwórz więc nową zakładkę i przejdź pod adres <a href="http://localhost:3131/" target="_blank">http://localhost:3131/</a>. To adres naszego serwera API.</p>
<p>Mówiliśmy, że serwer API udostępnia przede wszystkim endpointy do obsługi danych, ale akurat nasz oferuje nam jeszcze jeden endpoint <code>/</code>, który można potraktować jako dokumentację.</p>
<p>Właśnie pod tym adresem zobaczysz stronę wygenerowaną przez serwer <code>json-server</code>, która powie nam, jakie endpointy dokładnie mamy do dyspozycji! Pamiętasz jak mówiliśmy, że autorzy serwerów zawsze udostępniają nam dokumentację? Tutaj jest ona dostępna właśnie pod adresem <code>/</code> serwera, jako mała strona HTML.</p>
<p>Wejdźmy teraz pod endpoint, z którego będziemy korzystać za chwilę również w aplikacji <a href="http://localhost:3131/products" target="_blank">http://localhost:3131/products</a>. Pamiętasz jak mówiliśmy, że endpoint <strong>GET</strong> <code>/products</code> będzie zwracał nam wszystkie produkty? Wygląda na to, że tak właśnie się dzieje! Serwer naprawdę po wejściu w taki endpoint zwrócił nam dane – nasze produkty.</p>
<p>Możesz zastanawiać się jakiej metody użyła przeglądarka, wchodząc na ten endpoint (adres). Dlaczego uznała, że użyliśmy metody <strong>GET</strong>? Z prostego powodu. Gdy wchodzimy na jakiś adres w przeglądarce, to zawsze domyślnie wykorzystywana jest właśnie ta metoda.</p>
<p>Niedługo będziemy wykonywać requesty za pomocą AJAX-u, w naszej aplikacji. Wtedy sami będziemy decydować o użytej metodzie.</p>
<p>Nasza strona będzie korzystać na razie tylko z tego jednego endpointu (adresu), ale możesz też sprawdzić, jak będzie wyglądało pobranie pojedynczego produktu, dodając do adresu slash <code>/</code> oraz <code>id</code> jednego z produktów – np. <a href="http://localhost:3131/products/cake" target="_blank">http://localhost:3131/products/cake</a>.</p>
<p>Ważna uwaga – plik z danymi stworzyliśmy w katalogu <code>src/db</code>, ale serwer korzysta z pliku <code>dist/db/app.json</code>. Jeśli zechcesz ręcznie zmienić zawartość pliku z danymi, zmieniaj wyłącznie plik <code>src/db/app.json</code>. Zostanie on automatycznie skopiowany do <code>dist/db</code>, a API natychmiast zacznie korzystać z nowej wersji pliku. Wybraliśmy takie rozwiązanie, ponieważ już niedługo będziemy zapisywać zamówienia do API. Jako że jest to nasze testowe API, nie chcemy przechowywać w repozytorium testowych zamówień. Dlatego złożone zamówienia będą kasowane przy każdym uruchomieniu tasków <code>watch</code> i <code>build</code>.</p>
<p>Serwer API już działa, widzimy nawet, że udostępnia kilka endpintów – teraz czas przystosować nasz projekt do korzystania z niego.</p>
<h3>Pobieranie danych z API</h3>
<p>Otwórz plik <code>src/js/script.js</code> i znajdź w swoim kodzie obiekt <code>settings</code>. Dodaj do niego:</p>
<pre><code class="language-js">    db: {
      url: '//localhost:3131',
      products: 'products',
      orders: 'orders',
    },
</code></pre>
<p>Jest to konfiguracja parametrów, które będą nam potrzebne do łączenia się z API. Oczywiście można by zawsze wpisywać odpowiednie linki w kodzie ręcznie... ale miało by to tyle samo sensu, co wpisywanie na sztywno kolorów w Sassie. Niby można się męczyć, ale po co? Dzięki temu, że mamy takie informacje zapisane w jednym miejscu, to w przypadku zmiany nazwy kolekcji nie jesteśmy zmuszani do zmian we wszystkich plikach, w któych się z nią łączyliśmy. Wystarczy zmienić tylko wartości w obiekcie <code>settings</code>, a wtedy wszystkie pliki, które z tego obiektu korzystały, z automatu zaczną działać inaczej.</p>
<p>Możesz się również zastanawiać, dlaczego przygotowaliśmy link do kolekcji  <code>orders</code>. Przecież na razie nasz serwer obsługuje tylko produkty. No ale właśnie – na razie! A my myślimy już kilka kroków w przód :) W naszej aplikacji mamy już koszyk i chcielibyśmy, aby dało się z jego poziomu zamawiać posiłki. Informacje o tych posiłkach gdzieś będą musiały być przechowywane. Na pewno więc wkrótce dodamy do naszego pliku <code>app.json</code> nową kolekcję danych <code>orders</code>. A skoro tak, to przyda się również link w <code>settings</code>.</p>
<p>W takim razie idźmy dalej! W kolejnym kroku znajdź metodę <code>app.initData</code>, która znajduje się pod koniec pliku.</p>
<p>Zaczniemy od zastąpienia <code>dataSource</code> pustym obiektem. Nie chcemy już bowiem korzystać z tego obiektu. Zatem dotychczasowa linia kodu będzie teraz wyglądać tak:</p>
<pre><code class="language-js">      thisApp.data = {};
</code></pre>
<p>Następnie potrzebujemy zapisać w stałej <code>url</code> adres endpointu, który nas interesuje, czyli:</p>
<pre><code class="language-js">      const url = settings.db.url + '/' + settings.db.products;
</code></pre>
<p>Jak możesz się domyślić, po połączeniu stringów wyjdzie nam adres <code>http://localhost:3131/products</code>, pod którym jak już wiesz, serwer udostępnia listę produktów.</p>
<p>No dobrze, czas w końcu rozkazać JS-owi, aby połączył się z tym endpointem. Ciągle o tym mówimy, czas naprawdę to zrobić.</p>
<p>Użyjemy do tego celu wbudowanej funkcji <code>fetch</code>. Możesz zapoznać się z jej składnią <a href="https://poradnik-js.kodilla.com/ajax-fetch" target="_blank">w naszym poradniku</a>. Pomoże Ci to zrozumieć, czym są metody <code>.then</code> i dlaczego "doklejamy" je do <code>fetch(url)</code>. Najprościej możemy jednak rozumieć funkcję schowaną w pierwszym <code>.then</code> jako funkcję, która uruchomi się <strong>wtedy, gdy request się zakończy, a serwer zwróci odpowiedź</strong>.</p>
<p>Nie uzupełniaj jeszcze tego kodu w miejscach, w których znajdują się komentarze – skup się na razie na jego zrozumieniu.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-14.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-14.png" alt="image" style="width: auto;"></a>
<p>Przeanalizujmy, co on właściwie robi. Najpierw za pomocą funkcji <code>fetch</code> wysyłamy zapytanie (request) pod podany adres endpointu. Następnie otrzyma odpowiedź, która jak już wiesz, jest w formacie JSON. Widzieliśmy to wcześniej w przeglądarce. Dalej konwertujemy więc tę odpowiedź na obiekt JS-owy. Wreszcie, po otrzymaniu skonwertowanej odpowiedzi <code>parsedResponse</code>, wyświetlamy ją w konsoli.</p>
<p>To dokładnie to, o czym wcześniej mówiliśmy. Łączymy się z serwerem (request), czekamy na odpowiedź, i jak ją otrzymamy, to coś z nią robimy. W naszej sytuacji konwertujemy ją z JSON-a do obiektu JS i wyświetlamy.</p>
<p>Swoją drogą zauważ, że nie podaliśmy nigdzie z jakiej metody chcemy skorzystać. Nie musieliśmy. <code>fetch</code> domyślnie korzysta z metody <code>GET</code>, a właśnie z takiej musieliśmy skorzystać, jeśli chcieliśmy pobrać dane. Zauważ, że kiedy testowaliśmy, czy ten endpoint działa, wchodząc pod adres <code>url</code> w przeglądarce, też łączyliśmy się przy użyciu metody <code>GET</code> i otrzymaliśmy dobre dane. Teraz zrobiliśmy dokładnie to samo. Połączyliśmy się z tym samym serwerem, tym samym endpointem, przy użyciu tej samej metody. Tyle że tym razem zrobiliśmy to asynchronicznie, z poziomu już załadowanej strony i to bez potrzeby przeładowywania czegokolwiek. Imponujące, prawda?</p>
<p>Składnia <code>fetch</code> z <code>then</code> może na razie wydawać się trochę specyficzna, ale możesz zrozumieć całość jako prosty rozkaz:</p>
<ol>
<li>Połącz się z adresem <code>url</code> przy użyciu metody <code>fetch</code>.</li>
<li>Jeśli połączenie się zakończy, to wtedy (pierwsze <code>.then</code>) skonwertuj dane do obiektu JS-owego.</li>
<li>Kiedy i ta operacja się zakończy, to wtedy (drugie <code>.then</code>) pokaż w konsoli te skonwertowane dane.</li>
</ol>
<p>Zauważ, że obie funkcje w <code>then</code> uruchomią się dopiero w momencie zakończenia jakiejś operacji. Pierwsze <code>then</code> czeka na zakończenie reqestu, a drugie konwersji danych. Wcześniej JS nawet ich nie "dotknie".</p>
<p>Uwaga – po tych zmianach przez chwilę strona nie będzie wyświetlać produktów. Nie pokaże się też żadna wartość w konsoli przy komunikacie "thisApp.data". Za chwilę zajmiemy się obiema kwestiami.</p>
<p>Sprawdź teraz, co pokazuje konsola na stronie pizzerii – przy komentarzu "parsedResponse" powinna pokazywać tablicę z produktami. Jeśli masz dobrą pamięć, być może pamiętasz, że w <code>data.js</code> produkty nie miały właściwości <code>id</code>, a zamiast tablicy <code>products</code> mieliśmy obiekt <code>products</code>. W związku z tym każdy produkt miał swój klucz – który teraz mamy zapisany jako właściwość <code>id</code>. Musieliśmy jednak dostosować strukturę danych do możliwości <code>json-server</code>, dlatego będziemy musieli wprowadzić drobne zmiany w kodzie.</p>
<p>Jedyne miejsce, w którym wykorzystywaliśmy klucz produktu, znajduje się w metodzie <code>app.initMenu</code>.</p>
<pre><code class="language-js">        new Product(productData, thisApp.data.products[productData]);
</code></pre>
<p>Zamiast klucza, wykorzystamy teraz właściwość <code>id</code>:</p>
<pre><code class="language-js">        new Product(thisApp.data.products[productData].id, thisApp.data.products[productData]);
</code></pre>
<p>Teraz jesteśmy gotowi, aby dokończyć implementację AJAX-a. W metodzie <code>app.init</code> znajdź wywołanie metody <code>initMenu</code> i skasuj je. Przejdź do funkcji, która otrzymuje <code>parsedResponse</code> i uzupełnij ją zgodnie z wpisanymi komentarzami.</p>
<p>Po tej operacji produkty powinny z powrotem wyświetlać się na stronie, a także powinny działać zmiany opcji i liczby sztuk. Tak jak wcześniej, powinno działać też dodawanie ich do koszyka, zmiana liczby sztuk, oraz usuwanie z koszyka.</p>
<p>Zwróć uwagę na kolejność wyświetlania komunikatów w konsoli. Komunikat "thisApp.data" wyświetla się przed komunikatem "parsedResponse", mimo że w kodzie jest niżej. Co więcej, nie wyświetla zawartości <code>thisApp.data</code>.</p>
<p>Tak właśnie działa asynchroniczność, o której wspomnieliśmy. Kod w funkcji otrzymującej argument <code>parsedResponse</code> wykonuje się dopiero wtedy, kiedy otrzyma odpowiedź z serwera. Z tego też powodu nie wyświetla się zawartość <code>thisApp.data</code> – w momencie wykonania <code>console.log</code> ten obiekt jest jeszcze pusty. Właśnie dlatego musieliśmy do tej funkcji przenieść uruchomienie metody <code>initMenu</code> – inaczej uruchamiałaby się, zanim nasz skrypt otrzymałby z serwera listę produktów.</p>
<h3>Podsumowanie</h3>
<p>I jak Ci się podoba ten AJAX? Na razie niewiele nam zmienił, ponieważ wczytujemy dane tuż po odświeżeniu strony. Było to jednak ważne ćwiczenie, które pozwoli nam za chwilę na wysyłanie zamówień do API!</p>
<p>Teraz kiedy nasza aplikacja już korzysta z API, możesz w pliku <code>src/index.html</code> usunąć tag <code>&lt;script&gt;</code>, który odwołuje się do pliku <code>js/data.js</code>. Ten plik nie będzie już nam potrzebny. Zresztą, już go nawet usunęliśmy.</p>
<h3>Zadanie: zrozumienie AJAX-a</h3>
<p>W tym module Twoim zadaniem jest zrozumienie AJAX-a. Aby to osiągnąć, w pliku <code>package.json</code> znajdź task <code>server</code> i zmień w nim fragment <code>--delay 250</code> na <code>--delay 3000</code>. Teraz odpowiedzi z API będą przychodziły dopiero po 3 sekundach.</p>
<p>Wyłącz i ponownie włącz task <code>watch</code>, a następnie otwórz konsolę na stronie pizzerii i odśwież stronę. Zwróć uwagę, że menu nie pokazuje się przez ok. 3 sekundy od wyświetlenia strony. Również komunikat w konsoli zaczynający się od <code>parsedResponse</code> wyświetla się dopiero po 3 sekundach.</p>
<p>Przełącz teraz narzędzia developerskie z <em>Console</em> na <em>Network</em>. Po kolejnym odświeżeniu strony zobaczysz tutaj sporo plików – a konkretniej, wszystkie pliki pobierane przez stronę. Znajdziesz tu zarówno sam plik <code>index.html</code> (pod pierwszą pozycją "localhost"), jak również wszystkie pliki <code>.css</code> i <code>.js</code>, a także czcionki i obrazki.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Zwróć uwagę na czas odpowiedzi z serwera zaznaczony na grafie po prawej stronie. Zobaczysz na nim, że większość zapytań trwała tylko moment, poza zapytaniem do API, które specjalnie opóźniliśmy.</p>
<p>Teraz skupimy się wyłącznie na komunikacji z naszym API – kliknij ikonę filtra (wygląda jak lejek, znajdziesz ją obok ikony lupy na górnym pasku) i w polu <em>Filter</em> wpisz <code>products</code>.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network-filter.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network-filter.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Następnie kliknij nazwę znalezionego połączenia – otworzy się widok, w którym zobaczysz wszystkie nagłówki (<em>headers</em>). W sekcji <em>General</em> znajdują się najważniejsze nagłówki naszego zapytania – takie jak np. adres, z którym się połączyliśmy. Bardzo ważną pozycją jest <em>Status Code</em>, w której znajdziesz <a href="https://pl.wikipedia.org/wiki/Kod_odpowiedzi_HTTP" target="_blank">kod odpowiedzi HTTP</a>, informujący o tym, czy połączenie się powiodło (kod 200), czy np. nie znaleziono takiego adresu (kod 404) lub nie możemy zobaczyć tej treści bez zalogowania (kod 403).</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network-details.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/devtools-network-details.png" alt="image" style="width: auto; max-width: 50%;"></a>
<p>Poniżej w sekcji <em>Response Headers</em> znajdziesz nagłówki odpowiedzi z serwera. Pokażą Ci np. że zawartość odpowiedzi jest w formacie JSON, z kodowaniem znaków w UTF-8 (<code>Content-Type: application/json; charset=utf-8</code>).</p>
<div class="bc-note alert-success">
<h4 class="alert-heading text-center">Czym są nagłówki?</h4>
<p>Każde zapytanie do serwera i każda jego odpowiedź zawiera nagłówek (<em>header</em>) oraz opcjonalnie treść (<em>body</em>). W nagłówku znajdziesz parametry tego zapytania. Większość z nich jest automatycznie nadawana przez przeglądarkę lub serwer, ale niektóre z nich będą również nadawane przez nas – przekonasz się o tym, gdy będziemy wysyłać zamówienie do API.</p>
</div>
<p>Kolejnym miejscem, które zawiera wartościowe informacje, jest zakładka <em>Preview</em>, w której znajdziesz treść odpowiedzi z serwera. W naszym przypadku będzie to lista produktów, które przesłało nasze API w odpowiedzi na zapytanie.</p>
<p>Te informacje mogą nie być bardzo interesujące w tym momencie, ale warto już teraz sprawdzić, w jaki sposób możemy badać połączenia z API. Dzięki temu łatwiej będzie nam za chwilę sprawdzić, jak działa wysyłanie zamówienia do API.</p>
<p>Pamiętaj, aby w <code>package.json</code> z powrotem ustawić <code>--delay 250</code> i zrestartować task <code>watch</code>!</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1980" class="card submodule completed" data-bootcamp-user-submodule-id="607294" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.9. <span>Wysyłanie zam&oacute;wienia do API</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Potrafisz już pobierać dane z API i wyświetlać je na stronie. Teraz zajmiemy się odwrotną operacją, czyli wysyłaniem danych do API. W naszym przypadku będą to dane zamówienia: wykorzystamy do tego element <code>&lt;form&gt;</code>, znajdujący się w koszyku.</p>
<p>Idea będzie następująca. Dodamy nasłuchiwacz na nasz formularz. Kiedy wykryjemy, że ktoś chce go wysyłać (kliknięto na przycisk "Order"), skompletujemy informacje na temat zamówienia i wyślemy je za pomocą <code>fetch</code> do serwera. Oczywiście pod odpowiedni endpoint i przy użyciu odpowiedniej metody. Serwer powinien je odebrać i zapisać w bazie danych. Tym samym pracownicy pizzerii będą w stanie dowiedzieć się o nowym zamówieniu. Wszystko jasne?</p>
<h3>Przygotowanie serwera</h3>
<p>Jak mówiliśmy już wcześniej, nasz serwer obsługuje tylko takie kolekcje danych, jakie rozpoznał w pliku <code>app.json</code>. Jeśli jest w nim tylko tablica <code>products</code>, to tylko taką kolekcję danych dodano do bazy. A my potrzebujemy jeszcze <code>orders</code>.  Owszem, link w <code>settings</code> już przygotowaliśmy, ale sam serwer o niczym jeszcze nie wie.</p>
<p>Zacznij więc od edycji pliku <code>src/db/app.json</code> i dodania do obiektu w nim zawartego nowej tablicy – <code>orders</code>. Na razie powinna być pusta.</p>
<h3>Wychwycenie submitu formularza</h3>
<p>W koszyku umieściliśmy formularz, który domyślnie przeładowuje stronę po wciśnięciu guzika "ORDER". Zaczynamy więc od zablokowania tej domyślnej akcji.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Działamy oczywiście w klasie <code>Cart</code>.</p>
<p>Zacznij od przygotowania referencji do elementu formularza. <code>thisCart.dom.form</code> powinien kierować do elementu ukrytego pod selektorem <code>select.cart.form</code> (to nasz formularz).</p>
<p>Następnie w metodzie <code>Cart.initActions</code> dodaj nasłuchiwacz dla tego formularza. Nasłuchuj na event <code>'submit'</code>, a w funkcji callback dodaj instrukcję, która zablokuje domyślne zachowanie formularza. Po to, aby jego wysyłka nie przeładowywała strony. Od razu sprawdź, czy blokada domyślnej akcji działa – kliknięcie guzika "ORDER" nie powinno teraz niczego robić.</p>
<p>Oprócz tego, w tej samej funkcji callback dodaj wywołanie metody <code>thisCart.sendOrder</code>. Zajmiemy się nią szczegółowo za chwilę. Jej zadaniem będzie właśnie kompletowanie informacji o zamówieniu i późniejsza wysyłka ich do serwera. Wywołaj ją bez żadnych argumentów.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-DmWu4JJx_-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż wskazówki</a>
    <a href="#collapse-DmWu4JJx_-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj wskazówki</a>
  </span>
</p>
<div id="collapse-DmWu4JJx_-toggle" class="collapse">
<p>Pamiętaj, że wszystkie referencje do elementów DOM przygotowujemy w metodzie <code>getElements</code>. Dla czytelności.</p>
<p>Domyślne zachowanie zdarzenia możemy wyłączyć za pomocą metody <code>preventDefault</code>.</p>
</div>
</div>
<p>Następnie możemy zająć się tą metodą. Dodaj więc ją teraz <code>sendOrder</code> i standardowo zadbaj o przygotowanie skrótu do <code>this</code> (const <code>thisCart = this</code>).</p>
<p>Co dalej?</p>
<p>Zaczniemy od przygotowania adresu endpointu, z którym chcemy się połączyć.</p>
<pre><code class="language-js">const url = settings.db.url + '/' + settings.db.orders;
</code></pre>
<p>Oczywiście otrzymamy z takiego połączenia link <code>http://localhost:3131/orders</code>.</p>
<p>Następnie czas przygotować dane, które chcemy wysłać do serwera. Utworzenie obiektu z odpowiednimi danymi będzie właśnie Twoim zadaniem.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Serwer w przypadku zamówień będzie oczekiwał na następujący obiekt:</p>
<pre><code class="language-js">{ 
  address: adres klienta wpisany w koszyku,
  phone: numer telefonu wpisany w koszyku,
  totalPrice: całkowita cena za zam&oacute;wienie,
  subTotalPrice: cena całkowita - koszt dostawy,
  totalNumber: całkowita liczba sztuk,
  deliveryFee: koszt dostawy,
  products: tablica obecnych w koszyku produkt&oacute;w
}
</code></pre>
<p>Twoim zadaniem jest stworzenie obiektu o nazwie <code>payload</code> właśnie o takiej strukturze. Postaraj się poprawnie przygotować wartość wszystkich pól z wyjątkiem ostatniego. Nim zajmiemy się dopiero za chwilę. Na razie <code>payload.products</code> będzie po prostu pustą tablicą.</p>
<p>Aby sprawdzać, jak Ci idzie, warto dodać pod tym obiektem <code>console.log</code> pokazujący jego zawartość. Dzięki temu łatwo będziesz w stanie ustalić, czy obiekt zawiera wszystko, co trzeba.</p>
<p class="text-center">
  <span class="collapse-toggles">
    <a href="#collapse-0iA5a6RbuM-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Pokaż wskazówki</a>
    <a href="#collapse-0iA5a6RbuM-toggle" class="btn btn-primary collapsed" data-toggle="collapse">Ukryj wskazówki</a>
  </span>
</p>
<div id="collapse-0iA5a6RbuM-toggle" class="collapse">
<ol>
<li>W tej chwili prawdopodobnie nie masz jeszcze przygotowanych referencji do inputów <code>phone</code> czy <code>address</code>. Warto dodać je więc do <code>getElements</code> przed rozpoczęciem pracy.</li>
<li>Aby dojść do wartości elementu input, skorzystaj z jego właściwości <code>value</code>.</li>
<li>Bardzo łatwo możesz dojść do wartości <code>totalPrice</code>. Dlaczego? Gdy pisaliśmy metodę <code>update</code>, to zadbaliśmy o to, aby właśnie ta informacja była zapisana jako właściwość (<code>thisCart.totalPrice</code>). Zrobiliśmy to z myślą o przyszłości. Tak, żeby właśnie w takiej sytuacji jak ta, móc łatwo dojść do tej informacji. <code>totalNumber</code> czy <code>subTotalPrice</code> były już jednak w tamtej funkcji zapisywane tylko jako stałe, a co za tym idzie, dostępne tylko w niej... Może więc warto zmodyfikować tamtą metodę? Tak, aby <code>totalNumber</code> i <code>subTotalPrice</code> były również właściwościami? Wtedy będzie można dojść do ich wartości również poza metodę <code>update</code>. Właśnie np. w <code>sendOrder</code>!</li>
</ol>
</div>
</div>
<p>Teraz zajmiemy się już <code>payload.products</code>.</p>
<p>W Twojej klasie <code>Cart</code> jest już właściwość, która może wydawać się wręcz idealna dla <code>payload.products</code>. Mowa o <code>thisCart.products</code>, czyli tablicy z instancjami <code>cartProduct</code>. Jednak czy aby na pewno?</p>
<p>Zauważ, że instancja klasy <code>cartProduct</code> posiada informacje, które serwerowi się przydadzą (np. <code>id</code>, <code>name</code>, <code>price</code>, <code>amount</code>...), ale też masę niepotrzebnych, np. cały obiekt <code>thisCartProduct.dom</code> z referencjami do elementów HTML produktu jest kompletnie zbędny! Co możemy więc w takiej sytuacji zrobić?</p>
<p>Przypomnij sobie, jak rozwiązaliśmy ten problem w momencie przekazywanie produktu z klasy <code>Product</code> do koszyka. Mieliśmy tam analogiczną sytuację. Nie chcieliśmy przekazywać całej instancji, więc przygotowaliśmy metodę <code>prepareCartProduct</code>, która przygotowywała nam nowy obiekt. Bardzo mały, będący podsumowaniem całej instancji i posiadający tylko te właściwości, które koszykowi są potrzebne.</p>
<p>Tak samo postąpimy również teraz.</p>
<div class="bc-note alert-info">
<h4 class="alert-heading text-center">Ćwiczenie</h4>
<p>Przejdź do klasy <code>CartProduct</code> i przygotuj w niej nową metodę <code>getData</code>. Zadbaj o to, aby zwracała ona nowy obiekt, który posiada tylko te właściwości z całej instancji <code>thisCartProduct</code>, które naprawdę będą potrzebne w momencie zapisywania zamówienia, a więc <code>id</code>, <code>amount</code>, <code>price</code>, <code>priceSingle</code>, <code>name</code> i <code>params</code>.</p>
</div>
<p>Kiedy już to zrobisz, możemy bardzo łatwo zapełnić naszą tablicę <code>payload.products</code> nie całymi instancjami produktów w koszyku, a tylko tymi mini obiektami z ich podsumowaniem.</p>
<p>Wróć więc do metody <code>Cart.sendOrder</code> i pod obiektem <code>payload</code> dodaj następujący kod:</p>
<pre><code class="language-js">for(let prod of thisCart.products) {
  payload.products.push(prod.getData());
}
</code></pre>
<p>Popatrz tylko. Nie dodajemy do <code>payload.products</code> całych instancji. Dodajemy tylko obiekty podsumowania. Te małe, z zaledwie kilkoma właściwościami. Bo i po co serwerowi więcej? Po co obsłudze pizzerii więcej? Nazwa produktu, liczba sztuk, wybrane opcje i cena spokojnie wystarczą im do realizacji zamówienia.</p>
<p>Mamy już przygotowany link, z którym chcemy się połączyć. Przygotowaliśmy również dane do wysyłki. Czas na wywołanie <code>fetch</code>.</p>
<pre><code class="language-js">fetch(url);
</code></pre>
<p>Czy to jednak wystarczy? Nie.</p>
<p>Po pierwsze, <code>fetch</code> domyślnie łączy się z serwerem za pomocą metody <code>GET</code>, a ta służy do pobierania danych. Tym razem chcemy wysyłać dane, więc musimy skorzystać z metody <code>POST</code>. Na szczęście takie dodatkowe opcje możemy w <code>fetch</code> bardzo łatwo ustawić za pomocą drugiego argumentu:</p>
<pre><code class="language-js">fetch(url, { method: 'POST' });
</code></pre>
<p>To wciąż nie wszystko... Skąd serwer ma wiedzieć, co dokładnie trzeba dodać do bazy danych? Musimy mu to powiedzieć. Trzeba więc wraz z requestem wysłać również nasz <code>payload</code>. Możemy to zrobić przy użyciu obiektu <code>body</code>.</p>
<pre><code class="language-js">fetch(url, { method: 'POST', body: payload });
</code></pre>
<p>To jednak wciąż za mało. Serwer komunikuje się z nami przy użyciu formatu JSON, a <code>payload</code> to zwykły obiekt JS-owy. Musimy więc skonwertować go jeszcze na format JSON. Warto również przy użyciu nagłówków (headers) poinformować serwer o tym, że ma spodziewać się właśnie JSON-a.</p>
<pre><code class="language-js">fetch(url, { 
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(payload)
});
</code></pre>
<p>Wygląda to trochę brzydko. Warto wyciągnąć sobie opcje do osobnej stałej, dla czytelności.</p>
<pre><code class="language-js">const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(payload),
};

fetch(url, options);
</code></pre>
<p>Podsumujmy teraz całość.</p>
<p>Zaczynamy od stałej <code>url</code>, w której, podobnie jak wcześniej, umieszczamy adres endpointu. Tym razem będziemy się kontaktować z endopointem zamówienia (<em>order</em>).</p>
<p>Następnie deklarujemy stałą <code>payload</code>, czyli <em>ładunek</em>. Tak bardzo często określa się dane, które będą wysłane do serwera.</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/plane.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/plane-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/plane.png 2x" class="img-inline img-left">
<p>Kolejna stała – <code>options</code> – zawiera opcje, które skonfigurują zapytanie. Po pierwsze, musimy zmienić domyślną metodę <code>GET</code> na metodę <code>POST</code>, która służy do wysyłania nowych danych do API. Następnie musimy ustawić nagłówek, aby nasz serwer wiedział, że wysyłamy dane w postaci JSON-a. Ostatni z nagłówków to <code>body</code>, czyli treść, którą wysyłamy. Używamy tutaj metody <code>JSON.stringify</code>, aby przekonwertować obiekt <code>payload</code> na ciąg znaków w formacie JSON.</p>
<p>Możesz zauważyć, że tym razem nie przypięliśmy do wywołania <code>fetch</code> żadnej funkcji w <code>.then</code>. Dlaczego?</p>
<p>A czy musimy? Zauważ, że tak naprawdę teraz, nie odbieramy żadnych danych. Wręcz przeciwnie, to my je wysyłamy. Nie za bardzo więc obchodzi nas, co serwer zwróci jako odpowiedź.</p>
<p>Jeśli jednak chcesz, możesz dodać funkcję w <code>.then</code> i ją odczytać. <code>json-server</code> w przypadku sukcesu powinien zwrócić po prostu obiekt, który został dodany do bazy, czyli w naszej sytuacji nasz <code>payload</code>.</p>
<a href="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-15.png" class="img-modal-group"><img src="https://uploads.kodilla.com/bootcamp/fer/08.ajax-api/fer-08-15.png" alt="image" style="width: auto;"></a>
<p>Czy to już wszystko i zamówienie wyśle się do serwera? Sprawdźmy! Dodaj jakiś produkt do koszyka i wciśnij guzik "ORDER". Pozornie nic się nie stało, ale sprawdź, jaki komunikat wyświetlił się w konsoli.</p>
<p>Jeśli wszystko poszło dobrze, zobaczysz swoje zamówienie z polami: <code>address</code>, <code>totalPrice</code>, <code>id</code>... Ale chwila, my nie wysyłaliśmy żadnego <code>id</code>, prawda? To pole zostało dodane przez API. Dzięki temu każde dodane zamówienie ma swój unikalny identyfikator. Nawet jeśli wiele osób jednocześnie wysłałoby zamówienie, nie musimy się obawiać, że dwa zamówienia będą miały to samo <code>id</code>.</p>
<p>Pamiętaj, że listę wszystkich zamówień możesz zobaczyć przez endpoint <strong>GET</strong> <a href="http://localhost:3131/orders" target="_blank">http://localhost:3131/orders</a> (możesz otworzyć go w przeglądarce). Możesz odświeżać stronę do woli, a złożone zamówienia nie znikną! Dzięki temu moglibyśmy napisać prosty panel administracyjny, który umożliwiałby wyświetlanie (a nawet edycję!) wszystkich zamówień.</p>

                        </div>
                    </div>
                                        <div class="card-block task-card" >
                        <h3>Zadanie: <span class="task-title">agregacja danych z koszyka</span></h3>
                        <div class="task-content">
                            <p>Zadanie jest już gotowe, ale ostatnio wykonaliśmy sporo pracy, której Mentor nie miał jeszcze okazji sprawdzić. Zaktualizuj swoje repo i pochwal się swoim wysiłkiem :)</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <div class="clearfix">
                                                                                <a href="https://kodilla.com/pl/bootcamp-task/407/607294" target="_blank" class="btn btn-info-outline">Podgląd zadania</a>
                            <form target="_blank" class="form-inline project-link-form">
                                <div class="form-group">
                                    <input type="text" name="link" class="form-control" value="https://github.com/skwiryt/project-pizzeria/commit/fc160f67228f12f6924923cb3cab4f54abbd2d36">
                                </div>
                                <button type="submit" class="btn  btn-primary " >Wyślij link <i class="fa fa-check"></i></button>
                            </form>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1981" class="card submodule completed" data-bootcamp-user-submodule-id="607295" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.10. <span>Podsumowanie</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>W tym module udało nam się stworzyć całą funkcjonalność koszyka – od dodawania do niego produktów z menu, przez podliczanie ceny zamówienia, aż po wysyłanie zamówienia do API!</p>
<p>Jak teraz widzisz, AJAX nie jest niczym strasznym. Dużo więcej czasu spędziliśmy nad agregowaniem danych do wysłania, niż nad samą implementacją AJAX-a. W następnych modułach będziemy dalej pracować z OOP, AJAX-em i API – dzięki temu zdobędziesz wprawę w posługiwaniu się tymi technikami, bez których dzisiejsze strony już nie mogą się obejść.</p>
<p>Zanim zamkniesz ten moduł, zatrzymaj się na chwilę i pobaw się stroną pizzerii. W ciągu dwóch modułów stworzyliśmy całą jej funkcjonalność, podczas gdy dopiero kilka tygodni temu zaczęliśmy naukę JS-a. Niesamowite!</p>
<img src="https://uploads.kodilla.com/bootcamp/fer/images/climb.png" srcset="https://uploads.kodilla.com/bootcamp/fer/images/climb-sm.png 1x, https://uploads.kodilla.com/bootcamp/fer/images/climb.png 2x" class="img-inline img-right">
<p>Oczywiście, możesz powiedzieć, że w tym projekcie sporo Ci pomogliśmy, przygotowując pliki projektu – ale przecież ostylowanie projektu nie sprawiłoby Ci już wielkiego problemu, prawda? Funkcje w pliku <code>functions.js</code> były też bardzo przydatne, ale przy odrobinie samozaparcia udałoby Ci się znaleźć je w internecie. Wreszcie cały algorytm skryptu, który dla Ciebie opisaliśmy – staraliśmy się pokazać Ci, jak rozwijamy go krok po kroku. Najpierw pisaliśmy ogólny plan nowych funkcjonalności, aby potem skupić się na jednym jego fragmencie, i testować go na każdym kroku za pomocą <code>console.log</code>.</p>
<p>Gdybyśmy parę tygodni temu pokazali Ci tę stronę, pewnie usłyszelibyśmy, że nie wiesz nawet, od czego zacząć. Mamy nadzieję, że teraz już wiesz, iż nawet bardzo skomplikowane skrypty można rozbić na małe, proste w realizacji kroki.</p>
<p>Na tym kończymy wspólną pracę nad menu i koszykiem naszej pizzerii. Jednak jeśli zechcesz i będziesz mieć czas – teraz lub po ukończeniu kursu – możesz kontynuować pracę nad tym projektem.</p>
<p>Stworzenie dotychczasowych skryptów kosztowało nas sporo pracy. Musimy jednak do tego przywyknąć. Pisanie w czystym JS (tzw. VanillaJS) daje nam ogromną swobodę, ale też wymaga mnóstwa pracy. Nie bez powodu na rynku pojawiły się rozwiązania ułatwiające budowanie dużych aplikacji, takie jak React czy Angular. Korzystanie z nich jest zwyczajnie łatwiejsze. Dlatego też nie przejmuj się, jeśli czujesz, że nasza pizzeria jest dla Ciebie ciężka. Już niedługo tego typu aplikacje będziemy pisali znacznie przyjemniej i szybciej przy użyciu Reacta. Potraktuj projekt Pizzerii jako ciężki początek czegoś znacznie przyjemniejszego.</p>
<h3>Dla chętnych</h3>
<p>Jeśli zechcesz rozbudować funkcjonalność tego projektu, mamy kilka pomysłów, których wdrożenie na pewno podniosłoby jego jakość.</p>
<ol>
<li>Po dodaniu produktu z menu do koszyka, ten produkt powinien powracać do domyślnego stanu (takiego samego, jak tuż po wczytaniu strony). Podobnie, po wysłaniu zamówienia, koszyk powinien się opróżniać.</li>
<li>Nie powinno być możliwości wysłania zamówienia, kiedy brakuje numeru telefonu, adresu, lub produktów w koszyku. W przypadku numeru telefonu i adresu można wprowadzić podstawową walidację, opartą np. o długość wpisanego tekstu. Błędne pola powinny otrzymać klasę <code>error</code>, która np. zmieni kolor ich obramowania na czerwony. Walidacja musi działać również po zmianie wartości (event <code>change</code>), aby po wpisaniu poprawnej wartości nie było już czerwonej ramki.</li>
<li>Koszyk mógłby mieć jakiś wizualny efekt przy zmianie jego zawartości. Np. w momencie zmiany jego zawartości, ceny i ilość sztuk w koszyku mogłyby na moment dostawać klasę, dla której byłoby ustawione <code>opacity: 0.5;</code>. W połączeniu ze stylem <code>transition</code>, może to dać ciekawy efekt – szczególnie jeśli dla tej klasy ustawimy <code>transition: none;</code>, a dla elementów bez tej klasy, np. <code>transition: opacity 0.5s;</code>.</li>
<li>Nasze zamówienie, zapisane w bazie, dla każdego produktu zawiera jego parametry i ich opcje. Nie są nam jednak potrzebne ich nazwy (<code>label</code>), ponieważ zakładamy że API potrzebuje znać tylko <code>id</code> parametrów i opcji. Dobrym pomysłem byłaby zmiana w <code>CartProduct.getData</code>, aby zamiast zwracać <code>thisCartProduct.params</code>, stworzyć nowy obiekt, który zawierałby wyłącznie <code>id</code> parametrów i opcji.</li>
<li>Aby korzystanie ze strony było wygodniejsze, możesz sprawić, aby nagłówek był <em>sticky</em>, czyli był zawsze widoczny na górze okna przeglądarki, niezależnie od przewijania strony.</li>
<li>Jeśli dobrze radzisz sobie z JS-em, możesz też spróbować stworzyć własną klasę <code>API</code>, która będzie upraszczać korzystanie z komunikacji z serwerem. Warto wtedy rozszerzyć jej funkcjonalność o wychwytywanie błędów, wyszukując w Google np. "js fetch catch errors" czy "js fetch catch 404".</li>
</ol>
<p>Jak widzisz, jest sporo rzeczy do zrobienia, ale zapewne nie znajdziesz w tej chwili czasu na ich wdrożenie. Tym bardziej istotne jest dla nas podejście obiektowe, czyli OOP. Dzięki temu, wracając do tego projektu za kilka miesięcy, będzie Ci znacznie łatwiej odnaleźć się w kodzie JS.</p>

                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                                    
                <section id="submodule-1982" class="card submodule completed" data-bootcamp-user-submodule-id="607296" >
                <!-- klasy dla section: completed current comments -->
                    <div class="card-block submodule-header clearfix">
                        <i class="fa fa-check-circle-o fa-2x"></i>
                        <i class="fa fa-play-circle-o fa-2x"></i>
                        <i class="fa fa-exclamation-circle fa-2x"></i>
                        <i class="fa fa-send-o fa-2x"></i>
                        <h2 class="bootcamp-submodule-name">9.11. <span>Quiz powt&oacute;rkowy</span></h2>
                                            </div>
                    <div class="card-block">
                        <div class="submodule-content">
                            <p>Na koniec tego modułu przygotowaliśmy dla Ciebie quiz powtórkowy. Pomoże Ci on powtórzyć wiedzę z poprzednich modułów.</p>
<p>Odpowiedzi tego quizu nie są nigdzie zapisywane, więc są tylko do Twojej wiadomości. Ten quiz ma Ci posłużyć jako pomoc w nauce – dlatego pod każdym pytaniem znajdziesz guzik, który sprawdzi poprawność Twoich odpowiedzi oraz poda Ci wyjaśnienie zagadnienia poruszanego w tym pytaniu.</p>

        <div class='kodilla-quiz'>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>1.</em> W poniższym kodzie wywołano kilka funkcji. Przy każdym wywołaniu dopisano numerek. Zastanów się, jaka będzie wartość <code>this</code> w wywoływanej funkcji w każdym z tych przypadków?</p>
<pre><code class="language-js">class Person() {
  constructor(arg) {
    this.elem = arg;
  }

  show() {
  }
}

const foo = function() {
  console.log(this) 
}

const bar = {
  func: foo
}

const buttonForJohn = document.getElementById('button-john');
buttonForJohn.addEventListener('click', foo); // 1
const johnObject = new Person('John', buttonForJohn);
johnObject.show(); // 2

foo(); // 3
bar.func(); // 4
</code></pre>

        </header>
        <ol type='a' class='answers' data-correct='1,2,5,11'>
          <li><label><input type='checkbox'> <code>/* 1 */</code> – <code>window</code></label></li>
<li><label><input type='checkbox'> <code>/* 1 */</code> – obiektem <code>buttonForJohn</code></label></li>
<li><label><input type='checkbox'> <code>/* 2 */</code> – instancją klasy <code>Person</code> z właściwością <code>arg</code></label></li>
<li><label><input type='checkbox'> <code>/* 2 */</code> – guzikiem przypisanym do danej instancji (np. <code>buttonForJohn</code>)</label></li>
<li><label><input type='checkbox'> <code>/* 2 */</code> – klasą <code>Person</code></label></li>
<li><label><input type='checkbox'> <code>/* 3 */</code> – <code>window</code></label></li>
<li><label><input type='checkbox'> <code>/* 3 */</code> – <code>undefined</code></label></li>
<li><label><input type='checkbox'> <code>/* 3 */</code> – <code>null</code></label></li>
<li><label><input type='checkbox'> <code>/* 4 */</code> – <code>window</code></label></li>
<li><label><input type='checkbox'> <code>/* 4 */</code> – <code>undefined</code></label></li>
<li><label><input type='checkbox'> <code>/* 4 */</code> – <code>null</code></label></li>
<li><label><input type='checkbox'> <code>/* 4 */</code> – obiektem <code>bar</code></label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>Kontekst funkcji, czyli to co znajduje się w obiekcie <code>this</code>, może być inny dla każdej funkcji. Z tego względu należy każde wywołanie rozpatrywać osobno. Nawet jeśli wywołujemy tę samą funkcję kilka razy, to zależnie od sytuacji może ona mieć inną wartość.</p>
<p>Jeśli nie masz pewności, czym powinno być <code>this</code> w danej sytuacji, przypomnij sobie kilka zasad, które sterują ustalaniem <code>this</code> przez JS-a. To znacznie ułatwi Ci sprawę.</p>

          </div>
        </div>
      
        </article>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>2.</em> Funkcje użyte w poniższym kodzie nie uruchomią się jednocześnie. Zaznacz poprawną kolejność ich wykonania, zakładając że odpowiedź na zapytanie do serwera otrzymamy po 1 sekundzie.</p>
<pre><code class="language-js">setTimeout(function(){
  displayAdvertisement();
}, 5000);

fetch(&quot;http://api.icndb.com/jokes/random&quot;)
  .then(function(resp) {
    return resp.json();
  })
  .then(function(result) {
    displayOnPage(result);
  })
  .catch(function(error) {
    console.warn(error);
  });

startSlider();

setTimeout(function(){
  playVideo():
}, 3000);
</code></pre>

        </header>
        <ol type='a' class='answers' data-correct='1'>
          <li><label><input type='checkbox'> <code>displayAdvertisement</code>, <code>displayOnPage</code>, <code>startSlider</code>, <code>playVideo</code></label></li>
<li><label><input type='checkbox'> <code>startSlider</code>, <code>displayOnPage</code>, <code>playVideo</code>, <code>displayAdvertisement</code></label></li>
<li><label><input type='checkbox'> <code>playVideo</code>, <code>startSlider</code>, <code>displayOnPage</code>, <code>displayAdvertisement</code></label></li>
<li><label><input type='checkbox'> <code>startSlider</code>, <code>displayAdvertisement</code>, <code>displayOnPage</code>, <code>playVideo</code></label></li>
<li><label><input type='checkbox'> <code>playVideo</code>, <code>startSlider</code>, <code>displayOnPage</code>, <code>displayAdvertisement</code></label></li>
<li><label><input type='checkbox'> <code>displayOnPage</code>, <code>displayAdvertisement</code>, <code>playVideo</code>, <code>startSlider</code></label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>Zarówno <code>setTimeout</code> jak i callback fetcha wykonają się asynchronicznie. Pierwszy <code>setTimeout</code> wykona się po 5000ms, czyli 5 sekundach. Drugi, na końcu kodu, wykona się po 3 sekundach. Założyliśmy, że serwer przyśle odpowiedź na zapytanie po 1 sekundzie, czyli szybciej od wykonania któregokolwiek <code>setTimeout</code>.</p>
<p>Z funkcji wymienionych w odpowiedziach, jedynie <code>startSlider</code> będzie wykonany synchronicznie. Oznacza to, że wykona się natychmiast. W związku z tym poprawna kolejność to:</p>
<ul>
<li><code>startSlider</code> – funkcja wykonywana synchronicznie,</li>
<li><code>displayOnPage</code> – callback fetcha, wykonany po odpowiedzi z serwera (założyliśmy 1 sekundę),</li>
<li><code>playVideo</code> – funkcja wywołana przez <code>setTimeout</code> po 3 sekundach,</li>
<li><code>displayAdvertisement</code> – funkcja wywołana przez <code>setTimeout</code> po 5 sekundach.</li>
</ul>
<p>Istnieje jednak możliwość innej kolejności – gdyby wykonanie funkcji <code>startSlider</code> trwało bardzo długo, to ostatni <code>setTimeout</code> nie zostałby wykonany dopóki <code>startSlider</code> nie zakończy działania. Taka sytuacja mogłaby mieć miejsce np. gdyby funkcja <code>startSlider</code> wyświetliła <code>alert</code> – wtedy działanie JS będzie zatrzymane do czasu jego zamknięcia.</p>
<p>Załóżmy, że użytkownik pozostawił <code>alert</code> otwarty przez ponad 5 sekund – wtedy kolejność wykonania funkcji wyglądała tak:</p>
<ul>
<li><code>startSlider</code> – funkcja wykonywana synchronicznie,</li>
<li><code>displayOnPage</code> – callback fetcha, wykonany po odpowiedzi z serwera (założyliśmy 1 sekundę), ale ponieważ w tym momencie był otwarty <code>alert</code>, to wykona się tuż po jego zamknięciu,</li>
<li><code>displayAdvertisement</code> – funkcja wywołana przez <code>setTimeout</code> po 5 sekundach, ale ponieważ w tym momencie był otwarty <code>alert</code>, to wykona się tuż po jego zamknięciu,</li>
<li><code>playVideo</code> – funkcja wywołana przez <code>setTimeout</code> po 3 sekundach od zakończenia działania funkcji <code>startSlider</code>.</li>
</ul>
<p>Ten przykład pokazuje, że czasami nasz kod może zachowywać się inaczej niż byśmy się tego spodziewali. W szczególności w przypadku funkcji <code>alert</code>, <code>prompt</code> i <code>confirm</code> należy zachować szczególną uwagę (a najlepiej ich unikać, w miarę możliwości).</p>

          </div>
        </div>
      
        </article>
      
        <article class='question' data-type='multiple-choice'>
      
        <header>
          <p><em>3.</em> Wybierz poprawne przykłady formatu JSON:</p>

        </header>
        <ol type='a' class='answers' data-correct='0,3,4,7,9,11'>
          <li><label><input type='checkbox'> <code>{}</code></label></li>
<li><label><input type='checkbox'> <code>{name: 'John', age: 46}</code></label></li>
<li><label><input type='checkbox'> <code>{'name': 'John', 'age': 46}</code></label></li>
<li><label><input type='checkbox'> <code>{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 46}</code></label></li>
<li><label><input type='checkbox'> <code>{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;46&quot;}</code></label></li>
<li><label><input type='checkbox'> <code>[Paris, London]</code></label></li>
<li><label><input type='checkbox'> <code>['Paris', 'London']</code></label></li>
<li><label><input type='checkbox'> <code>[&quot;Paris&quot;, &quot;London&quot;]</code></label></li>
<li><label><input type='checkbox'> <code>[{day: 'Monday', times: ['12:00', '14:00']}, {day: 'Tuesday', times: ['13:00', '17:00']}]</code></label></li>
<li><label><input type='checkbox'> <code>[{&quot;day&quot;: &quot;Monday&quot;, &quot;times&quot;: [&quot;12:00&quot;, &quot;14:00&quot;]}, {&quot;day&quot;: &quot;Tuesday&quot;, &quot;times&quot;: [&quot;13:00&quot;, &quot;17:00&quot;]}]</code></label></li>
<li><label><input type='checkbox'> <code>[{&quot;day&quot;: &quot;Monday&quot;, &quot;times&quot;: &quot;[&quot;12:00&quot;, &quot;14:00&quot;]&quot;}, {&quot;day&quot;: &quot;Tuesday&quot;, &quot;times&quot;: &quot;[&quot;13:00&quot;, &quot;17:00&quot;]&quot;}]</code></label></li>
<li><label><input type='checkbox'> <code>[{&quot;day&quot;: &quot;Monday&quot;, &quot;times&quot;: &quot;12:00, 14:00&quot;}, {&quot;day&quot;: &quot;Tuesday&quot;, &quot;times&quot;: &quot;13:00, 17:00&quot;}]</code></label></li>
        </ol>
        <div class="buttons text-center">
          <button class="button-ok btn btn-primary">Sprawdź odpowiedź</button>
        </div>
      
      
        <div class='explanation'>
          <div class="bc-note alert-success">
            <h4 class="alert-heading text-center">Wyjaśnienie</h4>
      <p>To zadanie może przyprawiać o ból głowy, ale wystarczy pamiętać o paru zasadach, aby sobie z nim poradzić!</p>
<p>Po pierwsze, JSON może być obiektem lub tablicą. Zarówno klucze w obiektach, jak i wartości tekstowe muszą być zamknięte w podwójnych cudzysłowach <code>&quot; &quot;</code>.</p>
<p>Już na tym etapie możemy wykluczyć wszystkie przypadki, w których klucz w obiekcie nie jest zamknięty w cudzysłowach, lub są to pojedyncze cudzysłowy.</p>
<p>Idąc dalej, wartości w obiektach i tablicach mogą być liczbami (bez cudzysłowów), tekstami (z cudzysłowami), tablicami lub obiektami. Zwróć szczególną uwagę na przykład z <code>&quot;46&quot;</code> – liczbę możemy potraktować jako liczbę, albo jako tekst. Łatwo sobie wyobrazić sytuację, w której np. numer mieszkania zwykle będzie cyfrą, ale może też zawierać litery (np. <code>1b</code>), więc bezpieczniej będzie zawsze traktować go jako tekst.</p>
<p>Jeśli wartością jest tablica, to nie zamykamy jej w cudzysłowach – stąd zapis <code>&quot;times&quot;: &quot;[&quot;12:00&quot;, &quot;14:00&quot;]&quot;</code> jest niepoprawny i możemy albo użyć tablicy, czyli zapisać <code>&quot;times&quot;: [&quot;12:00&quot;, &quot;14:00&quot;]</code>, albo potraktować to pole jako tekst, wtedy używając zapisu <code>&quot;times&quot;: &quot;12:00, 14:00&quot;</code>.</p>
<p>Możesz sprawdzić poprawność odpowiedzi oznaczonych jako poprawne, wklejając do konsoli (w narzędziach developerskich przeglądarki) poniższy fragment kodu:</p>
<pre><code class="language-js">console.log(JSON.parse(`{}`));
console.log(JSON.parse(`{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 46}`));
console.log(JSON.parse(`{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: &quot;46&quot;}`));
console.log(JSON.parse(`[&quot;Paris&quot;, &quot;London&quot;]`));
console.log(JSON.parse(`[{&quot;day&quot;: &quot;Monday&quot;, &quot;times&quot;: [&quot;12:00&quot;, &quot;14:00&quot;]}, {&quot;day&quot;: &quot;Tuesday&quot;, &quot;times&quot;: [&quot;13:00&quot;, &quot;17:00&quot;]}]`));
console.log(JSON.parse(`[{&quot;day&quot;: &quot;Monday&quot;, &quot;times&quot;: &quot;12:00, 14:00&quot;}, {&quot;day&quot;: &quot;Tuesday&quot;, &quot;times&quot;: &quot;13:00, 17:00&quot;}]`));
</code></pre>

          </div>
        </div>
      
        </article>
      
        </div>
        
<style>
  .kodilla-quiz .question {
    margin-bottom: 1.5em;
  }
  .kodilla-quiz .explanation {
    display: none;
  }
  .kodilla-quiz li>label {
    display: inline-block;
    padding-top: 1px;
    vertical-align: top;
  }
</style>
<script>
  if(typeof initQuizzes == 'undefined'){
    function initQuizzes(){
      var types = {
        'multiple-choice': initMultipleChoice,
      };

      var questions = document.querySelectorAll('.kodilla-quiz .question');

      for(var i=0; i<questions.length; i++){
        var question = questions[i];
        var initFunc = types[question.dataset.type];

        if(typeof(initFunc) != 'undefined' && !question.classList.contains('initiated')){
          question.classList.add('initiated');
          initFunc(question);
        }
      }
    }

    function initMultipleChoice(question){
      var answers = question.querySelector('.answers');
      var inputs = answers.querySelectorAll('input');
      var buttons = question.querySelector('.buttons');
      var buttonOK = buttons.querySelector('.button-ok');
      var explanation = question.querySelector('.explanation');
      var correct = question.querySelector('[data-correct]').dataset.correct.split(',');

      buttonOK.addEventListener('click', function(e){
        e.preventDefault();

        var inputsChecked = answers.querySelectorAll('input:checked');
        if(inputsChecked.length == 0){
          alert('Wybierz co najmniej jedna odpowiedź');
          return;
        }

        correct.forEach(function(index){
          inputs[index].parentNode.parentNode.classList.add('text-success', 'text-bold');
        });

        for (var i = 0; i < inputs.length; i++) {
          var input = inputs[i];
          var li = input.parentNode.parentNode;
          input.setAttribute('disabled', true);
          
          if(input.checked){
            li.classList.add('text-bold');
            
            if(!li.classList.contains('text-success')){
              li.classList.add('text-danger');
            }
          }

        }
        
        if(explanation) explanation.style.display = 'block';
        buttons.setAttribute('hidden', true);
      });
    }
  }
  initQuizzes();
</script>

      
                        </div>
                    </div>
                                        <div class="card-block submodule-footer clearfix  completed ">
                                                <small>Jeśli masz wątpliwości do powyższego materiału, to - zanim zatwierdzisz - zapytaj na czacie :)</small>
                                                <div class="clearfix">
                                                                                <button class="btn  btn-primary "><i class="fa fa-check"></i><span>Zapoznałe(a)m się!</span></button>
                                                                                                    </div>
                    </div>
                </section>
                            </main>
        </div>
    </section>
</main>
;
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<script type="text/x-translation" data-translation-name="SentBootcampLinkReviewFormMessage">Wysłano link do zatwierdzenia</script>
    <div id="alerts">
    <div class="alert alert-danger" role="alert">
        <i class="fa fa-exclamation" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                        </ul>
    </div>
    <div class="alert alert-success" role="alert">
        <i class="fa fa-check" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                </ul>
    </div>
    <div class="alert alert-warning" role="alert">
        <i class="fa fa-warning" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                </ul>
    </div>
    <div class="alert alert-info" role="alert">
        <i class="fa fa-info" aria-hidden="true"></i>
        <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
            <span aria-hidden="true">&times;</span>
            <span class="sr-only">Zamknij</span>
        </button>
        <ul>
                    </ul>
    </div>
    <div class="container">
        <div class="alert alert-notify" role="alert">
            <i class="fa fa-info" aria-hidden="true"></i>
            <button type="button" class="close" data-hide="alert" aria-label="Zamknij">
                <span aria-hidden="true">&times;</span>
                <span class="sr-only">Zamknij</span>
            </button>
            <ul>
                            </ul>
        </div>
    </div>
</div>
    <div class="modal fade informator-modal" id="informator" tabindex="-1" role="dialog" aria-labelledby="informatorModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <img src="https://kodilla.com/static/img/logo-menu.png?00000" alt="Logo Kodilla" class="brand-logo">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <i class="fa fa-times" aria-hidden="true"></i>
                </button>
            </div>
            <div class="modal-body content-container">
                <h3>Zam&oacute;w szczeg&oacute;łowy informator</h3>
                <form class="row js-ajax-form" data-view-class="InformatorForm" action="https://kodilla.com/pl/download-informator" method="post">
                    <input type="hidden" name="ga-pobieranie-informatora-z-modala" value="wypelnienie">
                    <input type="hidden" name="tags[0]" value="informator">
                                        <div class="user-data-container">
                        <input type="text" class="form-control" name="firstname" placeholder="Imię">
                        <input type="text" class="form-control" name="surname" placeholder="Nazwisko">
                    </div>
                    <div class="user-data-container">
                        <input type="email" class="form-control" name="email" placeholder="Email" required/>
                        <input type="tel" class="form-control" name="phone" placeholder="Numer telefonu" pattern="^([\+][0-9]{1,3}([ \.\-])?)?([\(]{1}[0-9]{3}[\)])?([0-9 \.\-]{1,15})$" title="Wpisz poprawny numer telefonu, np. 453 674 897" minlength="9" maxlength="15" data-custom-message="Wpisz poprawny numer telefonu, np. 453 674 897">
                    </div>
                    <div class="terms-box">
                        <label>
                            <input name="accept_terms" value="true" data-custom-message="Prosimy o zaakceptowanie regulaminu" type="checkbox" class="form-control input-checkbox" required>
                            <span>Akceptuję <a target="_blank" href="https://kodilla.com/pl/regulamin">regulamin</a>  i nie wnoszę zastrzeżeń</span>
                        </label>
                    </div>
                    <div class="personal-terms-box">
                        <label>
                            <input name="accept_marketing" value="true" data-custom-message="Jeśli chcesz otrzymać dostęp do materiał&oacute;w, konieczna jest akceptacja obydwu zg&oacute;d" type="checkbox" class="form-control input-checkbox" required>
                            <span>Chcę otrzymywać newsletter, informacje o promocjach i produktach dostępnych w Kodilla.
                                <span class="details-button" data-action="show-details" data-identifier="personal-terms-details-informator">Czytaj więcej</span>
                                <span class="display-none" data-identifier="personal-terms-details-informator">Wyrażam zgodę na otrzymywanie informacji handlowych od Kodilla na podany przeze mnie adres e-mail. Zgoda jest dobrowolna, jednakże niezbędna do otrzymywania informacji o produktach, promocjach i o tym, co u nas słychać. Administratorem danych jest Codemy S.A. z siedzibą we Wrocławiu, Plac Powstańc&oacute;w Śląskich 13/4. Mam prawo cofnąć zgodę w każdym czasie, jednak wtedy nie będę otrzymywać informacji. Dane mogą być przetwarzane pomimo cofnięcia zgody wyłącznie w takim zakresie i celu, w jakim ich przetwarzanie jest niezbędne do ustalenia, dochodzenia lub obrony roszczeń Administratora w związku z udzieloną zgodą. Mam prawo dostępu do danych, sprostowania, usunięcia, ograniczenia przetwarzania, prawo wniesienia sprzeciwu, skargi do organu nadzorczego i przeniesienia danych. Szczeg&oacute;łowe informacje znajdują się na stronie kodilla.com, zakładka &quot;Polityka Prywatności&quot;.</span>
                            </span>
                        </label>
                    </div>
                    <div class="display-none">
                        <input type="text" name="myName" value="">
                    </div>
                    <div class="">
                        <button type="submit" class="btn btn-primary">
                            Pobierz Informator
                            <i data-role="loading-icon" class="fa fa-spinner fa-spin fa-1x fa-fw display-none"></i>
                        </button>
                    </div>
                </form>
                <a href="https://kodilla.com/pl/informator" id="informator-link" target="_blank" class="display-none"></a>
            </div>
            <div class="modal-footer">
                <p>Pobranie informatora do niczego nie zobowiązuje</p>
            </div>
        </div>
    </div>
</div>
<footer class="site-footer">
                <section class="footer-lower">
            <nav class="container">
                <a class="navbar-img" href="https://kodilla.com/pl">
                    <svg id="kodilla-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 168 29.553" width="168" height="30">
                        <defs>
                            <style>
                                .footer-logo-fill {
                                    fill: #fff;
                                }
                            </style>
                        </defs>
                        <g id="Group_1" data-name="Group 1" transform="translate(23.59)">
                            <path id="KODILLA_copy_5_1_" class="footer-logo-fill" d="M78.058,0a14.758,14.758,0,1,0,.075,0Zm0,23.739a8.939,8.939,0,0,1-8.944-8.907V14.8c0-4.957,4.584-.708,8.907-.708,4.919,0,9.019-4.211,9.019.708a8.978,8.978,0,0,1-8.981,8.944Z" transform="translate(-63.3)"/>
                            <ellipse id="eye_copy_4_1_" class="footer-logo-fill" cx="3.876" cy="3.876" rx="3.876" ry="3.876" transform="translate(9.462 13.2) rotate(-28.436)"/>
                        </g>
                        <path id="Path_1" data-name="Path 1" class="footer-logo-fill" d="M0,29.819V.9H6.671V13.347L17.255.9h7.491L13.938,13.794,25.491,29.819h-7.6l-8.2-11.665-3.019,3.13v8.5H0Z" transform="translate(0 -0.565)"/>
                        <path id="Path_2" data-name="Path 2" class="footer-logo-fill" d="M151.4,29.819V.9h10.807a15.515,15.515,0,0,1,6.261,1.155,12.966,12.966,0,0,1,4.509,3.093A12.918,12.918,0,0,1,175.7,9.732a17.245,17.245,0,0,1,.932,5.59,16.821,16.821,0,0,1-1.006,5.963,12.227,12.227,0,0,1-2.907,4.547,13.484,13.484,0,0,1-4.547,2.944,15.964,15.964,0,0,1-5.925,1.043Zm18.41-14.5a11.274,11.274,0,0,0-.522-3.466,7.723,7.723,0,0,0-1.491-2.72,6.616,6.616,0,0,0-2.385-1.752,8.055,8.055,0,0,0-3.205-.6h-4.1v17.18h4.1a7.985,7.985,0,0,0,3.242-.634,6.8,6.8,0,0,0,2.385-1.826,8.286,8.286,0,0,0,1.453-2.72A11.634,11.634,0,0,0,169.81,15.322Z" transform="translate(-94.978 -0.565)"/>
                        <path id="Path_3" data-name="Path 3" class="footer-logo-fill" d="M228.3,29.819V.9h6.671V29.819Z" transform="translate(-143.219 -0.565)"/>
                        <path id="Path_4" data-name="Path 4" class="footer-logo-fill" d="M259.9,29.819V.9h6.671V23.968h14.012v5.851Z" transform="translate(-163.043 -0.565)"/>
                        <path id="Path_5" data-name="Path 5" class="footer-logo-fill" d="M327.371,23.931V.9H320.7V29.819h18.522l2.124-5.851H327.371Z" transform="translate(-201.185 -0.565)"/>
                        <path id="Path_6" data-name="Path 6" class="footer-logo-fill" d="M388.547.9h6.037L405.13,29.819h-6.857l-2.236-6.484h-9.019l-2.2,6.484H378Zm6.373,17.851L391.528,8.54l-3.466,10.211Z" transform="translate(-237.13 -0.565)"/>
                    </svg>
                </a>
                <ul class="nav">
                    <li>
                        <a href="https://kodilla.com/pl/regulamin" rel="nofollow">Regulamin</a>
                    </li>
                    <li>
                        <a href="https://kodilla.com/pl/polityka-prywatnosci" rel="nofollow">Polityka prywatności</a>
                    </li>
                    <li class="nav-item">&copy; 2021 Kodilla</li>
                </ul>
            </nav>
        </section>
    </footer>

<!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KN2WWBH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <script src="https://kodilla.com/static/js/libs/jquery-2.1.4.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/js.cookie-2.1.0.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/jquery-dateFormat.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/bootstrap.min.js?00000"></script>
<script>
    (function () {
        $(document).ready(function () {
            if (window.location.hash === '#informator-modal') {
                showInformator();
            }
        });

        $('[data-action="show-modal"]').click(function() {
            showInformator();
        });

        function showInformator() {
            $('#informator').modal('show');
        }
    })();
</script>
<script src="https://kodilla.com/build/minified/js/fb-0370c8f03e.js" async></script>
<script src="https://kodilla.com/build/minified/js/call-us-d1ed4dfa39.js"></script>
<script>
    if (document.querySelector('main.editor')) {
        document.querySelector('body').classList.add('editor');
    }
</script>

<script type="text/javascript">
    (function(e,t,o,n,p,r,i){e.visitorGlobalObjectAlias=n;e[e.visitorGlobalObjectAlias]=e[e.visitorGlobalObjectAlias]||function(){(e[e.visitorGlobalObjectAlias].q=e[e.visitorGlobalObjectAlias].q||[]).push(arguments)};e[e.visitorGlobalObjectAlias].l=(new Date).getTime();r=t.createElement("script");r.src=o;r.async=true;i=t.getElementsByTagName("script")[0];i.parentNode.insertBefore(r,i)})(window,document,"https://diffuser-cdn.app-us1.com/diffuser/diffuser.js","vgo");
    vgo('setAccount', '649095895');
    vgo('setTrackByDefault', true);

    vgo('process');
</script>

        <script src="https://kodilla.com/static/js/libs/underscore-min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-relational.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/backbone-super.min.js?00000"></script>
<script src="https://kodilla.com/static/js/libs/handlebars-v4.0.5.min.js?00000"></script>
<script src="https://kodilla.com/build/minified/js/extends/handlebars-ifCond-139a2339f7.js"></script>
<script src="https://kodilla.com/build/minified/js/application-0dcfdc1306.js"></script>
<script src="https://kodilla.com/build/minified/js/main-cf3b73d734.js"></script>
<script src="https://kodilla.com/build/minified/js/views/settings-5fc44a761b.js"></script>
<script src="https://kodilla.com/build/minified/js/views/delete-account-da2b3de486.js"></script>
<script type="text/x-translation" data-translation-name="checkAccountDeleteCalculationMessage">Wynik jest nieprawidłowy</script>
<script src="https://kodilla.com/build/minified/js/helpers/forms-222ea01b08.js"></script>
<script src="https://kodilla.com/build/minified/js/helpers/alerts-66650c3acb.js"></script>
<script>
    App.Views.InpageAlertManager = Backbone.View.extend({
        events: {
            'click [data-alert-type][data-alert-text]': 'showAlert'
        },
        showAlert: function(e) {
            var $el = $(e.currentTarget);
            App.alertsView['show'+$el.data('alertType')]([App.Translations($el.data('alertText'))]);
        }
    });
</script>
<script src="https://kodilla.com/build/minified/js/collections-c07e1162e2.js"></script>
<script src="https://kodilla.com/build/minified/js/models-4e0e4fcffb.js"></script>
<script src="https://kodilla.com/build/minified/js/views/knowledge-base-61f71273c9.js"></script>
<script>
    App.Views.LearningProgram = Backbone.View.extend({
        events: {
            'click [data-technology-desc-expander]' : 'expandTechnologyDesc'
        },

        initialize: function() {
            this.$allTechnologyDesc = this.$el.find('[data-technology-desc]');
            this.$allTechnologyExpanderIcons = this.$el.find('[data-technology-expander-icon]');
        },

        expandTechnologyDesc: function() {
            this.$allTechnologyDesc.each(function(){
                var $desc = $(this);
                $desc.slideToggle('fast');
            });
            this.$allTechnologyExpanderIcons.each(function(){
                var $icon = $(this);
                $icon.toggleClass("fa-minus");
            });
        },
    });
</script>

    <script src="https://kodilla.com/static/js/libs/tether.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/prism.min.js?00000"></script>

    <script src="https://kodilla.com/build/minified/js/views/bootcamp-1522c7c010.js"></script>
    <script src="https://kodilla.com/static/js/libs/jquery.seourl.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/perfect-scrollbar.jquery.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/fancybox/jquery.fancybox.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/moment.timezone.locales.min.js?00000"></script>
    <script src="https://kodilla.com/static/js/libs/bootstrap-datetimepicker.min.js?00000"></script>
    <script type="text/javascript">
        $(document).ready(function() {
            $("a.img-modal-group").fancybox();
        });
    </script>

<div class="modal fade" tabindex="-1" role="dialog" id="call-us-modal">
    <div class="modal-dialog modal-dialog-callus" role="document">
        <div class="modal-content call-modal">
            <div id="call-us-step1">
                <h2>Um&oacute;w się na rozmowę z doradcą Kodilli</h2>
                <p>Krok <span>1/2:</span> Podaj numer telefonu</p>
                <form action="https://kodilla.com/pl/call-center/dates/phone_calls" method="post" id="call-us-form1">
                    <input type="tel" name="phone" id="call-us-input-phone" class="call-center-input" placeholder="731771787">
                    <p class="error-message display-none" id="validation-message-phone">Pole Numer Telefonu jest wymagane. Nieprawidłowy format.</p>
                    <button class="btn btn-success" id="call-us-submit-phone">Zarezerwuj rozmowę</button>
                </form>
                <p id="call-us-counter-holder" style="display: none;">Dzisiaj już  <span id="call-us-counter" class="call-counter" data-url="https://kodilla.com/pl/call-center/counter/phone_calls">-</span> <span id="call-us-counter-text" data-one=" osoba zam&oacute;wiła rozmowę z nami." data-few=" osoby zam&oacute;wiły rozmowę z nami." data-more=" os&oacute;b zam&oacute;wiło rozmowę z nami."></span></p>
                <div class="data-protection">
                    <p>Twój numer telefonu nie będzie wykorzystywany w celach marketingowych ani przekazany dalej. Tylko oddzwonimy. Dane są przetwarzane zgodnie z <a href="/pl/polityka-prywatnosci">Polityką Prywatności</a>.</p>
                </div>
            </div>

            <div id="call-us-step2" style="display: none;">
                <h2>Wybierz dogodny termin i godzinę na rozmowę z doradcą</h2>
                <p>Krok <span>2/2:</span>
                <form action="https://kodilla.com/pl/call-center/step2/phone_calls" method="post" id="call-us-form2">
                    <div class="select-date">
                        <select name="date" id="call-us-input-date">
                        </select>
                        <select name="time" id="call-us-input-time">
                        </select>
                    </div>
                    <button class="btn btn-success" id="call-us-submit-call">Oddzwońcie do mnie!</button>
                </form>
            </div>

            <div id="call-us-step3" style="display: none;">
                <div  class="thanks">
                    <i class="fa fa-check-circle" aria-hidden="true"></i>
                    <h2>Dziękujemy za zamowienie rozmowy! Do usłyszenia w wybranym terminie!</h2>
                </div>
            </div>
        </div>
    </div>
</div>



                <style type="text/css">
    .embeddedServiceHelpButton .helpButton .uiButton {
        background-color: #1EA71C;
        font-family: "Arial", sans-serif;
    }
    .embeddedServiceHelpButton .helpButton .uiButton:focus {
        outline: 1px solid #1EA71C;
    }
</style>
<script>
    function openChat(){
        $('.helpButtonEnabled').trigger('click');
    }
</script>
<script type="text/javascript" src="https://service.force.com/embeddedservice/5.0/esw.min.js"></script>

<script type="text/javascript">
    var initESW = function(gslbBaseURL) {
        let firstName = 'Marek Baberowski'.split(" ")[0];
        let lastName = 'Marek Baberowski'.split(" ")[1];
        console.log(name);
        embedded_svc.settings.displayHelpButton = true;
        embedded_svc.settings.language = '';

        embedded_svc.settings.defaultMinimizedText =  'Skontaktuj się z nami';
        embedded_svc.settings.disabledMinimizedText = ' ';

        embedded_svc.settings.loadingText = 'Ładowanie';
        embedded_svc.settings.storageDomain = 'kodilla.com';

        embedded_svc.settings.prepopulatedPrechatFields = {
            'FirstName': firstName,
            'LastName': lastName,
            'Email': 'm.z.baberowski@gmail.com'
        };
        embedded_svc.settings.offlineSupportMinimizedText = 'Napisz do nas';

        embedded_svc.settings.enabledFeatures = ['LiveAgent'];
        embedded_svc.settings.entryFeature = 'LiveAgent';

        embedded_svc.init(
            'https://kodilla.my.salesforce.com',
            'https://kodillacommunity.force.com',
            gslbBaseURL,
            '00D1i000000VBFH',
            'Support_Kodilla',
            {
                baseLiveAgentContentURL: 'https://c.la1-c2-fra.salesforceliveagent.com/content',
                deploymentId: '5721i00000009s9',
                buttonId: '5731i0000000AJN',
                baseLiveAgentURL: 'https://d.la1-c2-fra.salesforceliveagent.com/chat',
                eswLiveAgentDevName: 'Support_Kodilla',
                isOfflineSupportEnabled: true
            }
        );
    };

    if (!window.embedded_svc) {
        var s = document.createElement('script');
        s.setAttribute('src', 'https://kodilla.my.salesforce.com/embeddedservice/5.0/esw.min.js');
        s.onload = function() {
            initESW(null);
        };
        document.body.appendChild(s);
    } else {
        initESW('https://service.force.com');
    }
</script>
        <div data-role="notifications-wrapper" class="notifications-wrapper"></div>
</body>
</html>